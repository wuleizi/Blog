<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线段树算法实践]]></title>
    <url>%2F2019%2F04%2F10%2Fpractice-in-segment-tree%2F</url>
    <content type="text"><![CDATA[本文参考了岩之痕的线段树从零开始和线段树详解，原理可以在原文细看，本文主要是对线段树的几个例题进行实现，以备复习 为什么要用线段树有这样一个场景，给定一个数组，让求任意区间的累加和。 一般有两种算法 将这个区间上的所有数累加，然后返回 先求前n项的前缀和，然后将这期间差相减 但是，如果对其中任意一个数据进行操作，就会对累加和的时间复杂度有影响，第一种只需要修改一个元素，第二种却需要将其后的所有前缀和都进行修改。所以第一种查询费时间修改不费时间，第二种查询不费时间修改费时间。线段树就是为了适应修改和统计操作而设计的。 线段树的原理线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。 具体可以参考线段树详解 线段树例子由此看出，用线段树统计的东西，必须符合区间加法，否则，不可能通过分成的子区间来得到[L,R]的统计结果。 符合区间加法的例子： 数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和 最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD ); 最大值——总最大值=max(左区间最大值，右区间最大值) 不符合区间加法的例子： 众数——只知道左右区间的众数，没法求总区间的众数 01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零 线段树的递归模版（区间和模版）定义123// 注意！线段树开始是从1开始的，不是0，否则会导致root&lt;&lt;1不是左节点vector&lt;int&gt; sum(n &lt;&lt; 2, 0); // 统计量vector&lt;int&gt; add(n &lt;&lt; 2, 0); // 惰性标记 建树123456789101112131415void PushUp(int root, vector&lt;int&gt;&amp; sum) &#123; // 向上更新 sum[rt] = sum[root &lt;&lt; 1] + sum[root &lt;&lt; 1 | 1]; // 左右值相加&#125;void build(int l, int r, int root, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; sum) &#123; if (l == r) &#123; sum[root] = nums[l - 1]; // 更新叶子结点 return; &#125; int mid = l + (r - l) / 2; build(l, m, root &lt;&lt; 1, nums, sum); // 更新左右子树 build(m + 1, r, root &lt;&lt; 1 | 1, nums, sum); PushUp(root, sum); // 更新统计信息&#125; 点修改nums[index] += c12345678910void Update(int index, int c, int l, int r, int root, vector&lt;int&gt;&amp; sum) &#123; if (l == r) &#123; sum[root] += c; return; &#125; int mid = l + (r - l) / 2; if (index &lt; mid) Update(index, c, l, mid - 1, sum); else Update(index, c, mid, r, sum); PushUp(root, sum);&#125; 区间修改nums[left, right] += c1234567891011121314151617181920212223242526// 下推时必须将统计值更新，子树更新时必须将父节点也上推更新，保证数据一致性void PushDown(int root, int l_cnt, int r_cnt, vector&lt;int&gt;&amp; sum, vector,int&gt;&amp; add) &#123; // 下推标记 add[root &lt;&lt; 1] += add[root]; add[root &lt;&lt; 1 | 1] += add[root]; // 下推统计值 sum[root &lt;&lt; 1] += add[root] * l_cnt; sum[root &lt;&lt; 1 | 1] += add[root] * r_cnt; // 清除标记 add[root] = 0; &#125;void Update(int left, int right, int c, int l, int r, int root, vector&lt;int&gt;&amp; sum, vector&lt;int&gt;&amp; add) &#123; if (left &lt;= l &amp;&amp; r &lt;= right) &#123; sum[root] += c * (r - l + 1); // 更新统计信息 add[root] += c; // 更新惰性标记 return; &#125; int m = l + (r - l) / 2; PushDown(root, m - l + 1, r - m, sum, add); // 在更新新标记的时候将旧标记下推, 分别表示左右子树的更新个数 if (left &lt;= m) Update(left, right, c, l, m, root &lt;&lt; 1, sum, add); if (m &lt; right) Update(left, right, c, m + 1, r, root &lt;&lt; 1 | 1, sum, add); PushUp(root, sum); // 因为只下推了就标记，所以需要更新本节点的统计值&#125; 查询区间1234567891011121314int Query(int left, int right, int l, int r, int root, vector&lt;int&gt;&amp; sum, vector&lt;int&gt;&amp; add) &#123; // left, right为要查找的区间，l和r表示此函数所在的查询区间 if (left &lt;= l &amp;&amp; r &lt;= right) &#123; return sum[root]; &#125; int m = l + (r - l) / 2; PushDown(root, m - l + 1, r - m, sum, add); int ret = 0; if (left &lt;= m) ret += Query(left, right, l, m, root &lt;&lt; 1, sum, add); if (m &lt; right) ret += Query(left, right, m + 1, r, root &lt;&lt; 1 | 1, sum, add); return ret;&#125; 非递归原理和实现后期更新… 线段树思路 题目练习区间最大值（头条面试题）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;climits&gt;using namespace std;class segment_tree &#123;private: vector&lt;int&gt; ans; vector&lt;int&gt; add; void PushUp(int root) &#123; ans[root] = max(ans[root &lt;&lt; 1], ans[root &lt;&lt; 1 | 1]); &#125; void PushDown(int root) &#123; if (!add[root]) return; ans[root &lt;&lt; 1] += add[root]; ans[root &lt;&lt; 1 | 1] += add[root]; add[root &lt;&lt; 1] += add[root]; add[root &lt;&lt; 1 | 1] += add[root]; add[root] = 0; &#125; void build(int root, int l, int r, vector&lt;int&gt;&amp; nums) &#123; if (l == r) &#123; ans[root] = nums[l - 1]; return; &#125; int m = l + (r - l) / 2; build(root &lt;&lt; 1, l, m, nums); build(root &lt;&lt; 1 | 1, m + 1, r, nums); PushUp(root); &#125;public: segment_tree(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); ans = vector&lt;int&gt;(n &lt;&lt; 2, INT_MIN); add = vector&lt;int&gt;(n &lt;&lt; 2, 0); build(1, 1, n, nums); &#125; void update(int index, int c, int l, int r, int root) &#123; if (l == r) &#123; ans[root] += c; return; &#125; // 因为query的时候一定会下推，所以此处不需要下推标记 int m = l + (r - l) / 2; if (index &lt;= m) update(index, c, l, m, root &lt;&lt; 1); else update(index, c, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125; void update(int L, int R, int c, int l, int r, int root) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; ans[root] += c; add[root] += c; return; &#125; PushDown(root); int m = l + (r - l) / 2; if (L &lt;= m) update(L, R, c, l, m, root &lt;&lt; 1); if (m &lt; R) update(L, R, c, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125; int query(int L, int R, int l, int r, int root) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return ans[root]; &#125; PushDown(root); int m = l + (r - l) / 2; int ret = INT_MIN; if (L &lt;= m) ret = max(ret, query(L, R, l, m, root &lt;&lt; 1)); if (m &lt; R) ret = max(ret, query(L, R, m + 1, r, root &lt;&lt; 1 | 1)); return ret; &#125;&#125;;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; segment_tree* inst = new segment_tree(nums); int t; cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) &#123; int x, y, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; c; if (x == y) inst-&gt;update(x, c, 1, n, 1); else &#123; inst-&gt;update(x, y, c, 1, n, 1); for (int j = 1; j &lt;= n; j++) cout &lt;&lt; inst-&gt;query(j, j, 1, n, 1) &lt;&lt; " "; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 区间和123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// 2019-04-13#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class segment_tree &#123;private: vector&lt;int&gt; sum; vector&lt;int&gt; add; void PushUp(int root) &#123; sum[root] = sum[root &lt;&lt; 1] + sum[root &lt;&lt; 1 | 1]; &#125; void build(vector&lt;int&gt;&amp; nums, int l, int r, int root) &#123; if (l == r) &#123; sum[root] = nums[l - 1]; return; &#125; int m = l + (r - l) / 2; build(nums, l, m, root &lt;&lt; 1); build(nums, m + 1, r, root &lt;&lt; 1 |1); PushUp(root); &#125; void PushDown(int root, int cnt_l, int cnt_r) &#123; if (add[root]) &#123; sum[root &lt;&lt; 1] += add[root] * cnt_l; sum[root &lt;&lt; 1 | 1] += add[root] * cnt_r; add[root &lt;&lt; 1] += add[root]; add[root &lt;&lt; 1| 1] += add[root]; add[root] = 0; &#125; &#125;public: segment_tree(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); sum = vector&lt;int&gt;(n &lt;&lt; 2, 0); add = vector&lt;int&gt;(n &lt;&lt; 2, 0); build(nums, 1, n, 1); &#125; void Update(int L, int R, int c, int l, int r, int root) &#123; // 更新是加c到L..R cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; sum[root] += c * (r - l + 1); add[root] += c; return; &#125; int m = l + (r - l) / 2; PushDown(root, m - l + 1, r - m); if (L &lt;= m) Update(L, R, c, l, m, root &lt;&lt; 1); if (m &lt; R) Update(L, R, c, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125; void Update(int index, int c, int l, int r, int root) &#123; if (l == r) &#123; sum[root] += c; return; &#125; int m = l + (r - l) / 2; if (index &lt;= m) Update(index, c, l, m, root &lt;&lt; 1); else Update(index, c, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125; int query(int L, int R, int l, int r, int root) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[root]; &#125; int ret = 0; int m = l + (r - l) / 2; PushDown(root, m - l + 1, r - m); if (L &lt;= m) ret += query(L, R, l, m, root &lt;&lt; 1); if (m &lt; R) ret += query(L, R, m + 1, r, root &lt;&lt; 1 | 1); return ret; &#125;&#125;;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; auto instance = new segment_tree(nums); int t; cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cout &lt;&lt; instance-&gt;query(j, j, 1, n, 1) &lt;&lt; " "; &#125; cout &lt;&lt; endl; int x, y, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; c; if (x == y) &#123; instance-&gt;Update(x, c, 1, n, 1); &#125; else &#123; instance-&gt;Update(x, y, c, 1, n, 1); &#125; &#125; return 0;&#125; 最大公因数 因为最大公因数对于加减没有惰性标记代表性，所以这里采用乘除作为update的参数 update(L,R, c, l, r, root)代表给L到R的所有数都乘以c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// 2019-04-13#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;class segment_tree &#123;private: vector&lt;int&gt; ans; vector&lt;int&gt; mul; int GCD(int a, int b) &#123; if (!b) return a; else return GCD(b, a % b); &#125; void PushUp(int root) &#123; ans[root] = GCD(ans[root &lt;&lt; 1], ans[root &lt;&lt; 1 | 1]); &#125; void PushDown(int root) &#123; if (mul[root] != 1) &#123; ans[root &lt;&lt; 1] *= mul[root]; ans[root &lt;&lt; 1 | 1] *= mul[root]; mul[root &lt;&lt; 1] *= mul[root]; mul[root &lt;&lt; 1 | 1] *= mul[root]; mul[root] = 1; &#125; &#125; void build(vector&lt;int&gt;&amp; nums, int l, int r, int root) &#123; if (l == r) &#123; ans[root] = nums[l - 1]; return; &#125; int m = l + (r - l) / 2; if (l &lt;= m) build(nums, l, m, root &lt;&lt; 1); if (m &lt; r) build(nums, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125;public: segment_tree(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // 根据不同问题要注意区间值的初始化问题，因为防止没有叶子导致上推引入异常值 // 因为GCD算法会判断!b，所以将初始值初始化为0可以直接返回a, // 这样上推可以直接调用GCD(ans[root &lt;&lt; 1], ans[root &lt;&lt; 1 | 1]) ans = vector&lt;int&gt;(n &lt;&lt; 2, 0); mul = vector&lt;int&gt;(n &lt;&lt; 2, 1); build(nums, 1, n, 1); &#125; void Update(int L, int R, int c, int l, int r, int root) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; ans[root] *= c; mul[root] *= c; return; &#125; PushDown(root); int m = l + (r - l) / 2; if (L &lt;= m) Update(L, R, c, l, m, root &lt;&lt; 1); if (m &lt; R) Update(L, R, c, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125; void Update(int index, int c, int l, int r, int root) &#123; if (l == r) &#123; ans[root] *= c; return; &#125; int m = l + (r - l) / 2; if (index &lt;= m) Update(index, c, l, m, root &lt;&lt; 1); else Update(index, c, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125; int Query(int L, int R, int l, int r, int root) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return ans[root]; &#125; PushDown(root); int ret = 0; int m = l + (r - l) / 2; if (L &lt;= m) ret = GCD(ret, Query(L, R, l, m, root &lt;&lt; 1)); if (m &lt; R) ret = GCD(ret, Query(L, R, m + 1, r, root &lt;&lt; 1 | 1)); return ret; &#125;&#125;;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; auto instance = new segment_tree(nums); int t; cin &gt;&gt; t; for (auto i = 0; i &lt; t; i++) &#123; int x, y, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; c; if (x == y) &#123; instance-&gt;Update(x, c, 1, n, 1); &#125; else &#123; instance-&gt;Update(x, y, c, 1, n, 1); &#125; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; instance-&gt;Query(x, y, 1, n, 1) &lt;&lt; endl; &#125; return 0;&#125; 字符串哈希待补充。。。 最长连续零待补充。。。 计数排序待补充。。。 扫描线待补充。。。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【面经】今日头条部分编程算法题]]></title>
    <url>%2F2019%2F03%2F14%2Finterview-coding-bytedance%2F</url>
    <content type="text"><![CDATA[本文收集2018年实验室实习面试部分编程面经以供复习 有序链表归并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode* next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;ListNode* helper(ListNode* A, ListNode* B) &#123; ListNode* ret = new ListNode(-1); ListNode* cur = ret; while (A &amp;&amp; B) &#123; if (A-&gt;val &lt; B-&gt;val) &#123; cur-&gt;next = A; A = A-&gt;next; &#125; else &#123; cur-&gt;next = B; B = B-&gt;next; &#125; cur = cur-&gt;next; &#125; while (A) &#123; cur-&gt;next = A; A = A-&gt;next; cur = cur-&gt;next; &#125; while (B) &#123; cur-&gt;next = B; B = B-&gt;next; cur = cur-&gt;next; &#125; return ret-&gt;next;&#125;int main() &#123; int n; cin &gt;&gt; n; auto A = new ListNode(-1); auto cur = A; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; cur-&gt;next = new ListNode(x); cur = cur-&gt;next; &#125; cin &gt;&gt; n; auto B = new ListNode(-1); cur = B; for (int i = 0; i &lt; n; i++) &#123; int y; cin &gt;&gt; y; cur-&gt;next = new ListNode(y); cur = cur-&gt;next; &#125; auto ret = helper(A-&gt;next, B-&gt;next); while (ret) &#123; cout &lt;&lt; ret-&gt;val &lt;&lt; " "; ret = ret-&gt;next; &#125; cout &lt;&lt; endl; return 0;&#125; 反转链表12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode* next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;ListNode* helper(ListNode* root) &#123; ListNode* ret = new ListNode(-1); while (root) &#123; auto temp = root-&gt;next; root-&gt;next = ret-&gt;next; ret-&gt;next = root; root = temp; &#125; return ret-&gt;next;&#125;int main() &#123; int n; cin &gt;&gt; n; ListNode* A = new ListNode(-1); ListNode* cur = A; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; cur-&gt;next = new ListNode(x); cur = cur-&gt;next; &#125; auto ret = helper(A-&gt;next); while (ret) &#123; cout &lt;&lt; ret-&gt;val &lt;&lt; " "; ret = ret-&gt;next; &#125; return 0;&#125; Partion and Reverse List123１-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7空间复杂度Ｏ(1)转换成：1-&gt;7-&gt;2-&gt;6-&gt;3-&gt;5-&gt;4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode* next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;ListNode* helper(ListNode* head) &#123; if (!head || !head-&gt;next) return head; ListNode* fast = head, *slow = head; while (fast &amp;&amp; fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; ListNode* head2 = slow-&gt;next; slow-&gt;next = NULL; ListNode* ret = new ListNode(-1); ListNode* cur = ret; while (head2) &#123; auto temp = head2-&gt;next; head2-&gt;next = cur-&gt;next; cur-&gt;next = head2; cur = cur-&gt;next; head2 = temp; &#125; head2 = ret-&gt;next; ret-&gt;next = NULL; cur = ret; while (head) &#123; cur-&gt;next = head; head = head-&gt;next; cur = cur-&gt;next; if (head2) &#123; cur-&gt;next = head2; head2 = head2-&gt;next; cur = cur-&gt;next; &#125; &#125; return ret-&gt;next;&#125;int main() &#123; int n; cin &gt;&gt; n; ListNode* head = new ListNode(-1); auto cur = head; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; cur-&gt;next = new ListNode(x); cur = cur-&gt;next; &#125; auto ret = helper(head-&gt;next); while (ret) &#123; cout &lt;&lt; ret-&gt;val &lt;&lt; " "; ret = ret-&gt;next; &#125; cout &lt;&lt; endl; return 0;&#125; 单链表排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 快排版本#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode* next; ListNode(int x): val(x), next(NULL) &#123;&#125;&#125;;ListNode* helper(ListNode* head) &#123; if (!head || !head-&gt;next) return head; ListNode* A = new ListNode(-1); ListNode* B = new ListNode(-1); ListNode* cur_A = A, *cur_B = B; auto base = head; head = head-&gt;next; while (head) &#123; if (head-&gt;val &lt; base-&gt;val) &#123; cur_A-&gt;next = head; cur_A = head; &#125; else &#123; cur_B-&gt;next = head; cur_B = head; &#125; head = head-&gt;next; &#125; cur_A-&gt;next = NULL; cur_B-&gt;next = NULL; A-&gt;next = helper(A-&gt;next); B-&gt;next = helper(B-&gt;next); cur_A = A; while (cur_A-&gt;next) &#123; cur_A = cur_A-&gt;next; &#125; cur_A-&gt;next = base; base-&gt;next = B-&gt;next; return A-&gt;next;&#125;int main() &#123; int n; cin &gt;&gt; n; ListNode* head = new ListNode(-1); ListNode* cur = head; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; cur-&gt;next = new ListNode(x); cur = cur-&gt;next; &#125; auto ret = helper(head-&gt;next); while (ret) &#123; cout &lt;&lt; ret-&gt;val &lt;&lt; " "; ret = ret-&gt;next; &#125; cout &lt;&lt; endl; return 0;&#125; 从一个数组里取m个数，能否和为n1234567891011121314151617181920212223242526272829303132333435// 类似于zeros and ones#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool helper(vector&lt;int&gt;&amp; nums, int m, int s) &#123; int n = nums.size(); if (n &lt; m) return false; vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(s + 1, false)); dp[0][0] = true; for (auto num : nums) &#123; for (int i = m; i &gt;= 1; i --) &#123; for (int j = s; j &gt;= num; j--) &#123; dp[i][j] = dp[i][j] || dp[i - 1][j - num]; &#125; &#125; &#125; return dp[m][s];&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; int m, s; cin &gt;&gt; m &gt;&gt; s; cout &lt;&lt; helper(nums, m, s) &lt;&lt; endl; return 0;&#125; 最大子串和求出数组中最大的子串和，并求出子串1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int ans = 0; vector&lt;int&gt; temp; vector&lt;int&gt; cur; int ret = INT_MIN; for (auto i : nums) &#123; ans += i; if (ans &lt; 0) &#123; ans = 0; cur = vector&lt;int&gt;(&#123;&#125;); &#125; else &#123; cur.push_back(i); if (ret &lt; ans) &#123; ret = ans; temp = cur; &#125; &#125; &#125; return temp;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 字符串拼接最大值一堆数字如123，324，56怎么拼接得到的值最大。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(const int&amp; a, const int&amp; b) &#123; string x = to_string(a); string y = to_string(b); return x + y &gt; y + x;&#125;string helper(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return ""; sort(nums.begin(), nums.end(), cmp); string ret; for (auto i : nums) &#123; ret += to_string(i); &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; 左边最大值找出数组中每个数字左边部分（包括自己）最大的数字，然后返回结果数组 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;math.h&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; ret(n, -1); int limit = INT_MIN; for (int i = 0; i &lt; n; i++) &#123; limit = max(limit, nums[i]); ret[i] = limit; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; Search in Rotated Sorted Array123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); int left = 0, right = n - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; if (nums[mid] == nums[right]) &#123; right --; continue; &#125; if (nums[mid] &gt; nums[right]) &#123; if (nums[mid] &gt; target &amp;&amp; nums[right] &lt; target) &#123; right = mid - 1; &#125; else left = mid + 1; &#125; else &#123; if (nums[mid] &lt; target &amp;&amp; nums[right] &gt; target) &#123; left = mid + 1; &#125; else right = mid - 1; &#125; &#125; return -1;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; int target; cin &gt;&gt; target; cout &lt;&lt; helper(nums, target)&lt;&lt; endl; return 0;&#125; 数组变化一个数组，里面的元素全部初始为0，有以下两种操作： 指定一个元素+1 所有的*2 问到达一个数组目标值得最小操作步数。1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;climits&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums) &#123; int ret = 0; int limit = INT_MAX; for (auto i : nums) &#123; if (!i) continue; else &#123; limit = min(limit, i); ret ++; &#125; &#125; int ans = 1; while (ans * 2 &lt;= limit) ret ++, ans *= 2; for (auto i : nums) &#123; if (i) ret += i - ans; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; 顺时针打印数组1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int m = nums.size(), n = nums[0].size(); int dir = 0; int a[4] = &#123;0, 1, 0, -1&#125;, b[4] = &#123;1, 0, -1, 0&#125;; int x = 0, y = 0; vector&lt;int&gt; ret; while (ret.size() &lt; m * n) &#123; if (nums[x][y] != INT_MAX) &#123; ret.push_back(nums[x][y]); nums[x][y] = INT_MAX; &#125; int X = x + a[dir], Y = y + b[dir]; if (X &lt; m &amp;&amp; X &gt;= 0 &amp;&amp; Y &gt;= 0 &amp;&amp; Y &lt; n &amp;&amp; nums[X][Y] != INT_MAX) &#123; x = X, y = Y; &#125; else dir = (dir + 1) % 4; &#125; return ret;&#125;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; nums(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; K个升序数组归并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;using namespace std;void heapfy(vector&lt;pair&lt;int, int&gt;&gt;&amp; ans, vector&lt;vector&lt;int&gt;&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; nums[ans[left].first][ans[left].second] &lt; nums[ans[smallest].first][ans[smallest].second]) &#123; smallest = left; &#125; if (right &lt; max &amp;&amp; nums[ans[right].first][ans[right].second] &lt; nums[ans[smallest].first][ans[smallest].second]) &#123; smallest = right; &#125; if (smallest != index) &#123; swap(ans[index], ans[smallest]); heapfy(ans, nums, smallest, max); &#125;&#125;vector&lt;int&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;pair&lt;int, int&gt;&gt; ans; for (int i = 0; i &lt; n; i++) &#123; if (!nums[i].empty()) ans.push_back(&#123;i, 0&#125;); &#125; vector&lt;int&gt; ret; while (!ans.empty()) &#123; ret.push_back(nums[ans[0].first][ans[0].second]); if (ans[0].second + 1 &lt; nums[ans[0].first].size()) &#123; ans[0].second ++; heapfy(ans, nums, 0, ans.size()); &#125; else &#123; ans[0] = ans.back(); ans.pop_back(); heapfy(ans, nums, 0, ans.size()); &#125; &#125; return ret;&#125;int main() &#123; int k; cin &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; nums; for (int i = 0; i &lt; k; i++) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; ans(n, 0); for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; ans[j]; &#125; nums.push_back(ans); &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; 二叉树的最近公共祖先123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct TreeNode &#123; string val; TreeNode* left; TreeNode* right; TreeNode(string s) : val(s), left(NULL), right(NULL) &#123;&#125;&#125;;TreeNode* build(vector&lt;string&gt;&amp; nums, int&amp; index) &#123; int n = nums.size(); if (index &gt;= n) return NULL; auto val = nums[index++]; if (val == "#") return NULL; auto ret = new TreeNode(val); ret-&gt;left = build(nums, index); ret-&gt;right = build(nums, index); return ret;&#125;string helper1(TreeNode* root, string a, string b, bool&amp; m) &#123; if (!root) return ""; if (root-&gt;val == a || root-&gt;val == b) m = true; bool ml = false, mr = false; string l = helper1(root-&gt;left, a, b, ml); if (ml) &#123; if (m) return root-&gt;val; m = true; string r = helper1(root-&gt;right, a, b, mr); if (mr) return root-&gt;val; else return l; &#125; else &#123; string r = helper1(root-&gt;right, a, b, mr); if (m &amp;&amp; mr) return root-&gt;val; if (mr) &#123; m = mr; return r; &#125; else return ""; &#125;&#125;string helper(vector&lt;string&gt;&amp; nums, string a, string b) &#123; int index = 0; auto root = build(nums, index); bool m = false; return helper1(root, a, b, m);&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;string&gt; nums; for (auto i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; nums.push_back(s); &#125; string a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; helper(nums, a, b) &lt;&lt; endl; return 0;&#125; 两个升序数组，查合并之后的总的中位数123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;typedef vector&lt;int&gt;::iterator Iter;int helper1(Iter a, int m, Iter b, int n, int k) &#123; if (!n) return a[k - 1]; if (!m) return b[k - 1]; if (k == 1) return min(a[0], b[0]); int l = min(k / 2, m); int r = min(k / 2, n); if (a[l - 1] &lt; b[r - 1]) &#123; return helper1(a + l, m - l, b, n, k - l); &#125; else &#123; return helper1(a, m, b + r, n - r, k - r); &#125;&#125;double helper(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; int n1 = A.size(); int n2 = B.size(); return ( helper1(A.begin(), n1, B.begin(), n2, (n1 + n2 + 1) / 2) + helper1(A.begin(), n1, B.begin(), n2, (n1 + n2 + 2) / 2) ) / 2.0;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; A(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; A[i]; &#125; vector&lt;int&gt; B(n, 0); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; B[i]; &#125; cout &lt;&lt; helper(A, B) &lt;&lt; endl; return 0;&#125; LRU12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;list&gt;#include &lt;vector&gt;#include &lt;utility&gt;using namespace std;class LRU &#123;private: unordered_map&lt;int, pair&lt;int, list&lt;int&gt;::iterator&gt;&gt; nums; list&lt;int&gt; d; int cap; void touch(int key) &#123; if (nums.find(key) == nums.end()) return; d.erase(nums[key].second); nums.erase(key); &#125;public: LRU(int capacity): cap(capacity) &#123;&#125;; void add(int key, int val) &#123; touch(key); d.push_front(key); nums[key] = &#123;val, d.begin()&#125;; &#125; int get(int key) &#123; if (nums.find(key) == nums.end()) return -1; int ret = nums[key].first; touch(key); d.push_front(key); nums[key] = &#123;ret, d.begin()&#125;; return ret; &#125;&#125;;int main() &#123; auto cache = new LRU(2); cache-&gt;add(1, 1); cache-&gt;add(2, 2); cout &lt;&lt; cache-&gt;get(1) &lt;&lt; endl; // returns 1 return 0;&#125; 带重复的字符串全排列12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt; nums, int index) &#123; int n = nums.size(); if (n == index) ret.push_back(nums); for (int i = index; i &lt; n; i++) &#123; if (i != index &amp;&amp; nums[i] == nums[index]) continue; swap(nums[index], nums[i]); dfs(ret, nums, index + 1); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; helper(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; sort(nums.begin(), nums.end()); dfs(ret, nums, 0); return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 自然数排列0123456791011121314.. 自然数这样顺次排下去，给一个index，找出对应的数字是什么1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;char helper(int n) &#123; if (!n) return '0'; if (n &lt; 10) return '1' + (n - 1); n -= 9; int cnt = 1; while (n &gt; (pow(10, cnt + 1) - pow(10, cnt)) * (cnt + 1)) &#123; n -= (pow(10, cnt + 1) - pow(10, cnt)) * (cnt + 1); cnt ++; &#125; int ans = pow(10, cnt) + (n - 1) / (cnt + 1); return to_string(ans)[(n - 1) % (cnt + 1)];&#125;int main() &#123; for (int i = 0; i &lt; 200; i++) &#123; cout &lt;&lt; helper(i); &#125; cout &lt;&lt; endl; return 0;&#125; House Robber IIILeetcode 3371234567891011121314class Solution &#123;public: int helper(TreeNode* root, int&amp; l, int&amp; r) &#123; if (!root) return 0; int ll = 0, lr = 0, rl = 0, rr = 0; l = max(0, helper(root-&gt;left, ll, lr)); r = max(0, helper(root-&gt;right, rl, rr)); return max(l + r, root-&gt;val + ll + lr + rl + rr); &#125; int rob(TreeNode* root) &#123; int l, r; return helper(root, l, r); &#125;&#125;; Minimum Window SubstringLeetcode 761234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string minWindow(string s, string t) &#123; if (t.empty()) return ""; unordered_map&lt;char, int&gt; m; for (auto i : t) &#123; m[i] ++; &#125; int ans = m.size(); int n = s.size(); int l = 0, r = 0; int len = INT_MAX; string ret; while (r &lt;= n &amp;&amp; l &lt;= r) &#123; if (ans &gt; 0 &amp;&amp; r &lt; n) &#123; auto key = s[r++]; if (m.find(key) != m.end()) &#123; m[key] --; if (m[key] == 0) ans--; &#125; &#125; else &#123; auto key = s[l++]; if (m.find(key) != m.end()) &#123; m[key] ++; if (m[key] == 1) ans ++; &#125; &#125; if (!ans &amp;&amp; r - l &lt; len) &#123; len = r - l; ret = s.substr(l, len); &#125; &#125; return ret; &#125;&#125;; 变色龙123456789101112131415161718192021222324Description 在一个美丽的小岛上住着一群变色龙：其中有X只变色龙是红色的，Y只变色龙是绿色的，Z只变色龙是蓝色的。 每个时刻会有两只不同颜色的变色龙相遇，相遇后他们会同时变成第三种颜色。比如，如果一只红色的变色龙和一只蓝色的变色龙相遇了，他们就会同时变成绿色的变色龙，如果一只绿色的变色龙和一只蓝色的变色龙相遇了，他们就会同时变成红色的变色龙，等等。 那么最后是否有可能所有的变色龙都是同一种颜色呢？ Input 输入的第一行包含一个整数T (1 &lt;= T &lt;= 100)，表示接下来一共有T组测试数据。 每组数据占一行，包含三个整数X, Y, Z (1 &lt;= X, Y, Z &lt;= 109)，含义同上。 Output 对于每组测试数据，如果最后有可能所有的变色龙都是同一种颜色，用一行输出“Yes”（不包括引号），否则输出“No”（不包括引号）。 Sample Input41 1 11 2 37 1 23 7 5Sample OutputYesNoYesNoHINT 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;string helper(int x, int y, int z) &#123; if (x == y || y == z) return "YES"; if (abs(x - y) % 3 == 0 || abs(x - z) % 3 == 0 || abs(y - z) % 3 == 0) return "YES"; else return "NO";&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; cout &lt;&lt; helper(x, y, z) &lt;&lt; endl; &#125; return 0;&#125; 平方根123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;climits&gt;using namespace std;int helper1(int n) &#123; int ret = n; while (ret * ret &gt; n) &#123; ret = (ret + n / ret) / 2; &#125; return ret;&#125;int helper2(int n) &#123; int left = 1, right = n; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (mid + 1 &gt; n / (mid + 1) &amp;&amp; mid &lt;= n / mid) return mid; if (mid &lt; n / mid) left = mid + 1; else right = mid - 1; &#125; return -1;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; helper1(n) &lt;&lt; endl; cout &lt;&lt; helper2(n) &lt;&lt; endl; return 0;&#125; 短网址系统设计一个短网址系统？短网址生成策略？短网址和长网址的映射关系如何表示？存网址的数据库表太大了怎么办？Sharding后如何分别以长网址或短网址为主key搜索？你觉得这个系统追求的是时间效率还是空间节省？那冗余存储的牺牲值不值得？ 1// 代码待补充 大文件判断重复判断两个大文件，4g内存，判断两个文件里想同的url123456/*三种思路供参考：1. 运用bitmap，类似于布隆过滤器2. 运用hash值，类似于布隆过滤器，有可能出现判断不准确的情况3. 分桶成小文件，然后查询过程中扫每个文件*/ 无向图的最小环1234输入：n个点，t条边输出：最短环的路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;unordered_set&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, int n) &#123; vector&lt;unordered_set&lt;int&gt;&gt; adj(n); for (auto i : nums) &#123; if (i.first == i.second) continue; adj[i.first].insert(i.second); adj[i.second].insert(i.first); &#125; vector&lt;vector&lt;int&gt;&gt; cur; cur.push_back(&#123;0&#125;); while (true) &#123; vector&lt;vector&lt;int&gt;&gt; next; for (auto i : cur) &#123; for (auto j : adj[i.back()]) &#123; if (i.size() &gt; 2 &amp;&amp; j == 0) &#123; i.push_back(0); return i; &#125; if (find(i.begin(), i.end(), j) == i.end()) &#123; auto temp = i; temp.push_back(j); next.push_back(temp); &#125; &#125; &#125; if (next.empty()) break; cur = next; &#125; return vector&lt;int&gt;();&#125;int main() &#123; int n; cin &gt;&gt; n; int t; cin &gt;&gt; t; vector&lt;pair&lt;int, int&gt;&gt; nums; for (int i = 0; i &lt; t; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; nums.push_back(&#123;x, y&#125;); &#125; for (auto i : helper(nums, n)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125;/*6 70 11 21 32 32 44 55 0*/]]></content>
      <tags>
        <tag>算法</tag>
        <tag>总结</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 周赛模拟 【2】]]></title>
    <url>%2F2018%2F10%2F25%2FLeetcode-virtual-contest-2%2F</url>
    <content type="text"><![CDATA[Weekly Contest 83 参赛地址 830. Positions of Large Groups [AC] Leetcode 830 In a string S of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = “abbxxxxzyy” has the groups “a”, “bb”, “xxxx”, “z” and “yy”. Call a group large if it has 3 or more characters. We would like the starting and ending positions of every large group. The final answer should be in lexicographic order. Example 1:123Input: &quot;abbxxxxzzy&quot;Output: [[3,6]]Explanation: &quot;xxxx&quot; is the single large group with starting 3 and ending positions 6. Example 2:123Input: &quot;abc&quot;Output: []Explanation: We have &quot;a&quot;,&quot;b&quot; and &quot;c&quot; but no large group. Example 3:12Input: &quot;abcdddeeeeaabbbcd&quot;Output: [[3,5],[6,9],[12,14]] Note: 1 &lt;= S.length &lt;= 1000 1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; largeGroupPositions(string S) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int n = S.size(); if (!n) return ret; for (int i = 0; i &lt; n; i++) &#123; int cnt = 1; while (i + cnt &lt; n &amp;&amp; S[i] == S[i + cnt]) cnt ++; if (cnt &lt;= 2) continue; vector&lt;int&gt; ans(&#123;i, i + cnt - 1&#125;); ret.push_back(ans); i += cnt - 1; &#125; return ret; &#125;&#125;; 831. Masking Personal Information [AC] Leetcode 831 We are given a personal information string S, which may represent either an email address or a phone number. We would like to mask this personal information according to the following rules: Email address: We define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters A-Z. An email address starts with a name, followed by the symbol ‘@’, followed by a name, followed by the dot ‘.’ and followed by a name. All email addresses are guaranteed to be valid and in the format of “name1@name2.name3”. To mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks ‘*’. Phone number: A phone number is a string consisting of only the digits 0-9 or the characters from the set {‘+’, ‘-‘, ‘(‘, ‘)’, ‘ ‘}. You may assume a phone number contains 10 to 13 digits. The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits. The local number should be formatted and masked as “--1111”, where 1 represents the exposed digits. To mask a phone number with country code like “+111 111 111 1111”, we write it in the form “+--*-1111”. The ‘+’ sign and the first ‘-‘ sign before the local number should only exist if there is a country code. For example, a 12 digit phone number mask should start with “+-“. Note that extraneous characters like “(“, “)”, “ “, as well as extra dashes or plus signs not part of the above formatting scheme should be removed. Return the correct “mask” of the information provided. Example 1:12345Input: &quot;LeetCode@LeetCode.com&quot;Output: &quot;l*****e@leetcode.com&quot;Explanation: All names are converted to lowercase, and the letters between the first and last letter of the first name is replaced by 5 asterisks. Therefore, &quot;leetcode&quot; -&gt; &quot;l*****e&quot;. Example 2:1234Input: &quot;AB@qq.com&quot;Output: &quot;a*****b@qq.com&quot;Explanation: There must be 5 asterisks between the first and last letter of the first name &quot;ab&quot;. Therefore, &quot;ab&quot; -&gt; &quot;a*****b&quot;. Example 3:123Input: &quot;1(234)567-890&quot;Output: &quot;***-***-7890&quot;Explanation: 10 digits in the phone number, which means all digits make up the local number. Example 4:123Input: &quot;86-(10)12345678&quot;Output: &quot;+**-***-***-5678&quot;Explanation: 12 digits, 2 digits for country code and 10 digits for local number. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: bool helper(string s, int&amp; cnt) &#123; bool ret = false; for (auto i : s) &#123; if (i == '@') ret = true; if (i &gt;= '0' &amp;&amp; i &lt;= '9') cnt ++; &#125; return ret; &#125; string maskPII(string S) &#123; int cnt = 0; if (!helper(S, cnt)) &#123; string ret; string ans; int index = S.size() - 1; int c = 0; while (c &lt; 4) &#123; if (S[index] &lt;= '9' &amp;&amp; S[index] &gt;= '0') &#123; ans = S[index] + ans; c ++; &#125; index --; &#125; if (cnt &gt; 10) &#123; ret = "+"; for (int i = 0; i &lt; cnt - 10; i++) ret += "*"; ret += "-***-***-"; &#125; else ret = "***-***-"; ret += ans; return ret; &#125; else &#123; for (auto &amp;i : S) &#123; if (i &gt;= 'A' &amp;&amp; i &lt;= 'Z') i = 'a' + (i - 'A'); &#125; string ret; ret.push_back(S[0]); ret += "*****"; int index = 1; while (S[index + 1] != '@') index ++; while (index &lt; S.size()) ret += S[index ++]; return ret; &#125; &#125;&#125;; 829. Consecutive Numbers Sum [AC] Leetcode 829 Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? Example 1:123Input: 5Output: 2Explanation: 5 = 5 = 2 + 3 Example 2:123Input: 9Output: 3Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4 Example 3:123Input: 15Output: 4Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 12345678910class Solution &#123;public: int consecutiveNumbersSum(int N) &#123; int ret = 1; for (int i = 2; 2 * N - i * (i - 1) &gt; 0; i++) &#123; if ((2 * N - i * (i - 1)) % (2 * i) == 0) ret ++; &#125; return ret; &#125;&#125;; 828. Unique Letter String [Unsolved] Leetcode 828 A character is unique in string S if it occurs exactly once in it. For example, in string S = “LETTER”, the only unique characters are “L” and “R”. Let’s define UNIQ(S) as the number of unique characters in string S. For example, UNIQ(“LETTER”) = 2. Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S. If there are two or more equal substrings at different positions in S, we consider them different. Since the answer can be very large, return the answer modulo 10 ^ 9 + 7. Example 1:12345Input: &quot;ABC&quot;Output: 10Explanation: All possible substrings are: &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; and &quot;ABC&quot;.Evey substring is composed with only unique letters.Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10 Example 2:123Input: &quot;ABA&quot;Output: 8Explanation: The same as example 1, except uni(&quot;ABA&quot;) = 1. 123456789101112131415class Solution &#123;public: int uniqueLetterString(string S) &#123; long long ret = 0; int n = S.size(); for (int i = 0; i &lt; n; i++) &#123; int l = i - 1, r = i + 1; while (l &gt;= 0 &amp;&amp; S[l] != S[i]) l--; while (r &lt; n &amp;&amp; S[r] != S[i]) r ++; ret += (long long)(r - i) * (i - l); // 相乘表示从l-&gt;i和i-&gt;r所有子串的组合 &#125; return ret % 1000000007; &#125;&#125;; Weekly Contest 82824. Goat Latin [AC] Leetcode 824A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel (a, e, i, o, or u), append “ma” to the end of the word.For example, the word ‘apple’ becomes ‘applema’. If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add “ma”.For example, the word “goat” becomes “oatgma”. Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1.For example, the first word gets “a” added to the end, the second word gets “aa” added to the end and so on.Return the final sentence representing the conversion from S to Goat Latin. Example 1:12Input: &quot;I speak Goat Latin&quot;Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot; Example 2:12Input: &quot;The quick brown fox jumped over the lazy dog&quot;Output: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: bool helper(char c) &#123; if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') return true; else return false; &#125; string toGoatLatin(string S) &#123; string ret; string ans; int cnt = 1; for (auto i : S) &#123; if (i != ' ') &#123; ans.push_back(i); &#125; else &#123; if (ans.empty()) ans += " "; else &#123; if (helper(ans[0])) &#123; ans += "ma"; &#125; else &#123; char t = ans[0]; ans.erase(ans.begin()); ans.push_back(t); ans += "ma"; &#125; for (int i = 0; i &lt; cnt; i++) &#123; ans += "a"; &#125; cnt ++; &#125; ret += " " + ans; ans = ""; &#125; &#125; if (helper(ans[0])) &#123; ans += "ma"; &#125; else &#123; char t = ans[0]; ans.erase(ans.begin()); ans.push_back(t); ans += "ma"; &#125; for (int i = 0; i &lt; cnt; i++) &#123; ans += "a"; &#125; ret += " " + ans; ans = ""; ret.erase(ret.begin()); return ret; &#125;&#125;; 825. Friends Of Appropriate Ages [AC] Leetcode 825 Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person. Person A will NOT friend request person B (B != A) if any of the following conditions are true: age[B] &lt;= 0.5 * age[A] + 7age[B] &gt; age[A]age[B] &gt; 100 &amp;&amp; age[A] &lt; 100Otherwise, A will friend request B. Note that if A requests B, B does not necessarily request A. Also, people will not friend request themselves. How many total friend requests are made? Example 1:123Input: [16,16]Output: 2Explanation: 2 people friend request each other. Example 2:123Input: [16,17,18]Output: 2Explanation: Friend requests are made 17 -&gt; 16, 18 -&gt; 17. Example 3:123Input: [20,30,100,110,120]Output: Explanation: Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100. 12345678910111213141516171819202122class Solution &#123;public: bool helper(int a, int b) &#123; if ((2 * b &lt;= a + 14) || b &gt; a || (b &gt; 100 &amp;&amp; a &lt; 100)) return false; else return true; &#125; int numFriendRequests(vector&lt;int&gt;&amp; ages) &#123; int ret = 0; int n = ages.size(); sort(ages.begin(), ages.end()); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (helper(ages[j], ages[i])) &#123; cout &lt;&lt; ages[j] &lt;&lt; ages[i] &lt;&lt; endl; ret ++; &#125; &#125; &#125; if (ret &amp;&amp; n == 2) return 2; return ret; &#125;&#125;; 826. Most Profit Assigning Work [AC] Leetcode 826 We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job. Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i]. Every worker can be assigned at most one job, but one job can be completed multiple times. For example, if 3 people attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, his profit is $0. What is the most profit we can make? Example 1:123Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]Output: 100 Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately. 1234567891011121314151617181920212223class Solution &#123;public: int maxProfitAssignment(vector&lt;int&gt;&amp; difficulty, vector&lt;int&gt;&amp; profit, vector&lt;int&gt;&amp; worker) &#123; int n = worker.size(), m = profit.size(); vector&lt;pair&lt;int, int&gt;&gt; nums; if (!n || !m) return 0; for (int i = 0; i &lt; m; i++) &#123; nums.push_back(make_pair(difficulty[i], profit[i])); &#125; sort(nums.begin(), nums.end()); int ret = 0; for (int i = 0; i &lt; n; i++) &#123; int ans = 0; for (int j = 0; j &lt; m; j++) &#123; if (worker[i] &lt; nums[j].first) break; ans = max(ans, nums[j].second); &#125; ret += ans; &#125; return ret; &#125;&#125;; 827. Making A Large Island [Unsolved] Leetcode 827 In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). Example 1: Input: [[1, 0], [0, 1]]Output: 3Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.Example 2: Input: [[1, 1], [1, 0]]Output: 4Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.Example 3: Input: [[1, 1], [1, 1]]Output: 4Explanation: Can’t change any 0 to 1, only one island with area = 4. 本来思路是并查集加BFS，但是由于并查集写的代码太长导致时间不够用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: int N; int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; N = grid.size(); //DFS every island and give it an index of island int index = 2, res = 0; unordered_map &lt;int, int&gt;area; for (int x = 0; x &lt; N; ++x) &#123; for (int y = 0; y &lt; N; ++y) &#123; if (grid[x][y] == 1) &#123; area[index] = dfs(grid, x, y, index); res = max(res, area[index++]); &#125; &#125; &#125; //traverse every 0 cell and count biggest island it can conntect for (int x = 0; x &lt; N; ++x) for (int y = 0; y &lt; N; ++y) if (grid[x][y] == 0) &#123; unordered_set&lt;int&gt; seen = &#123;&#125;; int cur = 1; for (auto p : move(x, y)) &#123; index = grid[p.first][p.second]; if (index &gt; 1 &amp;&amp; seen.count(index) == 0) &#123; seen.insert(index); cur += area[index]; &#125; &#125; res = max(res, cur); &#125; return res; &#125; vector&lt;pair&lt;int, int&gt;&gt; move(int x, int y) &#123; vector&lt;pair&lt;int, int&gt;&gt; res; for (auto p : vector&lt;vector&lt;int&gt;&gt; &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;) &#123; if (valid(x + p[0], y + p[1])) res.push_back(make_pair(x + p[0], y + p[1])); &#125; return res; &#125; int valid(int x, int y) &#123; return 0 &lt;= x &amp;&amp; x &lt; N &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; N; &#125; int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) &#123; int area = 0; grid[x][y] = index; for (auto p : move(x, y)) if (grid[p.first][p.second] == 1) area += dfs(grid, p.first, p.second, index); return area + 1; &#125;&#125;; Weekly Contest 81821. Shortest Distance to a Character [AC] Leetcode 821Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string. Example 1:12Input: S = &quot;loveleetcode&quot;, C = &apos;e&apos;Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; shortestToChar(string S, char C) &#123; int n = S.size(); vector&lt;int&gt; res(n, n); int pos = -n; for (int i = 0; i &lt; n; ++i) &#123; if (S[i] == C) pos = i; res[i] = min(res[i], abs(i - pos)); &#125; for (int i = n - 1; i &gt;= 0; --i) &#123; if (S[i] == C) pos = i; res[i] = min(res[i], abs(i - pos)); &#125; return res; &#125;&#125;; 822. 822. Card Flipping Game [AC] Leetcode 821 On a table are N cards, with a positive integer printed on the front and back of each card (possibly different). We flip any number of cards, and after we choose one card. If the number X on the back of the chosen card is not on the front of any card, then this number X is good. What is the smallest number that is good? If no number is good, output 0. Here, fronts[i] and backs[i] represent the number on the front and back of card i. A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa. Example:1234Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]Output: 2Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].We choose the second card, which has number 2 on the back, and it isn&apos;t on the front of any card, so 2 is good. 123456789101112131415161718class Solution &#123;public: int flipgame(vector&lt;int&gt;&amp; fronts, vector&lt;int&gt;&amp; backs) &#123; unordered_set&lt;int&gt; same; int n = fronts.size(); for (int i = 0; i &lt; n; i++) &#123; if (fronts[i] == backs[i]) same.insert(fronts[i]); &#125; int ret = INT_MAX; for (auto i : fronts) &#123; if (same.find(i) == same.end()) ret = min(ret, i); &#125; for (auto i : backs) &#123; if (same.find(i) == same.end()) ret = min(ret, i); &#125; return ret == INT_MAX ? 0 : ret; &#125;&#125;; 820. Short Encoding of Words [AC] Leetcode 820Given a list of words, we may encode it by writing a reference string S and a list of indexes A. For example, if the list of words is [“time”, “me”, “bell”], we can write it as S = “time#bell#” and indexes = [0, 2, 5]. Then for each index, we will recover the word by reading from the reference string from that index until we reach a “#” character. What is the length of the shortest reference string S possible that encodes the given words? Example:123Input: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]Output: 10Explanation: S = &quot;time#bell#&quot; and indexes = [0, 2, 5]. 1234567891011121314class Solution &#123;public: int minimumLengthEncoding(vector&lt;string&gt;&amp; words) &#123; unordered_set&lt;string&gt; s(words.begin(), words.end()); for (auto w : words) &#123; for (int i = 1; i &lt; w.size(); i++) &#123; s.erase(w.substr(i)); &#125; &#125; int ret = 0; for (auto i : s) ret += i.size() + 1; return ret; &#125;&#125;; 823. Binary Trees With Factors [AC] Leetcode 823 Given an array of unique integers, each integer is strictly greater than 1. We make a binary tree using these integers and each number may be used for any number of times. Each non-leaf node’s value should be equal to the product of the values of it’s children. How many binary trees can we make? Return the answer modulo 10 ** 9 + 7. Example 1:123Input: A = [2, 4]Output: 3Explanation: We can make these trees: [2], [4], [4, 2, 2] Example 2:123Input: A = [2, 4, 5, 10]Output: 7Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]. 1234567891011121314151617181920212223class Solution &#123;public: long MOD = 1000000007; int numFactoredBinaryTrees(vector&lt;int&gt;&amp; A) &#123; sort(A.begin(), A.end()); unordered_map&lt;int, long&gt; m; for (int i = 0; i &lt; A.size(); i++) &#123; int x = A[i]; m[x] = 1; for (int j = 0; j &lt; i; j++) &#123; int y = A[j]; if (x % y == 0 &amp;&amp; m.find(x / y) != m.end()) &#123; m[x] = (m[x] + (m[y] * m[x / y]) % MOD) % MOD; &#125; &#125; &#125; long ret = 0; for (auto i : m) &#123; ret = (ret + i.second) % MOD; &#125; return ret; &#125;&#125;; Weekly Contest 80 Leetcode 80 819. Most Common Word [AC] Leetcode 819 Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn’t banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase. Example:12345678910Input: paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;banned = [&quot;hit&quot;]Output: &quot;ball&quot;Explanation: &quot;hit&quot; occurs 3 times, but it is a banned word.&quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. Note that words in the paragraph are not case sensitive,that punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;), and that &quot;hit&quot; isn&apos;t the answer even though it occurs more because it is banned. 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: vector&lt;string&gt; helper(string s) &#123; vector&lt;string&gt; ret; string ans; for (auto i : s) &#123; if (i == ' ' || ispunct(i)) &#123; if (ans != "") &#123; ret.push_back(ans); &#125; ans = ""; &#125; else &#123; if (i &lt;= 'Z' &amp;&amp; i &gt;= 'A') &#123; i = 'a' + (i - 'A'); &#125; ans.push_back(i); &#125; &#125; if (ans != "") ret.push_back(ans); return ret; &#125; string mostCommonWord(string paragraph, vector&lt;string&gt;&amp; banned) &#123; unordered_set&lt;string&gt; m(banned.begin(), banned.end()); unordered_map&lt;string, int&gt; cnt; for (auto s : helper(paragraph)) &#123; if (m.find(s) == m.end()) &#123; cout &lt;&lt; s &lt;&lt; endl; cnt[s] ++; &#125; &#125; string ret; int ans = 0; for (auto i : cnt) &#123; if (i.second &gt; ans) &#123; ans = i.second; ret = i.first; &#125; &#125; return ret; &#125;&#125;; 817. Linked List Components [AC] Leetcode 817 We are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1:123456Input: head: 0-&gt;1-&gt;2-&gt;3G = [0, 1, 3]Output: 2Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components. Example 2:123456Input: head: 0-&gt;1-&gt;2-&gt;3-&gt;4G = [0, 3, 1, 4]Output: 2Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int numComponents(ListNode* head, vector&lt;int&gt;&amp; G) &#123; if (!head) return 0; unordered_set&lt;int&gt; m(G.begin(), G.end()); int ret = 0; int check = 0; ListNode* cur = head; while (true) &#123; int x = cur-&gt;val; if (m.find(x) != m.end()) &#123; check = 1; &#125; else &#123; if (check) &#123; ret += 1, check = 0; &#125; &#125; cur = cur-&gt;next; if (!cur) &#123; if (check) ret += 1; break; &#125; &#125; return ret; &#125;&#125;; 816. Ambiguous Coordinates [AC] Leetcode 816 We had some 2-dimensional coordinates, like “(1, 3)” or “(2, 0.5)”. Then, we removed all commas, decimal points, and spaces, and ended up with the string S. Return a list of strings representing all possibilities for what our original coordinates could have been. Our original representation never had extraneous zeroes, so we never started with numbers like “00”, “0.0”, “0.00”, “1.0”, “001”, “00.01”, or any other number that can be represented with less digits. Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like “.1”. The final answer list can be returned in any order. Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.)12345678910111213141516Example 1:Input: &quot;(123)&quot;Output: [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]Example 2:Input: &quot;(00011)&quot;Output: [&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]Explanation: 0.0, 00, 0001 or 00.01 are not allowed.Example 3:Input: &quot;(0123)&quot;Output: [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]Example 4:Input: &quot;(100)&quot;Output: [(10, 0)]Explanation: 1.0 is not allowed. 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;string&gt; helper(string s) &#123; vector&lt;string&gt; ret; if (s == "0") return vector&lt;string&gt;(&#123;"0"&#125;); if (s[0] == '0' &amp;&amp; s.back() == '0') return ret; if (s[0] == '0' &amp;&amp; s.back() != '0') &#123; string ans = "0."; for (int i = 1; i &lt; s.size(); i++) &#123; ans.push_back(s[i]); &#125; ret.push_back(ans); return ret; &#125; if (s[0] != '0' &amp;&amp; s.back() == '0') &#123; ret.push_back(s); return ret; &#125; ret.push_back(s); for (int i = 1; i &lt; s.size(); i++) &#123; ret.push_back(s.substr(0, i) + "." + s.substr(i)); &#125; return ret; &#125; vector&lt;string&gt; ambiguousCoordinates(string S) &#123; S.pop_back(); S.erase(S.begin()); vector&lt;string&gt; ret; for (int i = 1; i &lt; S.size(); i++) &#123; for (auto a : helper(S.substr(0, i))) &#123; if (a == "") continue; for (auto b : helper(S.substr(i))) &#123; if (b == "") continue; ret.push_back("(" + a + ", " + b + ")"); &#125; &#125; &#125; return ret; &#125;&#125;; 818. Race Car [AC] Leetcode 818 Your car starts at position 0 and speed +1 on an infinite number line. (Your car can go into negative positions.) Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse). When you get an instruction “A”, your car does the following: position += speed, speed *= 2. When you get an instruction “R”, your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1. (Your position stays the same.) For example, after commands “AAR”, your car goes to positions 0-&gt;1-&gt;3-&gt;3, and your speed goes to 1-&gt;2-&gt;4-&gt;-1. Now for some target position, say the length of the shortest sequence of instructions to get there.123456789101112131415Example 1:Input: target = 3Output: 2Explanation: The shortest instruction sequence is &quot;AA&quot;.Your position goes from 0-&gt;1-&gt;3.Example 2:Input: target = 6Output: 5Explanation: The shortest instruction sequence is &quot;AAARA&quot;.Your position goes from 0-&gt;1-&gt;3-&gt;7-&gt;7-&gt;6. 123456789101112131415class Solution &#123;public: int dp[10001]; int racecar(int t) &#123; if (dp[t] &gt; 0) return dp[t]; int n = floor(log2(t)) + 1, res; if (1 &lt;&lt; n == t + 1) dp[t] = n; else &#123; dp[t] = racecar((1 &lt;&lt; n) - 1 - t) + n + 1; for (int m = 0; m &lt; n - 1; ++m) dp[t] = min(dp[t], racecar(t - (1 &lt;&lt; (n - 1)) + (1 &lt;&lt; m)) + n + m + 1); &#125; return dp[t]; &#125;&#125;;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由FTRL展开，在线梯度下降（OGD）理论基础以及与离线梯度下降算法等效性证明总结]]></title>
    <url>%2F2018%2F10%2F16%2Fonline-learning-algorithm-background-knowledge-ftrl-provement%2F</url>
    <content type="text"><![CDATA[之前的项目中用到了FTRL，在最近的交流中经常被问及这方面的相关基础，发现之前对在线学习的基础知识掌握不全面，以及对OGD和SGD等效性没有理论依据，这里作为总结。 本文参考资料losteng的csdn和雷天琪的回答 在线学习算法相关背景在线学习算法强调的是训练的实时性，面向流式数据，每次训练不使用全量数据，而是以之前训练好的参数为基础，每次利用一个样本更新一次模型，是属于增量学习的一部分，从而快速更新模型，提高模型的时效性。 在线学习算法与离线学习关注点的不同统计学习的先验假设是数据存在自己一定的分布，我们的目的是寻找与实际分布距离最小的策略来泛化未知的结果。数据由真实模型产生，如果能有无限数据、并在包含有真实模型的空间里求解，也许我们能算出真是模 型。但实际上我们只有有限的有噪音的数据，这又限制我们只能使用相对简单的模型。所以，理想的算法是能够用不多的数据来得到一个不错的模型。 离线学习算法强调的是数据中不断训练已有的模型，不断迭代达到真实的数据分布，在训练过程中，所有数据都是可见的，目标是一定的（就是最终的那个真实分布），其中可以采用不同的更新策略和采样策略，所以有了批量梯度下降和随机梯度下降等算法。 但是，在线学习算法的关注点是不同的，在线学习算法的限制条件是只能看到过去的数据和当前的数据，看不到未来的数据，所以我们训练的策略可能是任意的数据分布，通过不断的训练可能颠覆之前的训练结果，所以在线学习甚至是为了破坏我们之前的策略精心设计的。 在线学习关注点在于，追求对所知道的所有知识所能设计最优的策略，那么同这个最优的策略的差距成为后悔（regret）:后悔没有从一开始就选择这个策略，当然，我们希望的是，随着时间的增加，这个差异会不断的变小。因为我们不对数据进行任何假设，所以策略是否完美并不是我们关心的（比如回答所有问题），我们追求的是，没有后悔（no-regret） batch模式和delta模式梯度下降可以分成两种模式，batch模式和delta模式。batch模式的时效性比delta模式要低一些。分析一下batch模式，比如昨天及昨天的数据训练成了模型M，那么今天的每一条训练数据在训练过程中都会更新一次模型M，从而生成今天的模型M1。 batch学习可以认为是离线学习算法，强调的是每次训练都需要使用全量的样本，因而可能会面临数据量过大的问题。一般进行多轮迭代来向最优解靠近。online learning没有多轮的概念，如果数据量不够或训练数据不够充分，通过copy多份同样的训练数据来模拟batch learning的多轮训练也是有效的方法。 delta模式可以认为是在线学习算法，没有多轮的概念，如果数据量不够或训练数据不够充分，通过copy多份同样的训练数据来模拟batch learning的多轮训练也是有效的方法。所以，OGD和SGD都属于在线学习算法，因为每次更新模型只用一个样本。SGD则每次只针对一个观测到的样本进行更新。通常情况下，SGD能够比GD“更快”地令 逼近最优值。当样本数 特别大的时候，SGD的优势更加明显，并且由于SGD针对观测到的“一条”样本更新 ，很适合进行增量计算，实现梯度下降的Online模式（OGD, OnlineGradient Descent）。 在线凸优化 本章只是简单介绍，如果想要深入了解在线凸优化（OCO），强烈推荐阅读Elad Hazand的著作和Zinkevich的Paper 聊到在线学习算法通常会说到专家系统，在$t$时刻专家$i$的损失是$\ellt(e^i)$，于是这个时刻Weighted Majority（WM）损失的期望是$\sum{i=1}^m w_t^i\ell_t(e^i)$，是关于这m个专家的损失的一个线性组合（因为权重$w_t^i$关于$i$的和为1，所以实际上是在一个simplex上）。将专家在$t$时刻的损失看成是这个时候进来的数据点，于是我们便在这里使用了一个线性的损失函数。 WM的理论证明可以参考Littlestone 94,Freund 99，虽然在上个世纪已经完成，但是将其理论拓展到一般的凸的函数还是在03年由Zinkevich完成的。 在线梯度下降（OGD）Zinkevich提出的算法很简单，在时刻t做两步操作，首先利用当前得到数据对$ht$进行一次梯度下降得到$h{t+1}$，如果新的$h_{t+1}$不在$\mathcal{H}$中，那么将其投影进来： \displaystyle h_{t+1}=\Pi_{\mathcal{H}}(h_t-\eta_t\nabla\ell_t(h_t))这里$\nabla\ellt(h_t)$是$\ell_t(h_t)$关于$h_t$的导数（如果导数不唯一，就用次导数），$\eta_t$是学习率，$\Pi{\mathcal{H}}(\cdot)$是投影子，其将不在$\mathcal{H}$中的向量$x$投影成一个与$x$最近的但在$\mathcal{H}$中的向量（如果$x$已经在$\mathcal{H}$中了，那就不做任何事），用公式表达就是$\Pi{\mathcal{H}}(x)=\arg\min{y\in\mathcal{H}}|x-y|$。此算法通常被称之为 Online Gradient Descent。 先来啰嗦几句其与离线梯度下降的区别。在离线的情况下，我们知道所有数据，所以能计算得到整个目标函数的梯度，从而朝最优解 迈出坚实的一步。而在online设定下，我们只根据当前的数据来计算一个梯度，其很可能与真实目标函数的梯度有一定的偏差。我们能保证的只是会减小的值，而对别的项的减少程度是未知的。当然，我们还是一直在朝目标前进，只是可能要走点弯路。 那online的优势在哪里呢？其关键是每走一步只需要看一下当前的一个数据，所以代价很小。而offline的算法每走一个要看下所有数据来算一 个真实梯度，所以代价很大。假定有100个数据，offline走10步就到最优，而online要100步才能到。但这样offline需要看1000 个数据，而online只要看100个数据，所以还是online代价小。 在这里，$\mathcal{H}$的作用是什么呢？记得在ML中的目标函数通常是损失+罚$\ell(h)+\lambda f(h)$的形式。例如ridge regression就是平方误差+$\ell_2$罚，lasso是平方误差+$\ell_1$罚，SVM是hinge loss+$\ell_2$罚。最小化这个目标函数可以等价于在$f(h)\le\delta$的限制下最小化$\ell(h)$。$\lambda$和$\delta$是一一对应的关系。实际上$f(h)\le\delta$就是定义了一个凸子空间，例如使用$\ell_2$罚时就是一个半径为$\delta$的球。所以，Online Gradient Descent可以online的解这一类目标函数，只是对于不同的罚选择不同的投影子。 下面是理论分析。记投影前的 $\tilde h{t+1} = h_t-\eta_t\nabla\ell_t(h_t)$，以及offline最优解$h^*=\arg\min{h\in\mathcal{H}}\sum{t=1}^T\ell_t(h)$ 。因为$ \mathcal{H} $是凸的且 $ h^* $ 在其中，所以对 $ \tilde h{t+1} $ 投影只会减少其与 $ h^ $ 的距离，既 $ |h_{t+1}-h^|\le|\tilde h_{t+1}-h^*| $ 。记 $ \nabla_t=\nabla \ell_t(h_t) $ ，注意到 \displaystyle \|\tilde h_{t+1}-h^*\|^2=\|h_t-h^*\|^2+\eta_t^2\|\nabla_t\|^2-2\eta_t\langle\nabla_t,h_t-h^*\rangle.由于$\ell_t$是凸的，所以有 \displaystyle \ell_t(h_t)-\ell_t(h^*)\le \langle\nabla_t,h_t-h^*\rangle \le \frac{1}{2\eta_t}\big(\|h_t-h^*\|^2 - \|h_{t+1}-h^*\|^2\big) + \frac{\eta_t}{2}\|\nabla_t\|^2.取固定的$\etat=\eta$，对$t$进行累加就有$R(T)\le \frac{1}{2\eta}|w_1-w^*|^2+\frac{\eta}{2}\sum{t=1}^T|\nabla_t|^2$。记$\mathcal{H}$的直径为$D$，且对所有$t$有$|\nabla_t|\le L$成立（既Lipschitz常数为$L$），再取$\eta=\frac{D}{L\sqrt{T}}$，那么 \displaystyle R(T)\le LD\sqrt{T}.这个bound可以通过设置变动的学习率$\eta_t$加强。 FTRL更新公式和SGD更新公式的等效性SGD算法的迭代计算公式如下： 其中 t 为迭代轮数，w是模型参数，g是loss function关于w的梯度，而η是学习率。 FTRL算法的迭代算公式如下： 其中 t 为迭代轮数，w是模型参数，σs定义成 λ1是L1正则化系数。在公式2中，arg min算子的内容中由3项组成，如果我们去掉最后面的L1正则化项，公式2就变成下面的公式3： （3）式子在换个形式后就等价于梯度下降公式。 以下是推导过程： 首先，我们要求公式3中的最小值，我们可以对其求导，得到 令上面的求导公式等于0就得到极值，极值正是Wt+1： 将含有wt+1的项放到等号左边，剩下的放在右边，得到公式6： 进一步化简得到公式7： 用 t-1 替换 t，得到公式8： 用公式7减去公式8，即式子的左边右边同时减去，得到公式9： 把σt用ηt表示，得到公式10： 对公式10化简即可得到公式1： 通过上面的推导证明，我们看到公式3与公式1确实等价。]]></content>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 周赛模拟 【1】]]></title>
    <url>%2F2018%2F09%2F16%2FLeetcode-virtual-contest-20180910%2F</url>
    <content type="text"><![CDATA[Weekly Contest 85 参赛地址 836. Rectangle Overlap [AC] Leetcode 836 A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner. Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two (axis-aligned) rectangles, return whether they overlap. Example 1:12Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]Output: true Example 2:12Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]Output: false 12345678910class Solution &#123;public: bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) &#123; long long x11 = rec1[0], x12 = rec1[2], x21 = rec2[0], x22 = rec2[2]; bool r1 = max(x11, x21) &lt; min(x12, x22); long long y11 = rec1[1], y12 = rec1[3], y21 = rec2[1], y22 = rec2[3]; bool r2 = max(y11, y21) &lt; min(y12, y22); return r1 &amp;&amp; r2; &#125;&#125;; 838. Push Dominoes [AC] Leetcode 838 There are N dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right. After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. Given a string “S” representing the initial state. S[i] = ‘L’, if the i-th domino has been pushed to the left; S[i] = ‘R’, if the i-th domino has been pushed to the right; S[i] = ‘.’, if the i-th domino has not been pushed. Return a string representing the final state. Example 1:12Input: &quot;.L.R...LR..L..&quot;Output: &quot;LL.RR.LLRRLL..&quot; Example 2:123Input: &quot;RR.L&quot;Output: &quot;RR.L&quot;Explanation: The first domino expends no additional force on the second domino. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string pushDominoes(string A) &#123; char pre = 0; int index = -1, n = A.size(); for (int i = 0; i &lt; n; i++) &#123; if (A[i] == 'L') &#123; if (pre == 'R') &#123; int k = (index + i + 1) / 2 - index; for (int j = 0; j &lt; k; j++) &#123; A[j + index] = 'R', A[i - j] = 'L'; &#125; &#125; else &#123; for (int j = index + 1; j &lt;= i; j++) &#123; A[j] = 'L'; &#125; &#125; pre = 'L'; index = i; &#125; else if (A[i] == 'R')&#123; if (pre == 'R') &#123; for (int j = index + 1; j &lt; i; j++) A[j] = 'R'; &#125; pre = 'R'; index = i; &#125; &#125; if (pre == 'R') &#123; for (int i = index + 1; i &lt; n; i++) A[i] = 'R'; &#125; return A; &#125;&#125;; 837. New 21 Game [unsolved] Leetcode 837 Alice plays the following game, loosely based on the card game “21”. Alice starts with 0 points, and draws numbers while she has less than K points. During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer. Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets K or more points. What is the probability that she has N or less points? Example 1:123Input: N = 10, K = 1, W = 10Output: 1.00000Explanation: Alice gets a single card, then stops. Example 2:1234Input: N = 6, K = 1, W = 10Output: 0.60000Explanation: Alice gets a single card, then stops.In 6 out of W = 10 possibilities, she is at or below N = 6 points. Example 3:12Input: N = 21, K = 17, W = 10Output: 0.73278 12345678910111213141516171819class Solution &#123; public double new21Game(int N, int K, int W) &#123; double[] dp = new double[N+3]; dp[0] = 1; dp[1] = -1; double val = 0; for(int i = 0;i &lt; K;i++)&#123; val += dp[i]; if(i+1 &lt;= N)dp[i+1] += val / W; if(i+W+1 &lt;= N)dp[i+W+1] -= val / W; &#125; double ret = 0; for(int i = K;i &lt;= N;i++)&#123; val += dp[i]; ret += val; &#125; return ret; &#125;&#125; 839. Similar String Groups [AC] Leetcode 839 Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y. For example, “tars” and “rats” are similar (swapping at positions 0 and 2), and “rats” and “arts” are similar, but “star” is not similar to “tars”, “rats”, or “arts”. Together, these form two connected groups by similarity: {“tars”, “rats”, “arts”} and {“star”}. Notice that “tars” and “arts” are in the same group even though they are not similar. Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list A of strings. Every string in A is an anagram of every other string in A. How many groups are there? Example 1:12Input: [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]Output: 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 并查集class Solution &#123;public: bool helper(string a, string b) &#123; if (a == b) return true; if (a.size() != b.size()) return false; if (a.empty()) return true; int cnt = 0; char x1 = '\0', y1 = '\0', x2 = '\0', y2 = '\0'; for (int i = 0; i &lt; a.size(); i++) &#123; if (a[i] == b[i]) continue; cnt ++; if (cnt == 1) x1 = a[i], y1 = b[i]; if (cnt == 2) x2 = a[i], y2 = b[i]; &#125; return cnt == 2 &amp;&amp; x1 == y2 &amp;&amp; x2 == y1; &#125; int MyFind(vector&lt;int&gt;&amp; nums, int x) &#123; int y = x; while (nums[x] != x) &#123; x = nums[x]; &#125; while (x != y) &#123; int t = nums[y]; nums[y] = x; y = t; &#125; return x; &#125; void MyMerge(vector&lt;int&gt;&amp; nums, int x, int y) &#123; int p1 = MyFind(nums, x); int p2 = MyFind(nums, y); if (p1 != p2) nums[p1] = p2; &#125; int numSimilarGroups(vector&lt;string&gt;&amp; A) &#123; int n = A.size(); if (!n) return 0; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; nums[i] = i; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == j) continue; if (helper(A[i], A[j])) MyMerge(nums, i, j); &#125; &#125; int ret = 0; for (int i = 0; i &lt; n; i++) &#123; if (MyFind(nums, i) == i) ret ++; &#125; return ret; &#125;&#125;; Weekly Contest 84 参赛地址 832. Flipping an Image [AC] Leetcode 832 Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1:1234Input: [[1,1,0],[1,0,1],[0,0,0]]Output: [[1,0,0],[0,1,0],[1,1,1]]Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2:1234Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int m = A.size(), n = A[0].size(); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n / 2; j++) &#123; swap(A[i][j], A[i][n - 1 - j]); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; A[i][j] ^= 1; &#125; &#125; return A; &#125;&#125;; 833. Find And Replace in String [AC] Leetcode 833 To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y. The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y. If not, we do nothing. For example, if we have S = “abcd” and we have some replacement operation i = 2, x = “cd”, y = “ffff”, then because “cd” starts at position 2 in the original string S, we will replace it with “ffff”. Using another example on S = “abcd”, if we have both the replacement operation i = 0, x = “ab”, y = “eee”, as well as another replacement operation i = 2, x = “ec”, y = “ffff”, this second operation does nothing because in the original string S[2] = ‘c’, which doesn’t match x[0] = ‘e’. All these operations occur simultaneously. It’s guaranteed that there won’t be any overlap in replacement: for example, S = “abc”, indexes = [0, 1], sources = [“ab”,”bc”] is not a valid test case. Example 1:1234Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;a&quot;,&quot;cd&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]Output: &quot;eeebffff&quot;Explanation: &quot;a&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;.&quot;cd&quot; starts at index 2 in S, so it&apos;s replaced by &quot;ffff&quot;. Example 2:1234Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]Output: &quot;eeecd&quot;Explanation: &quot;ab&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;. &quot;ec&quot; doesn&apos;t starts at index 2 in the original S, so we do nothing. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool static cmp(pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b) &#123; return a.first &lt; b.first; &#125; string helper(string s, vector&lt;pair&lt;int, int&gt;&gt;&amp; m, vector&lt;string&gt;&amp; src, vector&lt;string&gt;&amp; targets) &#123; string ret = ""; int n = s.size(); for (int i = 0; i &lt; n; i++) &#123; if (!m.empty() &amp;&amp; i == m[0].first) &#123; auto t = m[0]; m.erase(m.begin()); string a = src[t.second], b = targets[t.second]; if (i + a.size() &lt;= n &amp;&amp; a == s.substr(i, a.size())) &#123; ret += b; i += a.size() - 1; continue; &#125; &#125; ret.push_back(s[i]); &#125; return ret; &#125; string findReplaceString(string S, vector&lt;int&gt;&amp; indexes, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) &#123; vector&lt;pair&lt;int, int&gt;&gt; m; int n = indexes.size(); for (int i = 0; i &lt; n; i++) m.push_back(make_pair(indexes[i], i)); sort(m.begin(), m.end(), cmp); return helper(S, m, sources, targets); &#125;&#125;; 835. Image Overlap [AC] Leetcode 835 Two images A and B are given, represented as binary, square matrices of the same size. (A binary matrix has only 0s and 1s as values.) We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image. After, the overlap of this translation is the number of positions that have a 1 in both images. (Note also that a translation does not include any kind of rotation.) What is the largest possible overlap? Example 1:12345678Input: A = [[1,1,0], [0,1,0], [0,1,0]] B = [[0,0,0], [0,1,1], [0,0,1]]Output: 3Explanation: We slide A to right by 1 unit and down by 1 unit. 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: string convert(int i, int j) &#123; return to_string(i) + "-" + to_string(j); &#125; void helper(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; B, int&amp; ret, unordered_set&lt;string&gt;&amp; hash) &#123; int m = A.size(), n = A[0].size(); if (i &lt;= -m || i &gt;= m || j &lt;= -n || j &gt;= n) return; int ans = 0; for (int x = 0; x &lt; m; x ++) &#123; for (int y = 0; y &lt; n; y++) &#123; int X = x + i, Y = y + j; if (X &lt; m &amp;&amp; X &gt;= 0 &amp;&amp; Y &lt; n &amp;&amp; Y &gt;= 0 &amp;&amp; A[X][Y] == 1 &amp;&amp; B[x][y] == 1) ans ++; &#125; &#125; ret = max(ret, ans); int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;1, -1, 0, 0&#125;; for (int k = 0; k &lt; 4; k++) &#123; int x = i + a[k], y = j + b[k]; auto s = convert(x, y); if (hash.find(s) != hash.end()) continue; hash.insert(s); helper(x, y, A, B, ret, hash); &#125; &#125; int largestOverlap(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123; int ret = 0; unordered_set&lt;string&gt; m; m.insert("0-0"); helper(0, 0, A, B, ret, m); return ret; &#125;&#125;; 834. Sum of Distances in Tree [TLE] Leetcode 834 An undirected, connected tree with N nodes labelled 0…N-1 and N-1 edges are given. The ith edge connects nodes edges[i][0] and edges[i][1] together. Return a list ans, where ans[i] is the sum of the distances between node i and all other nodes. Example 1:1234567891011Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]Output: [8,12,6,10,10,10]Explanation: Here is a diagram of the given tree: 0 / \1 2 /|\ 3 4 5We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)equals 1 + 1 + 2 + 2 + 2 = 8. Hence, answer[0] = 8, and so on. 123456789101112131415161718192021222324252627282930313233// BFS 超时版本....class Solution &#123;public: int helper(int start, vector&lt;unordered_set&lt;int&gt;&gt; adj, ) &#123; vector&lt;int&gt; cur(1, start); int ret = 0, cnt = 0; while (!cur.empty()) &#123; vector&lt;int&gt; next; cnt ++; for (auto i : cur) &#123; for (auto j : adj[i]) &#123; ret += cnt; adj[j].erase(i); next.push_back(j); &#125; &#125; cur = next; &#125; return ret; &#125; vector&lt;int&gt; sumOfDistancesInTree(int N, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; vector&lt;unordered_set&lt;int&gt;&gt; adj(N); for (auto t : edges) &#123; adj[t[0]].insert(t[1]); adj[t[1]].insert(t[0]); &#125; vector&lt;int&gt; ret; for (int i = 0; i &lt; N; i++) &#123; ret.push_back(helper(i, adj)); &#125; return ret; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041// 后用dfs保存中间状态ACconst int N = 1e4 + 10;vector&lt;int&gt; a[N];int dp0[N], dp1[N];void DFS(int u, int parent) &#123; dp0[u] = 1; dp1[u] = 0; for (auto&amp; v : a[u]) &#123; if (v == parent) continue; DFS(v, u); dp0[u] += dp0[v]; dp1[u] += dp1[v] + dp0[v]; &#125;&#125;void DFS2(int u, int parent, int n, vector&lt;int&gt;&amp; ret) &#123; for (auto&amp; v : a[u]) &#123; if (v == parent) continue; ret[v] = ret[u] + (n - dp0[v]) - (dp0[v]);// cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; ret[u] &lt;&lt; " " &lt;&lt; dp0[u] &lt;&lt; " " &lt;&lt; dp0[v] &lt;&lt; " " &lt;&lt; ret[v] &lt;&lt; endl; DFS2(v, u, n, ret); &#125;&#125;class Solution &#123;public: vector&lt;int&gt; sumOfDistancesInTree(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; for (int i = 0; i &lt; n; ++i) a[i].clear(); for (auto&amp; it : edges) &#123; int x = it[0], y = it[1]; a[x].push_back(y); a[y].push_back(x); &#125; DFS(0, -1); vector&lt;int&gt; ret(n); ret[0] = dp1[0]; DFS2(0, -1, n, ret); return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】零星算法模板总结]]></title>
    <url>%2F2018%2F09%2F08%2Fleetcode-summary-some-sample%2F</url>
    <content type="text"><![CDATA[这里整理一些零星的算法，作为记录… 水塘抽样Linked List Random NodeLeetcode 382 Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? Example:12345678// Init a singly linked list [1,2,3].ListNode head = new ListNode(1);head.next = new ListNode(2);head.next.next = new ListNode(3);Solution solution = new Solution(head);// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.solution.getRandom(); 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* root; /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ Solution(ListNode* head) &#123; root = head; &#125; /** Returns a random node's value. */ int getRandom() &#123; if (!root) return -1; int ret = root-&gt;val; ListNode* cur = root-&gt;next; int cnt = 2; while (cur) &#123; int k = rand() % cnt; cnt ++; if (!k) ret = cur-&gt;val; cur = cur-&gt;next; &#125; return ret; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(head); * int param_1 = obj.getRandom(); */ Random Pick Index Leetcode 398 Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note:The array size can be very large. Solution that uses too much extra space will not pass the judge. Example:12345678int[] nums = new int[] &#123;1,2,3,3,3&#125;;Solution solution = new Solution(nums);// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(3);// pick(1) should return 0. Since in the array only nums[0] is equal to 1.solution.pick(1); 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; ans; Solution(vector&lt;int&gt; nums) &#123; ans = nums; &#125; int pick(int target) &#123; int ret = -1, cnt = 1; for (int i = 0; i &lt; ans.size(); i++) &#123; if (ans[i] == target) &#123; int key = rand() % cnt; if (!key) ret = i; cnt ++; &#125; &#125; return ret; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(nums); * int param_1 = obj.pick(target); */ 线段树Count of Smaller Numbers After Self Leetcode 315 You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example:1234567Input: [5,2,6,1]Output: [2,1,1,0] Explanation:To the right of 5 there are 2 smaller elements (2 and 1).To the right of 2 there is only 1 smaller element (1).To the right of 6 there is 1 smaller element (1).To the right of 1 there is 0 smaller element. 1234567891011121314151617181920212223242526272829303132333435363738// 此题先用二分查找树实现，线段树实现方法之后正在更新struct MyTreeNode &#123; int val; int duplicate; int cnt; MyTreeNode* left, *right; MyTreeNode(int val) : val(val), duplicate(1), cnt(0), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: int helper(int target, MyTreeNode* &amp;root) &#123; if (!root) &#123; root = new MyTreeNode(target); return 0; &#125; if (root-&gt;val &lt; target) &#123; return root-&gt;duplicate + root-&gt;cnt + helper(target, root-&gt;right); &#125; else if (root-&gt;val &gt; target) &#123; root-&gt;cnt ++; return helper(target, root-&gt;left); &#125; else &#123; root-&gt;duplicate ++; return root-&gt;cnt; &#125; &#125; vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return vector&lt;int&gt;(); int n = nums.size(); vector&lt;int&gt; ret(n, 0); MyTreeNode* root = new MyTreeNode(nums[n - 1]); for (int i = n - 2; i &gt;= 0; i--) &#123; ret[i] = helper(nums[i], root); &#125; return ret; &#125;&#125;; 最大公约数1234int gcd(int a, int b) &#123; if (!b) return a; return gcd(b, a % b);&#125; 子串和满足条件的最短长度Minimum Size Subarray Sum Leetcode 209 Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. Example:123Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint. 12345678910111213class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int ret = INT_MAX; int n = nums.size(), left = 0, right = 0, ans = 0; while (right &lt; n) &#123; ans += nums[right++]; while (left &lt; right &amp;&amp; ans - nums[left] &gt;= s) ans -= nums[left++]; if (ans &gt;= s) ret = min(ret, right - left); &#125; return ret == INT_MAX ? 0 : ret; &#125;&#125;; 上一题数组中包含正负，找和为target的最小长度1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;stdlib.h&gt;#include &lt;climits&gt;using namespace std;int helper(int target, vector&lt;int&gt;&amp; nums) &#123; int ret = INT_MAX; unordered_map&lt;int, int&gt; m; int ans = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; ans += nums[i]; int t = target - ans; m[ans] = i; if (m.count(t)) &#123; ret = min(ret, i - m[t]); &#125; &#125; return ret == INT_MAX ? 0 : ret;&#125;int main() &#123; int target, n; cin &gt;&gt; target &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(target, nums) &lt;&lt; endl; return 0;&#125; 上一题的follow up，包含正负，找出大于等于k的最小长度 Leetcode 862 Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1. Example 1:12Input: A = [1], K = 1Output: 1 Example 2:12Input: A = [1,2], K = 4Output: -1 Example 3:12Input: A = [2,-1,2], K = 3Output: 3 12345678910111213141516171819202122232425262728293031323334353637#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums, int k) &#123; int ret = INT_MAX; deque&lt;int&gt; s; int n = nums.size(); vector&lt;int&gt; ans(n + 1, 0); for (int i = 1; i &lt;= n; i++) &#123; ans[i] = ans[i - 1] + nums[i - 1]; &#125; for (int i = 0; i &lt;= n; i++) &#123; while (!s.empty() &amp;&amp; ans[i] - ans[s.front()] &gt;= k) &#123; ret = min(ret, i - s.front()); s.pop_front(); &#125; while (!s.empty() &amp;&amp; ans[s.back()] &gt;= ans[i]) s.pop_back(); s.push_back(i); &#125; return ret == INT_MAX ? -1 : ret;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums, k) &lt;&lt; endl; return 0;&#125; 快排相关快排模板12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int base = nums[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[right] &gt;= base) right --; if (left &lt; right) nums[left] = nums[right]; while (left &lt; right &amp;&amp; nums[left] &lt; base) left ++; if (left &lt; right) nums[right] = nums[left]; &#125; nums[left] = base; return left;&#125;void helper(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left &lt; right) &#123; int mid = partition(nums, left, right); helper(nums, left, mid); helper(nums, mid + 1, right); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; helper(nums, 0, n); for (auto i : nums) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 快排优化 快排的优化可以参考此处文献 基准随机化算法 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int base = nums[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[right] &gt;= base) right --; if (left &lt; right) nums[left] = nums[right]; while (left &lt; right &amp;&amp; nums[left] &lt; base) left ++; if (left &lt; right) nums[right] = nums[left]; &#125; nums[left] = base; return left;&#125;void helper(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left &lt; right) &#123; // 随机产生基准 int index = left + rand() % (right - left + 1); swap(nums[left], nums[right]); int mid = partition(nums, left, right); helper(nums, left, mid - 1); helper(nums, mid + 1, right); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; helper(nums, 0, n - 1); for (int i : nums) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 将前后中间三个数取中值作为标兵元素 在数组大小等于一定范围的时候，改为插入排序，防止排序退化 将相等的数字聚集到一起，然后跳过此处的排序 快速选择算法模板 验证地址Leetcode 215 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int base = nums[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[right] &lt;= base) right--; if (left &lt; right) nums[left] = nums[right]; while (left &lt; right &amp;&amp; nums[left] &gt; base) left ++; if (left &lt; right) nums[right] = nums[left]; &#125; nums[left] = base; return left;&#125;int helper(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123; if (left &lt;= right) &#123; int mid = partition(nums, left, right); if (mid == k - 1) return nums[mid]; if (mid &lt; k - 1) return helper(nums, mid + 1, right, k); else return helper(nums, left, mid - 1, k); &#125; return -1;&#125;int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); if (n &lt; k) return -1; return helper(nums, 0, n - 1, k);&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; findKthLargest(nums, k) &lt;&lt; endl; return 0;&#125; 快速选择算法复杂度为O(n)的证明参考文献 最大子串和 贪心算法，最小类似 12345678910111213141516171819202122232425262728#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;climits&gt;#include &lt;stdlib.h&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums) &#123; int ans = 0, n = nums.size(); int ret = INT_MIN; for (int i = 0; i &lt; n; i++) &#123; ans += nums[i]; ret = max(ret, ans); if (ans &lt;= 0) ans = 0; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; 并查集模板12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int find(vector&lt;int&gt;&amp; nums, int x) &#123; int y = x; while (nums[x] != x) &#123; x = nums[x]; &#125; while (y != x) &#123; int t = nums[y]; nums[y] = x; y = t; &#125; return x;&#125;void merge(vector&lt;int&gt;&amp; nums, int x, int y) &#123; int p1 = find(nums, x); int p2 = find(nums, y); if (p1 != p2) &#123; nums[p1] = p2; &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) nums[i] = i; for (int i = 0; i &lt; k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(nums, x, y); &#125; int ret = 0; for (int i = 0; i &lt; n; i++) &#123; if (i == find(nums, i)) ret ++; &#125; cout &lt;&lt; ret &lt;&lt; endl; return 0;&#125; 牛顿法 Leetcode 69 Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1:12Input: 4Output: 2 Example 2:1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 12345678910class Solution &#123;public: int mySqrt(int x) &#123; long long ret = x; while (ret * ret &gt; x) &#123; ret = (ret + x / ret) / 2; &#125; return ret; &#125;&#125;; 堆排序 验证地址 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void heapfy(vector&lt;int&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; nums[left] &lt; nums[smallest]) smallest = left; if (right &lt; max &amp;&amp; nums[right] &lt; nums[smallest]) smallest = right; if (smallest != index) &#123; swap(nums[index], nums[smallest]); heapfy(nums, smallest, max); &#125;&#125;int helper(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); if (n &lt; k) return -1; vector&lt;int&gt; ans; for (int i = 0; i &lt; k; i++) &#123; ans.push_back(nums[i]); &#125; for (int i = k / 2 - 1; i &gt;= 0; i--) heapfy(ans, i, k); for (int i = k; i &lt; n; i++) &#123; if (nums[i] &lt; ans[0]) continue; ans[0] = nums[i]; for (int j = k / 2 - 1; j &gt;= 0; j--) heapfy(ans, j, k); &#125; return ans[0];&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums, k) &lt;&lt; endl; return 0;&#125; 拓扑排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;unordered_set&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; helper(vector&lt;unordered_set&lt;int&gt;&gt;&amp; adj, vector&lt;int&gt;&amp; cnt) &#123; int n = cnt.size(); unordered_set&lt;int&gt; m; vector&lt;int&gt; cur; vector&lt;vector&lt;int&gt;&gt; ret; for (int i = 0; i &lt; n; i++) &#123; if (!cnt[i]) &#123; cur.push_back(i); m.insert(i); &#125; &#125; while (true) &#123; ret.push_back(cur); vector&lt;int&gt; next; for (auto i : cur) &#123; for (auto j : adj[i]) &#123; cnt[j]--; if (!cnt[j]) &#123; if (m.find(j) != m.end()) return vector&lt;vector&lt;int&gt;&gt;(); next.push_back(j); m.insert(j); &#125; &#125; &#125; if (next.empty()) break; else cur = next; &#125; if (n != m.size()) return vector&lt;vector&lt;int&gt;&gt;(); return ret;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; cnt(n, 0); vector&lt;unordered_set&lt;int&gt;&gt; adj(n); for (int i = 0; i &lt; k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cnt[y]++; adj[x].insert(y); &#125; auto ret = helper(adj, cnt); for (auto i : ret) &#123; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 快速幂Pow(x, n) Leetcode 50 Implement pow(x, n), which calculates x raised to the power n (xn). 12Input: 2.00000, 10Output: 1024.00000 代码1234567891011121314class Solution &#123;public: double myPow(double x, int n) &#123; double ret = 1.0; // 注意要整型溢出 long N = abs((long) n); while (N) &#123; if (N &amp; 1) ret *= x; N &gt;&gt;= 1; x *= x; &#125; return n &gt; 0 ? ret : 1 / ret; &#125;&#125;; 矩阵快速幂 矩阵乘法还可以做dp优化，之后更新…. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;vector&gt;#include &lt;iostream&gt;#define MOD 1000000007using namespace std;vector&lt;vector&lt;int&gt;&gt; mul(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123; int n = A.size(); vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(n, 0)); for (int i = 0;i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; ret[i][j] += A[i][k] * B[k][j]; ret[i][j] %= MOD; &#125; &#125; &#125; return ret;&#125;vector&lt;vector&lt;int&gt;&gt; Qpow(vector&lt;vector&lt;int&gt;&gt; nums, int k) &#123; int n = nums.size(); cout &lt;&lt; n &lt;&lt; endl; vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; n; i++) &#123; ret[i][i] = 1; &#125; while (k) &#123; if (k &amp; 1) ret = mul(ret, nums); nums = mul(nums, nums); k &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; nums(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; auto ret = Qpow(nums, k); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; ret[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 验证地址 全排列相关Permutation Sequence Leetcode 60 对于数字全排列可以用这种方法 12345678910111213141516string getPermutation(int n, int k) &#123; long long ans[n + 1] = &#123;1&#125;; string ret; vector&lt;int&gt; nums; for (int i = 1; i &lt;= n; i++) &#123; ans[i] = ans[i - 1] * i; nums.push_back(i); &#125; for (int i = 0; i &lt; n; i++) &#123; int index = (k - 1) / ans[n - i - 1]; ret += to_string(nums[index]); nums.erase(nums.begin() + index); k = k - ans[n - i - 1] * index; &#125; return ret;&#125; 字母全排列 数字可以用上面的方法，但是对于字母来说就不行了，因为long long也存不下所有全排列的种类数 第二个思路是使用nextPermutation，此函数的原理是 从最后向前找相邻的两个元素是的i &lt; ii 然后再从最后向前找一个元素使得i &lt; j i和j交换，然后将ii之后的元素reverse排序 nextPermutation的头文件是algorithm 12345678910string getPermutation(int n, int k) &#123; string ret; for (int i = 1; i &lt;= n; i++) &#123; ret += to_string(i); &#125; for (int i = 1; i &lt; k; i++) &#123; next_permutation(ret.begin(), ret.end()); &#125; return ret;&#125; 面试题集合面试题1 一个树形的图，要遍历其中k个节点，最少需要走多少步 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;unordered_set&gt;using namespace std;int helper(vector&lt;unordered_set&lt;int&gt;&gt;&amp; adj) &#123; int n = adj.size(); int ret = 0; vector&lt;int&gt; cur; for (int i = 0; i &lt; n; i++) &#123; if (adj[i].size() == 1) cur.push_back(i); &#125; while (true) &#123; ret ++; vector&lt;int&gt; next; for (auto i : cur) &#123; for (auto j : adj[i]) &#123; adj[j].erase(i); if (adj[j].size() == 1) next.push_back(j); &#125; &#125; if (next.empty()) break; else cur = next; &#125; if (cur.size() == 1) return 2 *(ret - 1); else return 2 * (ret - 1) + 1;&#125;int main() &#123; int n, k, d; cin &gt;&gt; n &gt;&gt; k &gt;&gt; d; vector&lt;unordered_set&lt;int&gt;&gt; adj(n, unordered_set&lt;int&gt;()); for (int i = 0; i &lt; k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; adj[x].insert(y); adj[y].insert(x); &#125; int len = helper(adj), ret; if (len &gt;= d) ret = d; else ret = len + (d - len) * 2; cout &lt;&lt; ret &lt;&lt; endl; return 0;&#125; 面试题2 表达式求值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;double getNum(string s, int&amp; index) &#123; double ret = 0.0; int cnt = -1, n = s.size(); while (index &lt; n &amp;&amp; (s[index] == '.' || isdigit(s[index]))) &#123; if (s[index] == '.') cnt ++; else &#123; ret = ret * 10 + (s[index] - '0'); if (cnt &gt;= 0) cnt ++; &#125; index ++; &#125; if (cnt == -1) cnt = 0; return ret / pow(10, cnt);&#125;double helper(string s, int&amp; index) &#123; double ret = 0.0, cur_ret = 0.0; char op = '+'; int n = s.size(); while (index &lt; n &amp;&amp; s[index] != ')') &#123; if (s[index] == ' ') &#123; index ++; continue; &#125; if (isdigit(s[index]) || s[index] == '(') &#123; double ans; if (isdigit(s[index])) ans = getNum(s, index); else &#123; index ++; ans = helper(s, index); index ++; &#125; switch(op) &#123; case '+' : cur_ret += ans; break; case '-' : cur_ret -= ans; break; case '*' : cur_ret *= ans; break; case '/' : cur_ret /= ans; break; &#125; &#125; else &#123; if (s[index] == '+' || s[index] == '-') &#123; ret += cur_ret; cur_ret = 0.0; &#125; op = s[index++]; &#125; &#125; return ret + cur_ret;&#125;int main() &#123; string s; cin &gt;&gt; s; int index = 0; cout &lt;&lt; helper(s, index) &lt;&lt; endl; return 0;&#125; 面试题3 寻找能使数组跷跷板平衡的支点有几个 123456789101112131415161718192021222324252627282930#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), ret = 0; for (int i = 0; i &lt;= n; i++) &#123; int left = 0, right = 0; for (int j = 0; j &lt; i; j++) &#123; left += (i - j) * nums[j]; &#125; for (int j = i; j &lt; n; j++) &#123; right += (j - i + 1) * nums[j]; &#125; if (left == right) ret ++; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; 面试题4 给定一组数，表示他所在组的大小，输出一个数组，同一分组的在一起，数组保证字典序最小 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0];&#125;vector&lt;int&gt; helper(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ret; vector&lt;vector&lt;int&gt;&gt; ans; unordered_map&lt;int, vector&lt;int&gt;&gt; m; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; m[nums[i]].push_back(i); if (m[nums[i]].size() == nums[i]) &#123; ans.push_back(m[nums[i]]); m[nums[i]].clear(); &#125; &#125; sort(ans.begin(), ans.end(), cmp); for (auto i : ans) &#123; ret.insert(ret.end(), i.begin(), i.end()); &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 面试题5题目：给定一个状态转移图，和一个目标字符集合 M=| |A |B |C ||——|:—:|:—:|:—:||A |B,C |C |A ||B |A,C |C |C ||C |A |A |A,B | S={A,B,C} 每两个字符可以转换成一个字符，例如AAB可以转成BC，判断是否能最后转化成目标集合中的字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;vector&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;unordered_set&gt;using namespace std;bool helper(map&lt;char, map&lt;char, string&gt;&gt;&amp; trans, unordered_set&lt;char&gt;&amp; goals, string cur, string next, int index) &#123; int n = cur.size(); if (index == n) &#123; if (n == 1) return goals.find(cur[0]) != goals.end(); return helper(trans, goals, next, "", 1); &#125; for (auto i : trans[cur[index - 1]][cur[index]]) &#123; if (helper(trans, goals, cur, next + i, index + 1)) return true; &#125; return false;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; map&lt;char, map&lt;char, string&gt;&gt; trans; unordered_set&lt;char&gt; goals; for (int i = 0; i &lt; n * n; i++) &#123; char x, y; string s; cin &gt;&gt; x &gt;&gt; y &gt;&gt; s; trans[x][y] = s; &#125; for (int i = 0; i &lt; k; i++) &#123; char x; cin &gt;&gt; x; goals.insert(x); &#125; string s; cin &gt;&gt; s; cout &lt;&lt; helper(trans, goals, s, "", 1) &lt;&lt; endl; return 0;&#125;/*3 3A A BCA B CA C AB A ACB B CB C CC A AC B AC C ABA B CAAB*/]]></content>
      <tags>
        <tag>算法</tag>
        <tag>总结</tag>
        <tag>Leetcode</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode DP及贪心算法总结]]></title>
    <url>%2F2018%2F09%2F05%2Fleetcode-summary-dp-and-greedy%2F</url>
    <content type="text"><![CDATA[这里总结一些DP类型的题目，因为贪心一定程度可以认为是一维的DP，所以也做总结 贪心 Jump Game Leetcode 55 Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1:123Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:1234Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 1234567891011class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return true; int n = nums.size(), reach = 0, index = 0; for (index = 0; index &lt; n &amp;&amp; index &lt;= reach; index ++) &#123; reach = max(reach, index + nums[index]); &#125; return reach &gt;= n - 1; &#125;&#125;; Majority Element II Leetcode 229 Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1:12Input: [3,2,3]Output: [3] Example 2:12Input: [1,1,1,3,3,2,2,2]Output: [1,2] 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int c1 = 0, c2 = 0, i1 = 0, i2 = 1; for (auto i : nums) &#123; if (i == i1) c1 ++; else if (i == i2) c2 ++; else if (!c1) i1 = i, c1 = 1; else if (!c2) i2 = i, c2 = 1; else c1--, c2--; &#125; c1 = 0, c2 = 0; for (auto i : nums) &#123; if (i == i1) c1++; if (i == i2) c2++; &#125; vector&lt;int&gt; ret; if (c1 &gt; n / 3) ret.push_back(i1); if (c2 &gt; n / 3) ret.push_back(i2); return ret; &#125;&#125;; Queue Reconstruction by Height Leetcode 406 Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note:The number of people is less than 1,100. Example12345Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 1234567891011121314class Solution &#123;public: bool static cmp(pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b) &#123; return a.first == b.first ? a.second &lt; b.second : a.first &gt; b.first; &#125; vector&lt;pair&lt;int, int&gt;&gt; reconstructQueue(vector&lt;pair&lt;int, int&gt;&gt;&amp; people) &#123; sort(people.begin(), people.end(), cmp); vector&lt;pair&lt;int, int&gt;&gt; ret; for (auto i : people) &#123; ret.insert(ret.begin() + i.second, i); &#125; return ret; &#125;&#125;; Minimum Number of Arrows to Burst Balloons Leetcode 452 There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. Example:12345678Input:[[10,16], [2,8], [1,6], [7,12]]Output:2Explanation:One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons). 1234567891011121314151617181920212223class Solution &#123;public: // 扫描线算法 bool static cmp(pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b) &#123; return a.first == b.first ? a.second &lt; b.second : a.first &lt; b.first; &#125; int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; if (points.empty()) return 0; int ret = 1, n = points.size(); sort(points.begin(), points.end(), cmp); int limit = points[0].second; for (auto i : points) &#123; if (i.first &gt; limit) &#123; ret ++; limit = i.second; &#125; else &#123; limit = min(limit, i.second); &#125; &#125; return ret; &#125;&#125;; Remove K Digits Leetcode 402 Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero. Example 1:123Input: num = &quot;1432219&quot;, k = 3Output: &quot;1219&quot;Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2:123Input: num = &quot;10200&quot;, k = 1Output: &quot;200&quot;Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3:123Input: num = &quot;10&quot;, k = 2Output: &quot;0&quot;Explanation: Remove all the digits from the number and it is left with nothing which is 0. 1234567891011121314151617181920212223242526class Solution &#123;public:// 这里用了栈，其实也可以用两个指针实现 string removeKdigits(string num, int k) &#123; int n = num.size(); if (n &lt;= k) return "0"; stack&lt;char&gt; s; for (auto i : num) &#123; while (!s.empty() &amp;&amp; k &amp;&amp; s.top() &gt; i) &#123; k--; s.pop(); &#125; s.push(i); &#125; for (int i = 0; i &lt; k; i++) &#123; s.pop(); &#125; string ret; while (!s.empty()) &#123; ret = s.top() + ret; s.pop(); &#125; while (!ret.empty() &amp;&amp; ret[0] == '0') ret.erase(ret.begin()); return ret.empty() ? "0" : ret; &#125;&#125;; 动态规划矩阵链相乘 算法导论 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;climits&gt;#include &lt;math.h&gt;using namespace std;int helper(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; p(n + 1, 0); for (int i = 0; i &lt; n; i++) &#123; p[i] = nums[i].first; &#125; p[n] = nums.back().second; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); for (int i = 2; i &lt;= n; i++) &#123; for (int l = 0; l &lt;= n - i; l ++) &#123; int r = l + i - 1; dp[l][r] = INT_MAX; for (int k = l; k &lt; r; k++) &#123; int ans = dp[l][k] + dp[k + 1][r] + p[l] * p[k + 1] * p[r + 1]; dp[l][r] = min(dp[l][r], ans); &#125; &#125; &#125; return dp[0][n - 1];&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; nums; for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; nums.push_back(&#123;x, y&#125;); &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; Gas Station Leetcode 134 There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note: If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer. Example 1:1234567891011121314Input: gas = [1,2,3,4,5]cost = [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 4. Your tank = 4 - 1 + 5 = 8Travel to station 0. Your tank = 8 - 2 + 1 = 7Travel to station 1. Your tank = 7 - 3 + 2 = 6Travel to station 2. Your tank = 6 - 4 + 3 = 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index. Example 2:12345678910111213Input: gas = [2,3,4]cost = [3,4,3]Output: -1Explanation:You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 0. Your tank = 4 - 3 + 2 = 3Travel to station 1. Your tank = 3 - 3 + 3 = 3You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.Therefore, you can&apos;t travel around the circuit once no matter where you start. 1234567891011121314151617class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int ans = 0, c = 0, g = 0; int ret = 0; for (int i = 0; i &lt; gas.size(); i++) &#123; ans += gas[i] - cost[i]; g += gas[i]; c += cost[i]; if (ans &lt; 0) &#123; ans = 0; ret = i + 1; &#125; &#125; return g &gt;= c ? ret : -1; &#125;&#125;; Counting Bits Leetcode 338 Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example 1:12Input: 2Output: [0,1,1] Example 2:12Input: 5Output: [0,1,1,2,1,2] 12345678910class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; dp(num + 1, 0); for (int i = 1; i &lt;= num; i++) &#123; dp[i] = dp[i &amp; (i - 1)] + 1; &#125; return dp; &#125;&#125;; House Robber II Leetcode 213 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1:1234Input: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2:1234Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. 12345678910111213141516class Solution &#123;public: int helper(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int pre = 0, ret = 0; for (int i = left; i &lt;= right; i++) &#123; int temp = max(pre + nums[i], ret); pre = ret, ret = temp; &#125; return ret; &#125; int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt; 2) return n == 0 ? 0 : nums[0]; return max(helper(nums, 0, n - 2), helper(nums, 1, n - 1)); &#125;&#125;; Largest Divisible Subset Leetcode 368 Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1:12Input: [1,2,3]Output: [1,2] (of course, [1,3] will also be ok) Example 2:12Input: [1,2,4,8]Output: [1,2,4,8] 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; ret; sort(nums.begin(), nums.end(), greater&lt;int&gt;()); vector&lt;int&gt; dp(n, 0); vector&lt;int&gt; parents(n, -1); int index = -1, m = 0; for (int i = 0; i &lt; n; i++) &#123; dp[i] = 1; parents[i] = i; for (int j = 0; j &lt; i; j ++) &#123; if (nums[j] % nums[i] == 0 &amp;&amp; dp[i] &lt; dp[j] + 1) &#123; dp[i] = dp[j] + 1; parents[i] = j; &#125; &#125; if (m &lt; dp[i]) &#123; m = dp[i]; index = i; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; ret.push_back(nums[index]); index = parents[index]; &#125; reverse(ret.begin(), ret.end()); return ret; &#125;&#125;; Best Time to Buy and Sell Stock with Cooldown Leetcode 309 Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example:123Input: [1,2,3,0,2]Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy(INT_MIN), sell(0), pre_sell(0); for (auto i : prices) &#123; int pre_buy = buy; buy = max(buy, pre_sell - i); pre_sell = sell; sell = max(sell, pre_buy + i); &#125; return sell; &#125;&#125;; 最长公共子序列12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;string helper(string a, string b) &#123; int m = a.size(), n = b.size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); vector&lt;vector&lt;int&gt;&gt; parents(m + 1, vector&lt;int&gt;(n + 1, 0)); for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (a[i - 1] == b[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; parents[i][j] = 1; &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); if (dp[i - 1][j] &gt; dp[i][j - 1]) parents[i][j] = 2; else parents[i][j] = 3; &#125; &#125; &#125; string ret; while (m &amp;&amp; n) &#123; if (parents[m][n] == 1) &#123; ret = a[m - 1] + ret; m--, n--; &#125; else if (parents[m][n] == 2) &#123; m--; &#125; else n--; &#125; return ret;&#125;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; helper(a, b) &lt;&lt; endl; return 0;&#125; Word Break Leetcode 139 Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1:123Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]Output: trueExplanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;. Example 2:1234Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]Output: trueExplanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;. Note that you are allowed to reuse a dictionary word. Example 3:12Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output: false 1234567891011121314151617181920class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; if (wordDict.empty()) return false; int n = s.size(); vector&lt;bool&gt; dp(n + 1, false); dp[0] = true; for (int i = 0; i &lt;= n; i++) &#123; if (!dp[i]) continue; for (int j = i + 1; j &lt;= n; j++) &#123; string ans = s.substr(i, j - i); if (find(wordDict.begin(), wordDict.end(), ans) != wordDict.end()) &#123; dp[j] = true; &#125; &#125; &#125; return dp[n]; &#125;&#125;; Wiggle Subsequence Leetcode 376 A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Examples:12345678910Input: [1,7,4,9,2,5]Output: 6The entire sequence is a wiggle sequence.Input: [1,17,5,10,13,15,10,5,16,8]Output: 7There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].Input: [1,2,3,4,5,6,7,8,9]Output: 2 1234567891011class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int f = 1, d = 1, n = nums.size(); for (int i = 1; i &lt; nums.size(); i++) &#123; if (nums[i] &gt; nums[i - 1]) f = d + 1; if (nums[i] &lt; nums[i - 1]) d = f + 1; &#125; return min(max(f, d), n); &#125;&#125;; Arithmetic Slices Leetcode 413 A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.12345678910111213141516For example, these are arithmetic sequence:1, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9The following sequence is not arithmetic.1, 1, 2, 5, 7A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.A slice (P, Q) of array A is called arithmetic if the sequence:A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.The function should return the number of arithmetic slices in the array A. Example:123A = [1, 2, 3, 4]return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself. 123456789101112131415class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt; 3) return 0; int cur = nums[1] - nums[0] == nums[2] - nums[1] ? 1 : 0; int ret = cur; for (int i = 3; i &lt; n; i++) &#123; if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) cur ++; else cur = 0; ret += cur; &#125; return ret; &#125;&#125;; Regular Expression Matching Leetcode 10 Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.123&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1:12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2:12345Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;. Example 3:12345Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;. Example 4:12345Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;. Example 5:1234Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool isMatch(string s, string p) &#123; if (s.empty() &amp;&amp; p.empty()) return true; int m = s.size(), n = p.size(); bool dp[m + 1][n + 1]; memset(dp, false, sizeof(dp)); dp[0][0] = true; for (int i = 1; i &lt;= n; i++) &#123; dp[0][i] = p[i - 1] == '*' &amp;&amp; dp[0][i - 2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (p[j - 1] == '*') &#123; char c = p[j - 2]; if (c != '.' &amp;&amp; s[i - 1] != c) dp[i][j] = dp[i][j - 2]; else dp[i][j] = (dp[i][j - 2] || dp[i - 1][j] || dp[i - 1][j - 2]); // .* // 不匹配：dp[i][j - 2] // 匹配.：dp[i - 1][j - 2] // 匹配.*：dp[i - 1][j] 因为i-1不一定是由.匹配的可能是由*匹配的，所以用dp[i - 1][j] &#125; else dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == '.') &amp;&amp; dp[i - 1][j - 1]; &#125; &#125; return dp[m][n]; &#125;&#125;; Wildcard Matching Leetcode 44 Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’. ‘?’ Matches any single character.‘*’ Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z.p could be empty and contains only lowercase letters a-z, and characters like ? or *. Example 1:12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2:12345Input:s = &quot;aa&quot;p = &quot;*&quot;Output: trueExplanation: &apos;*&apos; matches any sequence. Example 3:12345Input:s = &quot;cb&quot;p = &quot;?a&quot;Output: falseExplanation: &apos;?&apos; matches &apos;c&apos;, but the second letter is &apos;a&apos;, which does not match &apos;b&apos;. Example 4:12345Input:s = &quot;adceb&quot;p = &quot;*a*b&quot;Output: trueExplanation: The first &apos;*&apos; matches the empty sequence, while the second &apos;*&apos; matches the substring &quot;dce&quot;. Example 5:1234Input:s = &quot;acdcb&quot;p = &quot;a*c?b&quot;Output: false 123456789101112131415161718192021class Solution &#123;public: bool isMatch(string s, string p) &#123; if (s.empty() &amp;&amp; p.empty()) return true; int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false)); dp[0][0] = true; for (int i = 1; i &lt;= n; i++) &#123; dp[0][i] = p[i - 1] == '*' &amp;&amp; dp[0][i - 1]; &#125; for (int i = 1; i &lt;= m; i++) &#123; char c = s[i - 1]; for (int j = 1; j &lt;= n; j++) &#123; char t = p[j - 1]; if (t == '?' || t == c) dp[i][j] = dp[i - 1][j - 1]; if (t == '*') dp[i][j] = dp[i - 1][j - 1] || dp[i][j - 1] || dp[i - 1][j]; &#125; &#125; return dp[m][n]; &#125;&#125;; Length of Longest Fibonacci Subsequence Leetcode 873 A sequence X_1, X_2, …, X_n is fibonacci-like if: n &gt;= 3 Xi + X{i+1} = X_{i+2} for all i + 2 &lt;= n Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A. If one does not exist, return 0. (Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].) Example 1:1234Input: [1,2,3,4,5,6,7,8]Output: 5Explanation:The longest subsequence that is fibonacci-like: [1,2,3,5,8]. Example 2:12345Input: [1,3,7,11,12,14,18]Output: 3Explanation:The longest subsequence that is fibonacci-like:[1,11,12], [3,11,14] or [7,11,18]. 12345678910111213141516171819202122232425class Solution &#123;public: int lenLongestFibSubseq(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt; 3) return 0; unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; n; i++) &#123; m[nums[i]] = i; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, 0)); int ret = 2; // 从后向前更新，将阶段的结果用于后面的过程 for (int i = n - 2; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; dp[i][j] = 2; int ans = nums[i] + nums[j]; if (!m.count(ans)) continue; int k = m[ans]; dp[i][j] = dp[j][k] + 1; ret = max(dp[i][j], ret); &#125; &#125; return ret &gt;= 3 ? ret : 0; &#125;&#125;; 背包Ones and Zeroes Leetcode 474 In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue. For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s. Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once. Note: The given numbers of 0s and 1s will both not exceed 100 The size of given string array won’t exceed 600. Example 1:123Input: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3Output: 4Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0” Example 2:123Input: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1Output: 2Explanation: You could form &quot;10&quot;, but then you&apos;d have nothing left. Better form &quot;0&quot; and &quot;1&quot;. 1234567891011121314151617181920212223class Solution &#123;public: void helper(string s, int&amp; one, int&amp; zero) &#123; one = zero = 0; for (auto i : s) &#123; if (i == '0') zero ++; else one ++; &#125; &#125; int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); for (auto s : strs) &#123; int o, z; helper(s, o, z); for (int i = m; i &gt;= z; i--) &#123; for (int j = n; j &gt;= o; j--) &#123; dp[i][j] = max(dp[i][j], dp[i - z][j - o] + 1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; Partition Equal Subset Sum Leetcode 416 Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1:12345Input: [1, 5, 11, 5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2:12345Input: [1, 2, 3, 5]Output: falseExplanation: The array cannot be partitioned into equal sum subsets. 123456789101112131415161718class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) return false; int ans = 0; for (auto i : nums) ans += i; if (ans % 2) return false; int target = ans / 2; vector&lt;bool&gt; dp(target + 1, false); dp[0] = true; for (auto i : nums) &#123; for (int j = target; j &gt;= i; j--) &#123; dp[j] = dp[j] || dp[j - i]; &#125; &#125; return dp[target]; &#125;&#125;; 最长回文子序列 参考资料 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;int helper(string s) &#123; if (s.empty()) return 0; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; n; i++) &#123; dp[i][i] = 1; &#125; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; return dp[0][n - 1];&#125;int main() &#123; string s; cin &gt;&gt; s; cout &lt;&lt; helper(s) &lt;&lt; endl; return 0;&#125; 回文子序列个数12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int helper(string s) &#123; int n = s.size(); if (!n) return 0; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (s[i] == s[j]) &#123; dp[i][j] = dp[i + 1][j] + dp[i][j + 1] + 1; &#125; else &#123; dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]; &#125; &#125; &#125; return dp[0][n - 1];&#125;int main() &#123; string s; cin &gt;&gt; s; cout &lt;&lt; helper(s) &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>总结</tag>
        <tag>Leetcode</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 搜索算法相关整理]]></title>
    <url>%2F2018%2F09%2F03%2Fleetcode-summary-search-algorithm%2F</url>
    <content type="text"><![CDATA[这里总结一些leetcode上比较经典的搜索类题目 快速搜索相关 Kth Largest Element in an Array Leetcode 215 Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. 1234567Example 1:Input: [3,2,1,5,6,4] and k = 2Output: 5Example 2:Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int base = nums[left]; while (left &lt; right) &#123; // 挖坑填数方法 // 第一次的left被保存到了base中，之后直接将该位置赋值为right // 则下次再找到就会赋值到right位置上，此时right原来的数保存在了原来left中，原来left的值也保存下来 // 剩下的值就是缺一个第一次的left，最后赋值到left位置就可以了 while (left &lt; right &amp;&amp; nums[right] &lt;= base) right--; if (left &lt; right) nums[left] = nums[right]; while (left &lt; right &amp;&amp; nums[left] &gt; base) left ++; if (left &lt; right) nums[right] = nums[left]; &#125; nums[left] = base; return left; &#125; int qsearch(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123; // 要注意只剩下一个数据的情况 if (left &lt;= right) &#123; int mid = partition(nums, left, right); if (mid == k - 1) return nums[mid]; if (mid &lt; k - 1) return qsearch(nums, mid + 1, right, k); else return qsearch(nums, left, mid - 1, k); &#125; return -1; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); if (len &lt; k || k &lt; 1) return -1; return qsearch(nums, 0, len - 1, k); &#125;&#125;; Wiggle Sort II Leetcode 324 Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….1234567Example 1:Input: nums = [1, 5, 1, 1, 6, 4]Output: One possible answer is [1, 4, 1, 5, 1, 6].Example 2:Input: nums = [1, 3, 2, 2, 3, 1]Output: One possible answer is [2, 3, 1, 3, 1, 2]. 1234567891011121314class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; // 之所以这样是防止中间的部分重叠例如[4, 5, 5, 6] vector&lt;int&gt; ans(nums); sort(ans.begin(), ans.end()); int n = nums.size(); int l = (n + 1) / 2 - 1, r = n - 1; for (int i = 0; i &lt; n; i++) &#123; if (i &amp; 1) nums[i] = ans[r--]; else nums[i] = ans[l--]; &#125; &#125;&#125;; Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space? 主要思想是先用快速找到中间的数，然后利用快搜中partition的思想将前半数据放到奇数位上，后半段的数放入偶数位，解释可以参考Discuss12345678910111213141516171819202122void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // Find a median. auto midptr = nums.begin() + n / 2; nth_element(nums.begin(), midptr, nums.end()); int mid = *midptr; // Index-rewiring. #define A(i) nums[(1+2*(i)) % (n|1)] // 3-way-partition-to-wiggly in O(n) time with O(1) space. int i = 0, j = 0, k = n - 1; while (j &lt;= k) &#123; if (A(j) &gt; mid) swap(A(i++), A(j++)); else if (A(j) &lt; mid) swap(A(j), A(k--)); else j++; &#125;&#125; 并查集Longest Consecutive Sequence Leetcode 128 Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example:123Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. 12345678910111213141516171819class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; m; int ret = 0; for (auto i : nums) &#123; int l = 0, r = 0; // 此题借用了并查集的思想，将边缘的数据进行合并 // 找到就跳过，防止存在中间结果 if (m.find(i) != m.end()) continue; if (m.find(i - 1) != m.end()) l = m[i - 1]; if (m.find(i + 1) != m.end()) r = m[i + 1]; int ans = l + r + 1; ret = max(ret, ans); m[i] = m[i - l] = m[i + r] = ans; &#125; return ret; &#125;&#125;; BFSBFS因为占用的空间比较大且一般时间比较长，所以经常用在需要全部数据都要检索的题目上，一般的类型包括： 图上任意两点之间的距离 图的拓扑排序 树与层数相关的题目，例如树形图的直径，寻找根节点等 可能还有其他的类型，之后会来补充… Course Schedule （拓扑排序） Leetcode 207 There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?123456789101112Example 1:Input: 2, [[1,0]] Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.Example 2:Input: 2, [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; int ret = 0; unordered_map&lt;int, vector&lt;int&gt;&gt; adj; vector&lt;int&gt; cnt(numCourses, 0); for (auto i : prerequisites) &#123; cnt[i.first]++; adj[i.second].push_back(i.first); &#125; vector&lt;int&gt; next; for (int i = 0; i &lt; numCourses; i++) &#123; if (!cnt[i]) &#123; ret ++; next.push_back(i); &#125; &#125; while (!next.empty()) &#123; vector&lt;int&gt; cur; for (auto i : next) &#123; for (auto j : adj[i]) &#123; cnt[j]--; if (!cnt[j]) &#123; ret ++; cur.push_back(j); &#125; &#125; &#125; next = cur; &#125; return ret == numCourses; &#125;&#125;; Minimum Height Trees Leetcode 310 For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. FormatThe graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Example 1 :123456789Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]] 0 | 1 / \ 2 3 Output: [1] Example 2 :1234567891011Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 0 1 2 \ | / 3 | 4 | 5 Output: [3, 4] 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;pair&lt;int, int&gt;&gt;&amp; edges) &#123; if (n == 1) return vector&lt;int&gt;(&#123;0&#125;); vector&lt;unordered_set&lt;int&gt;&gt; adj(n, unordered_set&lt;int&gt;()); for (auto i : edges) &#123; int x = i.first, y = i.second; adj[x].insert(y); adj[y].insert(x); &#125; vector&lt;int&gt; cur; for (int i = 0; i &lt; n; i++) &#123; if (adj[i].size() == 1) cur.push_back(i); &#125; while (true) &#123; vector&lt;int&gt; next; for (auto i : cur) &#123; for (auto j : adj[i]) &#123; // 此处是细节，和拓扑排序不一样 // 因为此树形图是无向图，所以必须将反向的边删除 adj[j].erase(i); if (adj[j].size() == 1) next.push_back(j); &#125; &#125; if (next.empty()) break; else cur = next; &#125; return cur; &#125;&#125;; Reconstruct Itinerary Leetcode 332 Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].All airports are represented by three capital letters (IATA code).You may assume all tickets form at least one valid itinerary. Example 1:12Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;] Example 2:1234Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]. But it is larger in lexical order. 123456789101112131415161718192021222324252627282930// 欧拉环路class Solution &#123;public: vector&lt;string&gt; findItinerary(vector&lt;pair&lt;string, string&gt;&gt; tickets) &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; m; for (auto i : tickets) &#123; m[i.first].push_back(i.second); &#125; for (auto &amp;i : m) &#123; sort(i.second.begin(), i.second.end()); &#125; vector&lt;string&gt; ret; stack&lt;string&gt; s; s.push("JFK"); while (!s.empty()) &#123; string ans = s.top(); if (m[ans].empty()) &#123; s.pop(); ret.push_back(ans); &#125; else &#123; s.push(m[ans][0]); m[ans].erase(m[ans].begin()); &#125; &#125; reverse(ret.begin(), ret.end()); return ret; &#125;&#125;; Populating Next Right Pointers in Each Node Leetcode 116 Given a binary tree12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space.Recursive approach is fine, implicit stack space does not count as extra space for this problem.You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). Example:1234567891011121314Given the following perfect binary tree, 1 / \ 2 3 / \ / \4 5 6 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL 1234567891011121314151617181920212223242526/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) return; TreeLinkNode* pre = root; pre-&gt;next = NULL; while (pre-&gt;left) &#123; TreeLinkNode* temp = pre; while (pre) &#123; pre-&gt;left-&gt;next = pre-&gt;right; if (pre-&gt;next) pre-&gt;right-&gt;next = pre-&gt;next-&gt;left; else pre-&gt;right-&gt;next = NULL; pre = pre-&gt;next; &#125; pre = temp-&gt;left; &#125; &#125;&#125;; DFSBinary Tree Maximum Path Sum Leetcode 124 Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1:1234567Input: [1,2,3] 1 / \ 2 3Output: 6 Example 2:123456789Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7Output: 42 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int helper(TreeNode* root, int&amp; ret) &#123; if (!root) return 0; // 此题用了贪心的思路，如果路径上的和为负，则就可以删掉这段路径 // 因此可以满足任意两点之间路径和最大的值，而不用考虑是不是从叶子节点开始 int l = max(0, helper(root-&gt;left, ret)); int r = max(0, helper(root-&gt;right, ret)); ret = max(ret, l + r + root-&gt;val); return max(l, r) + root-&gt;val; &#125; int maxPathSum(TreeNode* root) &#123; int ret = INT_MIN; helper(root, ret); return ret; &#125;&#125;; Kth Smallest Element in a BST Leetcode 230 Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Example 1:1234567Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2Output: 1 Example 2:123456789Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1Output: 3 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int helper(TreeNode* root, int&amp; k) &#123; if (!root) return 0; int x = helper(root-&gt;left, k); return !k ? x : (!--k ? root-&gt;val : helper(root-&gt;right, k)); &#125; int kthSmallest(TreeNode* root, int k) &#123; if (!root) return -1; return helper(root, k); &#125;&#125;; Generate Parentheses Leetcode 22 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is:1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 123456789101112131415class Solution &#123;public: void helper(int i, int j, int n, string ans, vector&lt;string&gt;&amp; ret) &#123; if (j != i) helper(i, j + 1, n, ans + ")", ret); if (i != n) helper(i + 1, j, n, ans + "(", ret); if (j == n) ret.push_back(ans); &#125; vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; ret; if (n &lt; 1) return ret; helper(0, 0, n, "", ret); return ret; &#125;&#125;; House Robber III Leetcode 337 The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1:12345678910Input: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2:12345678910Input: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1Output: 9Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:// 不一定是隔一行，也可能是左右子树所在行不一样，但是max保证了一定是隔着的 int helper(TreeNode* root, int&amp; l, int&amp; r) &#123; if (!root) return 0; int ll = 0, lr = 0, rl = 0, rr = 0; l = helper(root-&gt;left, ll, lr); r = helper(root-&gt;right, rl, rr); return max(ll + lr + rl + rr + root-&gt;val, l + r); &#125; int rob(TreeNode* root) &#123; int l, r; return helper(root, l, r); &#125;&#125;; Decode String Leetcode 394 Given an encoded string, return it’s decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4]. Examples:123s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;. 12345678910111213141516171819202122232425class Solution &#123;public: string helper(string s, int&amp; index) &#123; string ret; int n = s.size(); while (index &lt; n &amp;&amp; s[index] != ']') &#123; if (isdigit(s[index])) &#123; int cnt = 0; while (s[index] != '[') cnt = cnt * 10 + (s[index++] - '0'); index ++; string ans = helper(s, index); index ++; for (int i = 0; i &lt; cnt; i++) ret += ans; &#125; else &#123; ret.push_back(s[index++]); &#125; &#125; return ret; &#125; string decodeString(string s) &#123; int index = 0; return helper(s, index); &#125;&#125;; Matchsticks to Square Leetcode 473 Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time. Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has. Example 1:123Input: [1,1,2,2,2]Output: trueExplanation: You can form a square with length 2, one side of the square came two sticks with length 1. Example 2:1234Input: [3,3,3,3,4]Output: falseExplanation: You cannot find a way to form a square with all the matchsticks. 12345678910111213141516171819202122232425class Solution &#123;public: bool helper(vector&lt;int&gt;&amp; ans, vector&lt;int&gt;&amp; nums, int index, int target) &#123; int n = nums.size(); if (index == n) &#123; return ans[0] == target &amp;&amp; ans[1] == target &amp;&amp; ans[2] == target; &#125; for (int i = 0; i &lt; 4; i++) &#123; if (ans[i] + nums[index] &gt; target) continue; ans[i] += nums[index]; if (helper(ans, nums, index + 1, target)) return true; ans[i] -= nums[index]; &#125; return false; &#125; bool makesquare(vector&lt;int&gt;&amp; nums) &#123; int target = 0; for (auto i : nums) target += i; if (target % 4 != 0 || nums.size() &lt; 4) return false; sort(nums.rbegin(), nums.rend()); vector&lt;int&gt; ans(4, 0); return helper(ans, nums, 0, target / 4); &#125;&#125;; follow up: Partition to K Equal Sum Subsets Leetcode 698 Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal. Example 1:123Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4Output: TrueExplanation: It&apos;s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. 1234567891011121314151617181920212223242526class Solution &#123;public: bool helper(vector&lt;int&gt; ans, int index, vector&lt;int&gt;&amp; nums, int target) &#123; int k = ans.size(), n = nums.size(); if (index == n) &#123; for (int i = 0; i &lt; k; i++) &#123; if (ans[i] != target) return false; &#125; return true; &#125; for (int i = 0; i &lt; k; i++) &#123; if (ans[i] + nums[index] &gt; target) continue; ans[i] += nums[index]; if (helper(ans, index + 1, nums, target)) return true; ans[i] -= nums[index]; &#125; return false; &#125; bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123; int ans = 0, n = nums.size(); for (auto i : nums) ans += i; if (n &lt; k || ans % k) return false; sort(nums.begin(), nums.end(), greater&lt;int&gt;()); return helper(vector&lt;int&gt;(k, 0), 0, nums, ans / k); &#125;&#125;; Subsets II Leetcode 90 DescriptionHintsSubmissionsDiscussSolutionGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example:12345678910Input: [1,2,2]Output:[ [2], [1], [1,2,2], [2,2], [1,2], []] 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; ret.push_back(vector&lt;int&gt;()); if (nums.empty()) return ret; sort(nums.begin(), nums.end()); int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; int index = 0; while (i + index &lt; n &amp;&amp; nums[i] == nums[i + index]) index ++; int len = ret.size(); for (int j = 0; j &lt; len; j++) &#123; auto temp = ret[j]; for (int k = 0; k &lt; index; k++) &#123; temp.push_back(nums[i]); ret.push_back(temp); &#125; &#125; i += index - 1; &#125; return ret; &#125;&#125;; Word Search Leetcode 79 DescriptionHintsSubmissionsDiscussSolutionGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example:12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 12345678910111213141516171819202122232425262728class Solution &#123;public: bool helper(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int index, int x, int y) &#123; // 尽量在helper函数中做相等判断，否则还需要在外层函数中实现相等判断和访问覆盖操作 if (word[index] != board[x][y]) return false; int len = word.size(), m = board.size(), n = board[0].size(); if (index == len - 1) return true; int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; board[x][y] = '\0'; for (int i = 0; i &lt; 4; i++) &#123; int X = x + a[i], Y = y + b[i]; if (X &gt;= 0 &amp;&amp; X &lt; m &amp;&amp; Y &gt;= 0 &amp;&amp; Y &lt; n &amp;&amp; helper(board, word, index + 1, X, Y)) return true; &#125; board[x][y] = word[index]; return false; &#125; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (board.empty() || board[0].empty()) return false; if (word.empty()) return true; int m = board.size(), n = board[0].size(); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (helper(board, word, 0, i, j)) return true; &#125; &#125; return false; &#125;&#125;; Longest Increasing Path in a Matrix Leetcode 329 Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1:12345678Input: nums = [ [9,9,4], [6,6,8], [2,1,1]] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9]. Example 2:12345678Input: nums = [ [3,4,5], [3,2,6], [2,2,1]] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed. 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int helper(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; ma, int x, int y) &#123; if (ma[x][y]) return ma[x][y]; int ans = matrix[x][y]; int m = matrix.size(), n = matrix[0].size(); int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; for (int i = 0; i &lt; 4; i++) &#123; int X = x + a[i], Y = y + b[i]; if (X &gt;= 0 &amp;&amp; X &lt; m &amp;&amp; Y &gt;= 0 &amp;&amp; Y &lt; n) &#123; int local = 1; if (matrix[X][Y] &gt; ans) &#123; local += helper(matrix, ma, X, Y); &#125; ma[x][y] = max(local, ma[x][y]); &#125; &#125; return ma[x][y]; &#125; int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int ret = 1; if (matrix.empty() || matrix[0].empty()) return 0; int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; ma(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; ret = max(ret, helper(matrix, ma, i, j)); &#125; &#125; return ret; &#125;&#125;; Word Break II Leetcode 140 Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note: The same word in the dictionary may be reused multiple times in the segmentation.You may assume the dictionary does not contain duplicate words. Example 1:12345678Input:s = &quot;catsanddog&quot;wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]Output:[ &quot;cats and dog&quot;, &quot;cat sand dog&quot;] Example 2:12345678910Input:s = &quot;pineapplepenapple&quot;wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]Output:[ &quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot;]Explanation: Note that you are allowed to reuse a dictionary word. Example 3:12345Input:s = &quot;catsandog&quot;wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output:[] 12345678910111213141516171819202122232425262728293031class Solution &#123;public: void merge(vector&lt;string&gt; ans, string word, vector&lt;string&gt;&amp; ret) &#123; for (auto i : ans) &#123; ret.push_back(word + " " + i); &#125; &#125; vector&lt;string&gt; helper(string s, unordered_set&lt;string&gt;&amp; dict, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; m) &#123; if (m.find(s) != m.end()) return m[s]; vector&lt;string&gt; ret; if (dict.find(s) != dict.end()) ret.push_back(s); int n = s.size(); for (int i = 0; i &lt; n; i++) &#123; string word = s.substr(0, i); if (dict.find(word) == dict.end()) continue; string rem = s.substr(i); merge(helper(rem, dict, m), word, ret); &#125; m[s] = ret; return ret; &#125; vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; dict; unordered_map&lt;string, vector&lt;string&gt;&gt; m; for (auto i : wordDict) &#123; dict.insert(i); &#125; return helper(s, dict, m); &#125;&#125;; Add and Search Word - Data structure design Leetcode 211 Design a data structure that supports the following two operations: void addWord(word)bool search(word)search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example:1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct TrieNode &#123; TrieNode* child[26]; bool isKey; TrieNode() : isKey(false) &#123; memset(child, NULL, sizeof(child)); &#125;&#125;;class WordDictionary &#123;public: TrieNode* root; /** Initialize your data structure here. */ WordDictionary() &#123; root = new TrieNode(); &#125; /** Adds a word into the data structure. */ void addWord(string word) &#123; TrieNode* cur = root; for (auto i : word) &#123; int c = i - 'a'; if (!cur-&gt;child[c]) cur-&gt;child[c] = new TrieNode(); cur = cur-&gt;child[c]; &#125; cur-&gt;isKey = true; &#125; bool helper(string s, int index, TrieNode* cur) &#123; int n = s.size(); for (int i = index; i &lt; n; i++) &#123; if (s[i] == '.') &#123; for (int j = 0; j &lt; 26; j++) &#123; if (cur-&gt;child[j] &amp;&amp; helper(s, i + 1, cur-&gt;child[j])) return true; &#125; return false; &#125; int c = s[i] - 'a'; if (!cur-&gt;child[c]) return false; cur = cur-&gt;child[c]; &#125; return cur &amp;&amp; cur-&gt;isKey; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ bool search(string word) &#123; return helper(word, 0, root); &#125;&#125;;/** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * bool param_2 = obj.search(word); */ Reconstruct Itinerary Leetcode 332 Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].All airports are represented by three capital letters (IATA code).You may assume all tickets form at least one valid itinerary. Example 1:12Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;] Example 2:1234Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]. But it is larger in lexical order. 1234567891011121314151617181920212223242526272829303132// dfs 版本class Solution &#123;public: void helper(vector&lt;string&gt;&amp; ret, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; m, int n) &#123; if (ret.size() == n) return; string ans = ret.back(); for (int i = 0; i &lt; m[ans].size(); i++) &#123; string temp = m[ans][i]; ret.push_back(temp); m[ans].erase(m[ans].begin() + i); helper(ret, m, n); if (ret.size() == n) return; ret.pop_back(); m[ans].insert(m[ans].begin() + i, temp); &#125; &#125; vector&lt;string&gt; findItinerary(vector&lt;pair&lt;string, string&gt;&gt; tickets) &#123; vector&lt;string&gt; ret; int n = tickets.size() + 1; unordered_map&lt;string, vector&lt;string&gt;&gt; m; for (auto i : tickets) &#123; m[i.first].push_back(i.second); &#125; for (auto&amp; i : m) &#123; sort(i.second.begin(), i.second.end()); &#125; ret.push_back("JFK"); helper(ret, m, n); if (ret.size() == n) return ret; else return vector&lt;string&gt;(); &#125;&#125;; Construct Binary Tree from Inorder and Postorder Traversal Leetcode 106 Given inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given123456789inorder = [9,3,15,20,7]postorder = [9,15,7,20,3]Return the following binary tree: 3 / \ 9 20 / \ 15 7 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */typedef vector&lt;int&gt;::iterator Iter;class Solution &#123;public: TreeNode* helper(Iter ibegin, Iter iend, Iter pbegin, Iter pend) &#123; if (ibegin == iend) return NULL; int val = *(pend - 1); Iter mid = find(ibegin, iend, val); TreeNode* ret = new TreeNode(val); ret-&gt;left = helper(ibegin, mid, pbegin, pbegin + (mid - ibegin)); ret-&gt;right = helper(mid + 1, iend, pbegin + (mid - ibegin), pend - 1); return ret; &#125; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return helper(inorder.begin(), inorder.end(), postorder.begin(), postorder.end()); &#125;&#125;; Restore IP Addresses Leetcode 93 Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example:12Input: &quot;25525511135&quot;Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 1234567891011121314151617181920212223242526class Solution &#123;public: void helper(string s, int index, vector&lt;string&gt;&amp; ret, vector&lt;int&gt; ans) &#123; if (ans.size() == 4 &amp;&amp; index == s.size()) &#123; ret.push_back(to_string(ans[0]) + "." + to_string(ans[1]) + "." + to_string(ans[2]) + "." + to_string(ans[3])); return; &#125; if (ans.size() &lt; 4 &amp;&amp; index &lt; s.size()) &#123; int temp = 0, n = s.size(); for (int i = 0; i &lt; 3 &amp;&amp; index + i &lt; n ; i++) &#123; if (i &amp;&amp; !temp) return; temp = temp * 10 + (s[index + i] - '0'); if (temp &lt;= 255) &#123; ans.push_back(temp); helper(s, index + i + 1, ret, ans); ans.pop_back(); &#125; &#125; &#125; &#125; vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; ret; helper(s, 0, ret, vector&lt;int&gt;()); return ret; &#125;&#125;; Different Ways to Add Parentheses Leetcode 241 Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1:12345Input: &quot;2-1-1&quot;Output: [0, 2]Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2:12345678Input: &quot;2*3-4*5&quot;Output: [-34, -14, -10, -10, 10]Explanation: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; ret; for (int i = 0; i &lt; input.size(); i++) &#123; if (ispunct(input[i])) &#123; auto c = input[i]; for (auto a : diffWaysToCompute(input.substr(0, i))) &#123; for (auto b : diffWaysToCompute(input.substr(i + 1))) &#123; ret.push_back(c == '+' ? a + b : (c == '-' ? a - b : a * b)); &#125; &#125; &#125; &#125; return ret.empty() ? vector&lt;int&gt;(&#123;stoi(input)&#125;) : ret; &#125;&#125;; Palindrome Partitioning Leetcode 131 Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example:123456Input: &quot;aab&quot;Output:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 123456789101112131415161718192021222324252627class Solution &#123;public: void helper(vector&lt;vector&lt;string&gt;&gt;&amp; ret, vector&lt;string&gt; ans, int index, string s) &#123; int n = s.size(); if (index == n) &#123; ret.push_back(ans); return; &#125; for (int i = index; i &lt; n; i++) &#123; int l = index, r = i; while (l &lt; r &amp;&amp; s[l] == s[r]) l++, r--; if (l &gt;= r) &#123; ans.push_back(s.substr(index, i - index + 1)); helper(ret, ans, i + 1, s); ans.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; ret; if (s.empty()) return ret; helper(ret, vector&lt;string&gt;(), 0, s); return ret; &#125;&#125;; Permutations II Leetcode Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example:1234567Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] 12345678910111213141516171819202122class Solution &#123;public: void helper(int index, vector&lt;int&gt; ans, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; int n = ans.size(); if (index == n - 1) &#123; ret.push_back(ans); return; &#125; for (int i = index; i &lt; n; i++) &#123; if (index != i &amp;&amp; ans[i] == ans[index]) continue; swap(ans[i], ans[index]); helper(index + 1, ans, ret); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (nums.empty()) return ret; sort(nums.begin(), nums.end()); helper(0, nums, ret); return ret; &#125;&#125;; Permutation Sequence Leetcode 60 The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3:1234567&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot;Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive. Example 1:12Input: n = 3, k = 3Output: &quot;213&quot; Example 2:12Input: n = 4, k = 9Output: &quot;2314&quot; 12345678910111213141516171819202122232425class Solution &#123;public: string getPermutation(int n, int k) &#123; if (n &lt; 1) return ""; vector&lt;int&gt; fac(n, 1); vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; nums[i] = i + 1; &#125; for (int i = 1; i &lt; n; i++) &#123; fac[i] = fac[i - 1] * i; &#125; string ret; for (int i = 0; i &lt; n; i++) &#123; int index = (k - 1) / fac[n - i - 1]; ret += to_string(nums[index]); nums.erase(nums.begin() + index); k -= index * fac[n - 1 - i]; &#125; return ret; &#125;&#125;; 12345678910111213141516171819202122232425// next permutation 版本class Solution &#123;public: void next_permutation(string&amp; s) &#123; int n = s.size(); int i = n - 2; while (i &gt;= 0 &amp;&amp; s[i] &gt;= s[i + 1]) i--; if (i &gt;= 0) &#123; int j = n - 1; while (s[j] &lt;= s[i]) j --; swap(s[j], s[i]); &#125; reverse(s.begin() + i + 1, s.end()); &#125; string getPermutation(int n, int k) &#123; string ret; for (int i = 1; i &lt;= n; i++) &#123; ret = ret + to_string(i);; &#125; for (int i = 0; i &lt; k - 1; i++) &#123; next_permutation(ret); &#125; return ret; &#125;&#125;; 二分查找 二分查找一般用来简化查找逻辑，将O(n)降低成O(logn)，但是由于左右边界更新的细节比较多，每个题都需要单独推导分析 Missing Number Leetcode 268 Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. Example 1:12Input: [3,0,1]Output: 2 Example 2:12Input: [9,6,4,2,3,5,7,0,1]Output: 8 1234567891011121314// 除此之外还有循环替换算法以及位操作算法class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int left = 0, right = nums.size(); while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == mid) left = mid + 1; else right = mid; &#125; return left; &#125;&#125;; Search a 2D Matrix Leetcode 74 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1:12345678Input:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3Output: true Example 2:12345678Input:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13Output: false 123456789101112131415// 线性扫描class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty() || matrix[0].empty()) return false; int m = matrix.size(), n = matrix[0].size(); int i = 0, j = n - 1; while (i &lt; m &amp;&amp; j &gt;= 0) &#123; if (matrix[i][j] == target) return true; if (matrix[i][j] &gt; target) j--; else i ++; &#125; return false; &#125;&#125;; 1234567891011121314151617181920212223242526// 二分法class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty() || matrix[0].empty()) return false; int m = matrix.size(), n = matrix[0].size(); int low = 0, high = m - 1; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (matrix[mid][0] &gt; target) high = mid - 1; else if (matrix[mid][n - 1] &lt; target) low = mid + 1; else &#123; int left = 0, right = n - 1; while (left &lt;= right) &#123; int m = left + (right - left) / 2; int x = matrix[mid][m]; if (x == target) return true; if (x &lt; target) left = m + 1; else right = m - 1; &#125; return false; &#125; &#125; return false; &#125;&#125;; Search a 2D Matrix II Leetcode 240 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example:123456789101112Consider the following matrix:[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]Given target = 5, return true.Given target = 20, return false. 12345678910111213141516171819// 其实也就是二分查找的思想，右侧路过的值就是查找空间的上界，左侧路过的值是下界// 查找不到就是左侧和右侧不重叠会始终找不到，从而超过边界退出循环// 此处不是像惯性思维的i,j封闭了左侧封锁了搜索空间class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty() || matrix[0].empty()) return false; int m = matrix.size(), n = matrix[0].size(); int i = 0, j = n - 1; while (i &lt; m &amp;&amp; j &gt;= 0) &#123; int x = matrix[i][j]; if (x == target) return true; if (x &lt; target) i++; else j --; &#125; return false; &#125;&#125;; Kth Smallest Element in a Sorted Matrix Leetcode 378 Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example:12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. 12345678910111213141516171819202122// upper_bound是找到大于该值的第一个数，lower_bound是找到大于等于该值的第一个数class Solution &#123;public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; if (matrix.empty() || matrix[0].empty()) -1; int m = matrix.size(), n = matrix[0].size(); int left = matrix[0][0], right = matrix[m - 1][n - 1]; while (left &lt; right) &#123; int mid = left + (right - left) / 2; int cnt = 0; for (int i = 0; i &lt; m; i++) &#123; cnt += (int)(upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin()); &#125; if (cnt &lt; k) &#123; // 如果不满足等于k，则left会一直向后扩直至取到矩阵中的值 left = mid + 1; &#125; else right = mid; &#125; return left; &#125;&#125;; Median of Two Sorted Arrays Leetcode 4 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1:1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2:1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 1234567891011121314151617181920typedef vector&lt;int&gt;::iterator Iter;class Solution &#123;public: int helper(Iter l, int m, Iter r, int n, int k) &#123; if (!m) return r[k - 1]; if (!n) return l[k - 1]; if (k == 1) return min(l[0], r[0]); int i = min(m, k / 2), j = min(n, k / 2); if (l[i - 1] &lt; r[j - 1]) return helper(l + i, m - i, r, n, k - i); else return helper(l, m, r + j, n - j, k - j); &#125; double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int n1 = nums1.size(), n2 = nums2.size(); int a = helper(nums1.begin(), n1, nums2.begin(), n2, (n1 + n2 + 1) / 2); int b = helper(nums1.begin(), n1, nums2.begin(), n2, (n1 + n2 + 2) / 2); return (a + b) / 2.0; &#125;&#125;; Find Right Interval Leetcode 436 Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i. For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array. Note:You may assume the interval’s end point is always bigger than its start point.You may assume none of these intervals have the same start point. Example 1:12345Input: [ [1,2] ]Output: [-1]Explanation: There is only one interval in the collection, so it outputs -1. Example 2:1234567Input: [ [3,4], [2,3], [1,2] ]Output: [-1, 0, 1]Explanation: There is no satisfied &quot;right&quot; interval for [3,4].For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point;For [1,2], the interval [2,3] has minimum-&quot;right&quot; start point. Example 3:123456Input: [ [1,4], [2,3], [3,4] ]Output: [-1, 2, -1]Explanation: There is no satisfied &quot;right&quot; interval for [1,4] and [3,4].For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point. 1234567891011121314151617181920212223242526/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public:// map的upper_bound和lower_bound是使用二分查找 vector&lt;int&gt; findRightInterval(vector&lt;Interval&gt;&amp; intervals) &#123; int n = intervals.size(); vector&lt;int&gt; ret(n, -1); map&lt;int, int&gt; m; for (int i = 0; i &lt; n; i++) &#123; m[intervals[i].start] = i; &#125; for (int i = 0; i &lt; n; i++) &#123; auto cur = m.lower_bound(intervals[i].end); if (cur != m.end()) ret[i] = cur-&gt;second; &#125; return ret; &#125;&#125;; Find First and Last Position of Element in Sorted Array Leetcode 34 Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1:12Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Example 2:12Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; // 此题是推导更新公式最典型的题目 vector&lt;int&gt; ret(2, -1); if (nums.empty()) return ret; int n = nums.size(); int left = 0, right = n - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) left = mid + 1; else right = mid; &#125; if (nums[left] != target) return ret; else ret[0] = left; right = n - 1; while (left &lt;= right) &#123; // 等号是防止单元素 int mid = left + (right - left) / 2; if (nums[mid] &gt; target) right = mid - 1; else &#123; ret[1] = mid; left = mid + 1; &#125; &#125; return ret; &#125;&#125;; Find Minimum in Rotated Sorted Array Leetcode 153 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1:12Input: [3,4,5,1,2] Output: 1 Example 2:12Input: [4,5,6,7,0,1,2]Output: 0 1234567891011121314class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return -1; int n = nums.size(); int left = 0, right = n - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) left = mid + 1; else right = mid; &#125; return nums[left]; &#125;&#125;; Search in Rotated Sorted Array Leetcode 33 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example 1:12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2:12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 123456789101112131415161718192021222324class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.empty()) return -1; int n = nums.size(); int left = 0, right = n - 1; while (left &lt;= right) &#123; // 更新过程可能存在1，【2】这种情况， // 所以需要在更新了left之后指向同一个数依旧生效 int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; if (nums[mid] &gt; nums[right]) &#123; if (nums[mid] &gt; target &amp;&amp; nums[right] &lt; target) right = mid - 1; else left = mid + 1; &#125; else &#123; // 因为是nums[mid] &lt;= nums[right]，所以可能存在nums[right] == target if (nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target) left = mid + 1; else right = mid - 1; &#125; &#125; return -1; &#125;&#125;; Search in Rotated Sorted Array II Leetcode 81 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1:12Input: nums = [2,5,6,0,0,1,2], target = 0Output: true Example 2:12Input: nums = [2,5,6,0,0,1,2], target = 3Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why? 12345678910111213141516171819202122232425class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.empty()) return false; int n = nums.size(); int left = 0, right = n - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) return true; // 与上一题的区别在于，因为需要根据mid和right的大小判断target处于哪个区间， // 所以需要更新一下右边界 if (nums[mid] == nums[right]) right --; else if (nums[mid] &gt; nums[right]) &#123; if (nums[mid] &gt; target &amp;&amp; nums[right] &lt; target) right = mid - 1; else left = mid + 1; &#125; else &#123; if (nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target) left = mid + 1; else right = mid - 1; &#125; &#125; return false; &#125;&#125;; Koko Eating Bananas (*) Leetcode 875 Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won’t eat any more bananas during this hour. Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. Return the minimum integer K such that she can eat all the bananas within H hours. Example 1:12Input: piles = [3,6,7,11], H = 8Output: 4 Example 2:12Input: piles = [30,11,23,4,20], H = 5Output: 30 Example 3:12Input: piles = [30,11,23,4,20], H = 6Output: 23 Note: 1 &lt;= piles.length &lt;= 10^4 piles.length &lt;= H &lt;= 10^9 1 &lt;= piles[i] &lt;= 10^9 1234567891011121314151617181920212223// 二分答案，类似于求绝对值差值第K大那道题class Solution &#123;public: int minEatingSpeed(vector&lt;int&gt;&amp; piles, int H) &#123; int mx = 0; for (auto i : piles) &#123; mx = max(mx, i); &#125; int left = 1, right = mx; while (left &lt; right) &#123; int i = (left + right) / 2; long long ans = 0; for (auto j : piles) &#123; int x = j / i; ans += (j % i == 0) ? x * i : (x + 1) * i; &#125; int h = ans / i; if (h &gt; H) left = i + 1; else right = i; &#125; return left; &#125;&#125;; 特殊题目 还未归类的题目放到这里，此部分待编辑 数组中的逆序对 (*) 牛客网 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 思路可以参考牛客网 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; int length=data.size(); if(length&lt;=0) return 0; //vector&lt;int&gt; copy=new vector&lt;int&gt;[length]; vector&lt;int&gt; copy; for(int i=0;i&lt;length;i++) copy.push_back(data[i]); long long count=InversePairsCore(data,copy,0,length-1); //delete[]copy; return count%1000000007; &#125; long long InversePairsCore(vector&lt;int&gt; &amp;data,vector&lt;int&gt; &amp;copy,int start,int end) &#123; if(start==end) &#123; copy[start]=data[start]; return 0; &#125; int length=(end-start)/2; long long left=InversePairsCore(copy,data,start,start+length); long long right=InversePairsCore(copy,data,start+length+1,end); int i=start+length; int j=end; int indexcopy=end; long long count=0; while(i&gt;=start&amp;&amp;j&gt;=start+length+1) &#123; if(data[i]&gt;data[j]) &#123; copy[indexcopy--]=data[i--]; count=count+j-start-length; //count=count+j-(start+length+1)+1; &#125; else &#123; copy[indexcopy--]=data[j--]; &#125; &#125; for(;i&gt;=start;i--) copy[indexcopy--]=data[i]; for(;j&gt;=start+length+1;j--) copy[indexcopy--]=data[j]; return left+right+count; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>总结</tag>
        <tag>Leetcode</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 数据结构相关整理]]></title>
    <url>%2F2018%2F08%2F27%2Fleetcode-summary-data-structure%2F</url>
    <content type="text"><![CDATA[这里总结一些leetcode上比较经典的与数据结构相关的例题与思路，因为部分数据结构更偏向与搜索或贪心类型，该类题目就不再本部分总结… 字符串和数组字符串和数组是比较典型的线性表结构，由于比较好访问，所以通常会在该类数据结构上设计搜索和dp类型的题目。搜索和动规类型的题目会另做讨论，本部分主要总结比较典型反映字符串和数组属性的题目，例如线性表操作或双指针等。 字符串表达式求值表达式求值是一类比较考察细节的题目，一般会涉及括号，四则运算，小数和空格，所以在写的时候要注意思路清晰，以下提供一个模板： 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;double getNum(string s, int&amp; index) &#123; int n = s.size(); int cnt = -1, ans = 0; while (index &lt; n &amp;&amp; (isdigit(s[index]) || s[index] == '.')) &#123; if (s[index] == '.') cnt ++; else &#123; ans = ans * 10 + (s[index] - '0'); if (cnt &gt;= 0) cnt ++; &#125; index ++; &#125; cnt = cnt &lt; 0 ? 0 : cnt; return ans / pow(10, cnt);&#125;double helper(string s, int&amp; index) &#123; double ret = 0.0, cur_ret = 0.0; int n = s.size(); char op = '+'; while (index &lt; n &amp;&amp; s[index] != ')') &#123; if (s[index] == ' ') &#123; index ++; continue; &#125; if (isdigit(s[index]) || s[index] == '(') &#123; double temp = 0.0; if (s[index] == '(') &#123; index ++; temp = helper(s, index); index ++; &#125; else &#123; temp = getNum(s, index); &#125; switch(op) &#123; case '+' : cur_ret += temp; break; case '-' : cur_ret -= temp; break; case '*' : cur_ret *= temp; break; case '/' : cur_ret /= temp; break; &#125; &#125; else &#123; if (s[index] == '+' || s[index] == '-') &#123; ret += cur_ret; cur_ret = 0.0; &#125; op = s[index++]; &#125; &#125; return ret + cur_ret;&#125;int main() &#123; string s; cin &gt;&gt; s; int index = 0; cout &lt;&lt; helper(s, index) &lt;&lt; endl; return 0;&#125; Basic Calculator Leetcode 224 123456789101112131415Implement a basic calculator to evaluate a simple expression string.The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .Example 1:Input: &quot;1 + 1&quot;Output: 2Example 2:Input: &quot; 2-1 + 2 &quot;Output: 3Example 3:Input: &quot;(1+(4+5+2)-3)+(6+8)&quot;Output: 23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: int getNum(string s, int&amp; index) &#123; int ret = 0, n = s.size(); while (index &lt; n &amp;&amp; isdigit(s[index])) &#123; ret = ret * 10 + (s[index++] - '0'); &#125; return ret; &#125; int helper(string s, int&amp; index) &#123; int ret = 0, cur_ret = 0; char op = '+'; int n = s.size(); while (index &lt; n &amp;&amp; s[index] != ')') &#123; if (s[index] == ' ') &#123; index ++; continue; &#125; if (isdigit(s[index]) || s[index] == '(') &#123; int temp = 0; if (s[index] == '(') &#123; index ++; temp = helper(s, index); index ++; &#125; else temp = getNum(s, index); switch(op) &#123; case '+': cur_ret += temp; break; case '-': cur_ret -= temp; break; case '*': cur_ret *= temp; break; case '/': cur_ret /= temp; break; &#125; &#125; else &#123; if (s[index] == '+' || s[index] == '-') &#123; ret += cur_ret; cur_ret = 0; &#125; op = s[index ++]; &#125; &#125; return ret + cur_ret; &#125; int calculate(string s) &#123; int index = 0; return helper(s, index); &#125;&#125;; Basic Calculator II Leetcode 227 123456789101112131415Implement a basic calculator to evaluate a simple expression string.The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.Example 1:Input: &quot;3+2*2&quot;Output: 7Example 2:Input: &quot; 3/2 &quot;Output: 1Example 3:Input: &quot; 3+5 / 2 &quot;Output: 5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: int getNum(string s, int&amp; index) &#123; int ret = 0, n = s.size(); while (index &lt; n &amp;&amp; isdigit(s[index])) &#123; ret = ret * 10 + (s[index++] - '0'); &#125; return ret; &#125; int helper(string s, int&amp; index) &#123; int ret = 0, cur_ret = 0; char op = '+'; int n = s.size(); while (index &lt; n &amp;&amp; s[index] != ')') &#123; if (s[index] == ' ') &#123; index ++; continue; &#125; if (isdigit(s[index]) || s[index] == '(') &#123; int temp = 0; if (s[index] == '(') &#123; index ++; temp = helper(s, index); index ++; &#125; else temp = getNum(s, index); switch(op) &#123; case '+': cur_ret += temp; break; case '-': cur_ret -= temp; break; case '*': cur_ret *= temp; break; case '/': cur_ret /= temp; break; &#125; &#125; else &#123; if (s[index] == '+' || s[index] == '-') &#123; ret += cur_ret; cur_ret = 0; &#125; op = s[index ++]; &#125; &#125; return ret + cur_ret; &#125; int calculate(string s) &#123; int index = 0; return helper(s, index); &#125;&#125;; 字符串操作Multiply Strings Leetcode 43字符串乘法 Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. 1234567Example 1:Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;Output: &quot;6&quot;Example 2:Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;Output: &quot;56088&quot; 1234567891011121314151617181920212223class Solution &#123;public: string multiply(string num1, string num2) &#123; int n1 = num1.size(), n2 = num2.size(); string ret(n1 + n2, '0'); reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); for (int i = 0; i &lt; n1; i++) &#123; int a = num1[i] - '0'; int c = 0; for (int j = 0; j &lt; n2; j++) &#123; int b = num2[j] - '0'; int ans = a * b + c + (ret[i + j] - '0'); c = ans / 10; ret[i + j] = '0' + (ans % 10); &#125; ret[n2 + i] = c + '0'; &#125; reverse(ret.begin(), ret.end()); while (!ret.empty() &amp;&amp; ret[0] == '0') ret.erase(ret.begin()); return ret.empty() ? "0" : ret; &#125;&#125;; Add Two Numbers II Leetcode 445无符号字符串加法 You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up:What if you cannot modify the input lists? In other words, reversing the lists is not allowed.123Example:Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; string num1, num2; ListNode* cur = l1; while (cur) &#123; num1.push_back('0' + cur-&gt;val); cur = cur-&gt;next; &#125; cur = l2; while (cur) &#123; num2.push_back('0' + cur-&gt;val); cur = cur-&gt;next; &#125; string ret; int c = 0; int i = num1.size() - 1, j = num2.size() - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; int a = num1[i--] - '0'; int b = num2[j--] - '0'; int ans = c + a + b; ret = to_string(ans % 10) + ret; c = ans / 10; &#125; while (i &gt;= 0) &#123; int a = num1[i--] - '0'; int ans = c + a; ret = to_string(ans % 10) + ret; c = ans / 10; &#125; while (j &gt;= 0) &#123; int a = num2[j--] - '0'; int ans = c + a; ret = to_string(ans % 10) + ret; c = ans / 10; &#125; if (c) ret = to_string(c) + ret; ListNode* head = NULL; for (i = ret.size() - 1; i &gt;= 0; i--) &#123; ListNode* cur = new ListNode(ret[i] - '0'); cur-&gt;next = head; head = cur; &#125; return head; &#125;&#125;; 带符号字符串加减法模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;// 此处由于是默认加法所以没有对减法进行符号处理，否则这里也需要像加法一样对其进行符号判断string INT_SUB(string a, string b) &#123; int syn = 1; if (a &lt; b) &#123; string temp = a; a = b; b = temp; syn *= -1; &#125; int i = a.size() - 1, j = b.size() - 1; int c = 0; string ret; while (i &gt;= 0) &#123; int x = a[i--] - '0'; int y = b[j--] - '0'; int ans = (10 + x - y - c) % 10; c = x &lt; y ? 1 : 0; ret = (char)('0' + ans) + ret; &#125; while (ret.empty() &amp;&amp; ret[0] == '0') ret.erase(ret.begin()); if (ret.empty()) return "0"; return syn == -1 ? "-" + ret : ret;&#125;string INT_ADD(string a, string b) &#123; if (a.empty()) return b; if (b.empty()) return a; if (a[0] == '+') a.erase(a.begin()); if (b[0] == '+') b.erase(b.begin()); int syn = 1; string ret; if (a[0] == '-') &#123; if (b[0] == '-') &#123; syn = -1; ret = INT_ADD(a.substr(1), b.substr(1)); &#125; else &#123; ret = INT_SUB(b, a.substr(1)); &#125; &#125; else &#123; if (b[0] == '-') &#123; ret = INT_SUB(a, b.substr(1)); &#125; else &#123; int i = a.size() - 1, j = b.size() - 1; int c = 0; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; int x = a[i--] - '0'; int y = b[j--] - '0'; int ans = x + y + c; ret = (char)('0' + ans % 10) + ret; c = ans / 10; &#125; while (i &gt;= 0) &#123; int x = a[i--] - '0'; int ans = x + c; ret = (char)('0' + ans % 10) + ret; c = ans / 10; &#125; while (j &gt;= 0) &#123; int x = b[j--] - '0'; int ans = x + c; ret = (char)('0' + ans % 10) + ret; c = ans / 10; &#125; if (c) ret = (char)('0' + c) + ret; &#125; &#125; if (ret[0] == '-') &#123; if (syn == 1) return ret; else return ret.substr(1); &#125; else &#123; if (syn == 1) return ret; else return ret != "0" ? "-" + ret : ret; &#125;&#125;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; INT_ADD(a, b) &lt;&lt; endl; return 0;&#125; 字符串双指针题目双指针有两种用法，第一种是用于更新原字符串，另一种是用于搜索。一般而言，快指针不光可以表示原本字符串上的位置，同时还可以表示扩展字符串后的位置。 Longest Substring with At Least K Repeating Characters Leetcode 395 Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times. Example 1:1234567Input:s = &quot;aaabb&quot;, k = 3Output:3The longest substring is &quot;aaa&quot;, as &apos;a&apos; is repeated 3 times. Example 2:1234567Input:s = &quot;ababbc&quot;, k = 2Output:5The longest substring is &quot;ababb&quot;, as &apos;a&apos; is repeated 2 times and &apos;b&apos; is repeated 3 times. 123456789101112131415161718192021222324252627class Solution &#123;public: int longestSubstring(string s, int k) &#123; int ret = 0, n = s.size(); for (int h = 1; h &lt;= 26; h++) &#123; vector&lt;int&gt; m(26, 0); int i = 0, j = 0, unique = 0, ans = 0; while (j &lt; n) &#123; if (unique &lt;= h) &#123; int index = s[j++] - 'a'; m[index] ++; if (m[index] == k) ans ++; if (m[index] == 1) unique ++; &#125; else &#123; int index = s[i++] - 'a'; m[index] --; if (m[index] == k - 1) ans --; if (m[index] == 0) unique --; &#125; if (unique == h &amp;&amp; unique == ans) ret = max(ret, j - i); &#125; &#125; return ret; &#125;&#125;; Reverse Words in a String Leetcode 151 123456789101112Given an input string, reverse the string word by word.Example: Input: &quot;the sky is blue&quot;,Output: &quot;blue is sky the&quot;.Note:A word is defined as a sequence of non-space characters.Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.You need to reduce multiple spaces between two words to a single space in the reversed string.Follow up: For C programmers, try to solve it in-place in O(1) space. 123456789101112131415161718192021class Solution &#123;public: void reverseWords(string &amp;s) &#123; // 更新原本字符串 if (s.empty()) return; reverse(s.begin(), s.end()); int i = 0, cur = 0; int n = s.size(); while (i &lt; n) &#123; if (s[i] != ' ') &#123; if (cur) s[cur++] = ' '; int j = i; while (j &lt; n &amp;&amp; s[j] != ' ') s[cur++] = s[j++]; reverse(s.begin() + cur - (j - i), s.begin() + cur); i = j; &#125; i++; &#125; s.erase(s.begin() + cur, s.end()); &#125;&#125;; Minimum Window Substring Leetcode 76 123456789Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).Example:Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;Output: &quot;BANC&quot;Note:If there is no such window in S that covers all characters in T, return the empty string &quot;&quot;.If there is such window, you are guaranteed that there will always be only one unique minimum window in S. 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: string minWindow(string s, string t) &#123; // ans保存未满足的字符数 unordered_map&lt;char, int&gt; m; for (auto i : t) m[i] ++; int ans = m.size(), n = s.size(); int cnt = INT_MAX, i = 0, j = 0; string ret; while (j &lt;= n &amp;&amp; i &lt;= j) &#123; if (j &lt; n &amp;&amp; ans &gt; 0) &#123; if (m.find(s[j]) != m.end()) &#123; m[s[j]]--; if (!m[s[j]]) ans--; &#125; j ++; &#125; else &#123; if (m.find(s[i]) != m.end()) &#123; if (!m[s[i]]) ans ++; m[s[i]] ++; &#125; i++; &#125; if (!ans) &#123; if (j - i &lt; cnt) &#123; cnt = j - i; ret = s.substr(i, cnt); &#125; &#125; &#125; return ret; &#125;&#125;; Decoded String at Index Leetcode 884 An encoded string S is given. To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken: If the character read is a letter, that letter is written onto the tape.If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string. 123456789101112131415161718Example 1:Input: S = &quot;leet2code3&quot;, K = 10Output: &quot;o&quot;Explanation: The decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;.The 10th letter in the string is &quot;o&quot;.Example 2:Input: S = &quot;ha22&quot;, K = 5Output: &quot;h&quot;Explanation: The decoded string is &quot;hahahaha&quot;. The 5th letter is &quot;h&quot;.Example 3:Input: S = &quot;a2345678999999999999999&quot;, K = 1Output: &quot;a&quot;Explanation: The decoded string is &quot;a&quot; repeated 8301530446056247680 times. The 1st letter is &quot;a&quot;. 123456789101112131415161718192021222324252627282930class Solution &#123;public: string decodeAtIndex(string S, int K) &#123; int n = S.size(); // 此题因为反复更新K，也可以认为是栈类型的题目 // 但是由于栈通常一般时间复杂度为O(n)，所以放到双指针类型中 while (K &gt;= 0) &#123; long long cur = 0, pre = 0; for (int i = 0; i &lt; n; i++) &#123; if (isdigit(S[i])) &#123; cur = pre * (S[i] - '0'); if (cur &gt;= K) &#123; // 更新K K = ((K - 1) % pre) + 1; break; &#125; &#125; else &#123; cur ++; if (cur &gt;= K) &#123; // 如果超过了原本就超过K则K就会被更新 // 这里就是在当前字符串段上 return S.substr(i, 1); &#125; &#125; pre = cur; &#125; &#125; &#125;&#125;; Longest Palindromic Substring Leetcode 5 Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 12345678Example 1:Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.Example 2:Input: &quot;cbbd&quot;Output: &quot;bb&quot; 123456789101112131415161718// 最长回文数的最常见算法为O(n2)，还有优化版本，但是需要讲解数学逻辑，之后更新...class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.empty()) return s; int n = s.size(), len = 0, index = 0; for (int i = 0; i &lt; n; i++) &#123; if (n - i &lt;= len / 2) break; int l = i, r = i; while (r &lt; n - 1 &amp;&amp; s[r + 1] == s[r]) r++; while (l &gt; 0 &amp;&amp; r &lt; n - 1 &amp;&amp; s[l - 1] == s[r + 1]) l--, r++; if (len &lt; r - l + 1) &#123; index = l, len = r - l + 1; &#125; &#125; return s.substr(index, len); &#125;&#125;; 字符串处理此部分会不断更新… Validate IP Address Leetcode 468 12345678910111213141516171819202122232425262728Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (&quot;.&quot;), e.g.,172.16.254.1;Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (&quot;:&quot;). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).However, we don&apos;t replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.Note: You may assume there is no extra space or special characters in the input string.Example 1:Input: &quot;172.16.254.1&quot;Output: &quot;IPv4&quot;Explanation: This is a valid IPv4 address, return &quot;IPv4&quot;.Example 2:Input: &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;Output: &quot;IPv6&quot;Explanation: This is a valid IPv6 address, return &quot;IPv6&quot;.Example 3:Input: &quot;256.256.256.256&quot;Output: &quot;Neither&quot;Explanation: This is neither a IPv4 address nor a IPv6 address. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 此方法主要是用于练习字符串处理，如果想要寻找更加高效的算法请在leetcode discuss区寻找class Solution &#123;public: bool helper4(string s) &#123; vector&lt;string&gt; nums; string ans; int cnt = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if (isdigit(s[i]) || s[i] == '.') &#123; if (s[i] == '.') &#123; nums.push_back(ans); ans = ""; cnt ++; &#125; else &#123; ans.push_back(s[i]); &#125; &#125; else return false; &#125; nums.push_back(ans); for (string i : nums) &#123; if (i.empty() || (i.size() &gt; 1 &amp;&amp; i[0] == '0')) return false; int temp = atoi(i.c_str()); if (temp &lt; 0 || temp &gt; 255) return false; &#125; return nums.size() == 4 &amp;&amp; cnt == 3; &#125; bool helper6(string s) &#123; vector&lt;string&gt; nums; string ans; int cnt = 0; for (auto i : s) &#123; if (i == ':') &#123; nums.push_back(ans); ans = ""; cnt ++; &#125; else &#123; ans.push_back(i); &#125; &#125; nums.push_back(ans); for (auto i : nums) &#123; int n = i.size(); if (n &lt; 1 || n &gt; 4) return false; for (auto j : i) &#123; if ((j &lt;= '9' &amp;&amp; j &gt;= '0') || (j &lt;= 'F' &amp;&amp; j &gt;= 'A') || (j &lt;= 'f' &amp;&amp; j &gt;= 'a')); else return false; &#125; &#125; return nums.size() == 8 &amp;&amp; cnt == 7; &#125; string validIPAddress(string IP) &#123; if (helper4(IP)) return "IPv4"; else if (helper6(IP)) return "IPv6"; else return "Neither"; &#125;&#125;; 数组数组操作Increasing Triplet Subsequence Leetcode 334 Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, ksuch that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.1234567Example 1:Input: [1,2,3,4,5]Output: trueExample 2:Input: [5,4,3,2,1]Output: false 123456789101112class Solution &#123;public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123; int c1 = INT_MAX, c2 = INT_MAX; for (auto i : nums) &#123; if (i &lt;= c1) c1 = i; else if (i &lt;= c2) c2 = i; else return true; &#125; return false; &#125;&#125;; Contiguous Array Leetcode 525 Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.123456789Example 1:Input: [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.Example 2:Input: [0,1,0]Output: 2Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Note: The length of the given binary array will not exceed 50,000. 123456789101112131415161718class Solution &#123;public: int findMaxLength(vector&lt;int&gt;&amp; nums) &#123; // 前缀和的变形 for (auto &amp;i : nums) &#123; if (!i) i = -1; &#125; unordered_map&lt;int, int&gt; m; m[0] = -1; int ans = 0, ret = 0, n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; ans += nums[i]; if (m.find(ans) != m.end()) ret = max(ret, i - m[ans]); else m[ans] = i; &#125; return ret; &#125;&#125;; 4Sum II Leetcode 454 Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.123456789101112131415Example:Input:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]Output:2Explanation:The two tuples are:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 1234567891011121314151617181920class Solution &#123;public: void helper(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, unordered_map&lt;int, int&gt;&amp; ret) &#123; for (auto i : A) &#123; for (auto j : B) &#123; ret[i + j]++; &#125; &#125; &#125; int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; unordered_map&lt;int, int&gt; a, b; helper(A, B, a); helper(C, D, b); int ret = 0; for (auto i : a) &#123; if (b.find(-i.first) != b.end()) ret += i.second * b[-i.first]; &#125; return ret; &#125;&#125;; Largest Number Leetcode 179 Given a list of non negative integers, arrange them such that they form the largest number.1234567Example 1:Input: [10,2]Output: &quot;210&quot;Example 2:Input: [3,30,34,5,9]Output: &quot;9534330&quot; Note: The result may be very large, so you need to return a string instead of an integer. 123456789101112131415161718class Solution &#123;public: bool static cmp(const int&amp; a, const int&amp; b) &#123; string a1 = to_string(a); string b1 = to_string(b); return a1 + b1 &gt; b1 + a1; &#125; string largestNumber(vector&lt;int&gt;&amp; nums) &#123; string ret; if (nums.empty()) return ret; sort(nums.begin(), nums.end(), cmp); for (auto i : nums) &#123; ret += to_string(i); &#125; while (!ret.empty() &amp;&amp; ret[0] == '0') ret.erase(ret.begin()); return ret.empty() ? "0" : ret; &#125;&#125;; First Missing Positive Leetcode 41 Given an unsorted integer array, find the smallest missing positive integer.1234567891011Example 1:Input: [1,2,0]Output: 3Example 2:Input: [3,4,-1,1]Output: 2Example 3:Input: [7,8,9,11,12]Output: 1 12345678910111213class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]) swap(nums[nums[i] - 1], nums[i]); &#125; for (int i = 0; i &lt; n; i++) &#123; if (i + 1 != nums[i]) return i + 1; &#125; return n + 1; &#125;&#125;; Find the Duplicate Number Leetcode 287 Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.1234567Example 1:Input: [1,3,4,2,2]Output: 2Example 2:Input: [3,1,3,4,2]Output: 3 1234567891011class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return -1; for (auto &amp;i : nums) &#123; if (nums[abs(i) - 1] &lt; 0) return abs(i); nums[abs(i) - 1] *= -1; &#125; return -1; &#125;&#125;; Find All Duplicates in an Array Leetcode 442 Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?123456Example:Input:[4,3,2,7,8,2,3,1]Output:[2,3] 1234567891011class Solution &#123;public: vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ret; for (auto &amp;i : nums) &#123; if (nums[abs(i) - 1] &lt; 0) ret.push_back(abs(i)); nums[abs(i) - 1] *= -1; &#125; return ret; &#125;&#125;; Longest Substring Without Repeating Characters Leetcode 3 Given a string, find the length of the longest substring without repeating characters.123456789101112131415Example 1:Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, which the length is 3.Example 2:Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1.Example 3:Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; if (s.empty()) return 0; unordered_map&lt;char, int&gt; m; int index = -1, n = s.size(), ret = 0; for (int i = 0; i &lt; n; i++) &#123; auto c = s[i]; if (m.find(c) != m.end() &amp;&amp; m[c] &gt; index) index = m[c]; ret = max(ret, i - index); m[c] = i; &#125; return ret; &#125;&#125;; 连续子数组的最大值 牛客网 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 12345678910111213class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; int ans = 0, n = array.size(); int ret = INT_MIN; for (int i = 0; i &lt; n; i++) &#123; ans += array[i]; ret = max(ret, ans); if (ans &lt;= 0) ans = 0; &#125; return ret; &#125;&#125;; 整数中1出现的次数（从1到n整数中1出现的次数） 牛客网因为此题细节较多，为了多加练习，在此处也做整理 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 1234567891011121314151617181920class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; string s = to_string(n); int len = s.size(), ret = 0; for (int i = 0; i &lt; len; i++) &#123; int c = s[len - 1 - i] - '0'; if (c == 0) &#123; ret += n / (int)pow(10, i + 1) * pow(10, i); &#125; else if (c == 1) &#123; ret += n / (int)pow(10, i + 1) * pow(10, i) + (n % (int)pow(10, i)) + 1; &#125; else &#123; ret += (n / (int)pow(10, i + 1) + 1) * pow(10, i); &#125; &#125; return ret; &#125;&#125;; 双指针Minimum Size Subarray Sum Leetcode 209 Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.12345Example: Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up:If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). 1234567891011121314class Solution &#123;public: // 因为是正整数，和一直是递增的，所以使用双指针就可以了 int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int ans = 0, i = 0, j = 0, n = nums.size(); int ret = INT_MAX; while (j &lt; n) &#123; ans += nums[j++]; while (i &lt; j &amp;&amp; ans - nums[i] &gt;= s) ans -= nums[i++]; if (ans &gt;= s) ret = min(ret, j - i); &#125; return ret == INT_MAX ? 0 : ret; &#125;&#125;; 3Sum Leetcode 15 Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets.123456789Example:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int n = nums.size(); if (n &lt; 3) return ret; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; n - 2; i++) &#123; if (i == 0 || nums[i] != nums[i - 1]) &#123; int j = i + 1, k = n - 1; while (j &lt; k) &#123; int ans = nums[i] + nums[j] + nums[k]; if (!ans) &#123; ret.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[k]&#125;); while (j &lt; k &amp;&amp; nums[j + 1] == nums[j]) j++; while (j &lt; k &amp;&amp; nums[k - 1] == nums[k]) k--; j ++, k --; &#125; else if (ans &gt; 0) k --; else j ++; &#125; &#125; &#125; return ret; &#125;&#125;; 3Sum Closest Leetcode 16 Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.123Example:Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 123456789101112131415161718192021// 3Sum的扩展版本class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if (n &lt; 3) return -1; sort(nums.begin(), nums.end()); int ret = nums[0] + nums[1] + nums[2]; for (int i = 0; i &lt; n - 2; i++) &#123; int j = i + 1, k = n - 1; while (j &lt; k) &#123; int ans = nums[i] + nums[j] + nums[k]; if (ans == target) return target; if (abs(ans - target) &lt; abs(ret - target)) ret = ans; if (ans &gt; target) k--; else j ++; &#125; &#125; return ret; &#125;&#125;; 丑数 牛客网 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 12345678910111213141516class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if (index &lt; 1) return 0; vector&lt;int&gt; ret(index, 0); int c2 = 0, c3 = 0, c5 = 0; ret[0] = 1; for (int i = 1; i &lt; index; i++) &#123; ret[i] = min(ret[c2] * 2, min(ret[c3] * 3, ret[c5] * 5)); if (ret[c2] * 2 == ret[i]) c2 ++; if (ret[c3] * 3 == ret[i]) c3 ++; if (ret[c5] * 5 == ret[i]) c5 ++; &#125; return ret[index - 1]; &#125;&#125;; Super Ugly Number Leetcode 313 Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k.123456Example:Input: n = 12, primes = [2,7,13,19]Output: 32 Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19] of size 4. 12345678910111213141516class Solution &#123;public: int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123; int len = primes.size(); vector&lt;int&gt; cnt(len + 1, 0); vector&lt;int&gt; ret(n, INT_MAX); ret[0] = 1; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; len; j++) ret[i] = min(ret[i], primes[j] * ret[cnt[j]]); for (int j = 0; j &lt; len; j++) &#123; if (ret[i] == primes[j] * ret[cnt[j]]) cnt[j] ++; &#125; &#125; return ret[n - 1]; &#125;&#125;; Remove Duplicates from Sorted Array II Leetcode 80 Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.123456789Example 1:Given nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.It doesn&apos;t matter what you leave beyond the returned length.Example 2:Given nums = [0,0,1,1,1,1,2,3,3],Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this:12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 12345678910class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int index = 0, n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; if (index &lt; 2 || nums[index - 2] != nums[i]) nums[index ++] = nums[i]; &#125; return index; &#125;&#125;; Trapping Rain Water Leetcode 42 Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! 123Example:Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 12345678910111213class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int ret = 0, n = height.size(); int level = 0, l = 0, r = n - 1; while (l &lt; r) &#123; int lower = height[height[l] &lt; height[r] ? l ++ : r --]; level = max(level, lower); ret += level - lower; &#125; return ret; &#125;&#125;; 构建乘积数组 牛客网 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123; int len = A.size(); vector&lt;int&gt; B(len, 1); for (int i = 1; i &lt; len; i++) &#123; B[i] = A[i - 1] * B[i - 1]; &#125; int ans = 1; for (int i = len - 1; i&gt;= 0; i--) &#123; B[i] *= ans; ans *= A[i]; &#125; return B; &#125;&#125;; 队列队列通常的应用一般包括单调队列等，这里只列出一部分单调队列题目，之后不断补充… Shortest Subarray with Sum at Least K Leetcode 862 Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1. 123456789101112131415161718Example 1:Input: A = [1], K = 1Output: 1Example 2:Input: A = [1,2], K = 4Output: -1Example 3:Input: A = [2,-1,2], K = 3Output: 3 Note:1 &lt;= A.length &lt;= 50000-10 ^ 5 &lt;= A[i] &lt;= 10 ^ 51 &lt;= K &lt;= 10 ^ 9 1234567891011121314151617181920212223class Solution &#123;public: int shortestSubarray(vector&lt;int&gt;&amp; A, int K) &#123; // 此算法是利用了双指针的思路，不过需要维护一个单调队列 // 才能需要保证更新长度过程中是满足条件的，否则有升有降只能使用平方级的时间复杂度 int n = A.size(), ret = n + 1; vector&lt;int&gt; B(n + 1, 0); for (int i = 0; i &lt; n; i++) &#123; B[i + 1] = B[i] + A[i]; &#125; deque&lt;int&gt; d; for (int i = 0; i &lt;= n; i++) &#123; // 因为是有序的，所以此处还可以使用二分查找 while (!d.empty() &amp;&amp; B[i] - B[d.front()] &gt;= K) &#123; ret = min(ret, i - d.front()); d.pop_front(); &#125; while (!d.empty() &amp;&amp; B[d.back()] &gt;= B[i]) d.pop_back(); d.push_back(i); &#125; return ret == n + 1 ? -1 : ret; &#125;&#125;; Sliding Window Maximum Leetcode 239 Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. 1234567891011121314Example:Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note:You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array. Follow up:Could you solve it in linear time? 123456789101112131415class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;int&gt; ret; deque&lt;int&gt; d; for (int i = 0; i &lt; n; i++) &#123; while (!d.empty() &amp;&amp; nums[i] &gt; nums[d.back()]) d.pop_back(); d.push_back(i); if (i &gt;= k - 1) ret.push_back(nums[d.front()]); if (d.front() &lt;= i - k + 1) d.pop_front(); &#125; return ret; &#125;&#125;; 链表LRU Cache（双端链表list） Leetcode 146 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up:Could you do both operations in O(1) time complexity?12345678910111213Example:LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 list是stl的双端链表，链表指针可以用O(1)时间删除，但是随机访问时间慢 1234567891011121314151617181920212223242526272829303132typedef list&lt;int&gt;::iterator Iter;class LRUCache &#123;public: int cap; unordered_map&lt;int, pair&lt;Iter, int&gt;&gt; m; list&lt;int&gt; d; LRUCache(int capacity) &#123; cap = capacity; &#125; void helper(int key) &#123; d.erase(m[key].first); m.erase(key); &#125; int get(int key) &#123; if (m.find(key) == m.end()) return -1; int val = m[key].second; helper(key); d.push_front(key); m[key] = &#123;d.begin(), val&#125;; return val; &#125; void put(int key, int value) &#123; if (m.find(key) != m.end()) helper(key); else if (m.size() == cap) helper(d.back()); d.push_front(key); m[key] = &#123;d.begin(), value&#125;; &#125;&#125;; Insertion Sort List Leetcode 147 Sort a linked list using insertion sort. Algorithm of Insertion Sort: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.It repeats until no input elements remain.1234567Example 1:Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4Example 2:Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void helper(ListNode* &amp;ret, ListNode* head) &#123; while (head) &#123; ListNode* temp = head; head = head-&gt;next; temp-&gt;next = NULL; ListNode* cur = ret; while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val &lt; temp-&gt;val) &#123; cur = cur-&gt;next; &#125; temp-&gt;next = cur-&gt;next; cur-&gt;next = temp; &#125; &#125; ListNode* insertionSortList(ListNode* head) &#123; if (!head) return NULL; ListNode* ret = new ListNode(-1); helper(ret, head); return ret-&gt;next; &#125;&#125;; Sort List Leetcode 148 Sort a linked list in O(n log n) time using constant space complexity.1234567Example 1:Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4Example 2:Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */// 归并排序class Solution &#123;public: ListNode* merge(ListNode* l, ListNode* r) &#123; auto ret = new ListNode(-1); auto cur = ret; while (l &amp;&amp; r) &#123; if (l-&gt;val &lt; r-&gt;val) &#123; cur-&gt;next = l; cur = cur-&gt;next; l = l-&gt;next; &#125; else &#123; cur-&gt;next = r; cur = cur-&gt;next; r = r-&gt;next; &#125; &#125; while (l) cur-&gt;next = l, cur = cur-&gt;next, l = l-&gt;next; while (r) cur-&gt;next = r, cur = cur-&gt;next, r = r-&gt;next; cur-&gt;next = NULL; return ret-&gt;next; &#125; ListNode* sortList(ListNode* head) &#123; if (!head || !head-&gt;next) return head; auto fast = head, slow = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; auto mid = slow-&gt;next; slow-&gt;next = NULL; auto l = sortList(head); auto r = sortList(mid); return merge(l, r); &#125;&#125;; 123456789101112131415161718192021222324252627282930313233343536// 快排版本class Solution &#123;public: ListNode* partition(ListNode* start, ListNode* end) &#123; ListNode* base = start; start = start-&gt;next; ListNode* l = new ListNode(-1); ListNode* curl = l; ListNode* r = new ListNode(-1); ListNode* curr = r; while (start != end) &#123; if (base-&gt;val &gt; start-&gt;val) curl-&gt;next = start, curl = curl-&gt;next; else curr-&gt;next = start, curr = curr-&gt;next; start = start-&gt;next; &#125; curr-&gt;next = end; curl-&gt;next = base; base-&gt;next = r-&gt;next; return l-&gt;next; &#125; ListNode* helper(ListNode* start, ListNode* end) &#123; if (start == end) return start; auto mid = start; start = partition(start, end); auto l = helper(start, mid); auto r = helper(mid-&gt;next, end); mid-&gt;next = r; return l; &#125; ListNode* sortList(ListNode* head) &#123; if (!head) return head; return helper(head, NULL); &#125;&#125;; Remove Duplicates from Sorted List II Leetcode 82 Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.1234567Example 1:Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5Example 2:Input: 1-&gt;1-&gt;1-&gt;2-&gt;3Output: 2-&gt;3 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (!head || !head-&gt;next) return head; int val = head-&gt;val; ListNode* cur = head-&gt;next; if (cur-&gt;val != val) &#123; head-&gt;next = deleteDuplicates(cur); return head; &#125; while (cur &amp;&amp; cur-&gt;val == val) cur = cur-&gt;next; return deleteDuplicates(cur); &#125;&#125;; Reorder List Leetcode 143 Given a singly linked list L: L0→L1→…→Ln-1→Ln,reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list’s nodes, only nodes itself may be changed.12345Example 1:Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.Example 2:Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode* head) &#123; if (!head || !head-&gt;next) return; ListNode* fast = head, *slow = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; auto mid = slow-&gt;next; slow-&gt;next = NULL; ListNode* cur = NULL; while (mid) &#123; ListNode* temp = mid-&gt;next; mid-&gt;next = cur; cur = mid; mid = temp; &#125; mid = cur; cur = head; while (mid) &#123; ListNode* temp = cur-&gt;next; cur-&gt;next = mid; mid = mid-&gt;next; cur-&gt;next-&gt;next = temp; cur = temp; &#125; &#125;&#125;; Reverse Linked List II Leetcode 92 Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list.123Example:Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (m == n) return head; ListNode* ret = new ListNode(-1); ret-&gt;next = head; auto cur = ret; // 因为从1开始数，所以m-1 for (int i = 0; i &lt; m - 1; i++) cur = cur-&gt;next; auto start = cur-&gt;next; for (int i = 0; i &lt; n - m; i++) &#123; auto temp = start-&gt;next; start-&gt;next = temp-&gt;next; temp-&gt;next = cur-&gt;next; cur-&gt;next = temp; &#125; return ret-&gt;next; &#125;&#125;; 栈132 Pattern Leetcode 456 Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. Note: n will be less than 15,000.1234567891011121314Example 1:Input: [1, 2, 3, 4]Output: FalseExplanation: There is no 132 pattern in the sequence.Example 2:Input: [3, 1, 4, 2]Output: TrueExplanation: There is a 132 pattern in the sequence: [1, 4, 2].Example 3:Input: [-1, 3, 2, 0]Output: TrueExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. 12345678910111213141516171819class Solution &#123;public: bool find132pattern(vector&lt;int&gt;&amp; nums) &#123; stack&lt;pair&lt;int, int&gt;&gt; s; for (auto i : nums) &#123; if (s.empty() || s.top().second &gt; i) &#123; s.push(make_pair(i, i)); &#125; else if (s.top().second &lt; i) &#123; int m = s.top().second; if (s.top().first &gt; i) return true; while (!s.empty() &amp;&amp; s.top().first &lt;= i) s.pop(); if (!s.empty() &amp;&amp; s.top().second &lt; i) return true; s.push(&#123;i, m&#125;); &#125; &#125; return false; &#125;&#125;; Next Greater Element II Leetcode 503 Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number. 1234567Example 1:Input: [1,2,1]Output: [2,-1,2]Explanation: The first 1&apos;s next greater number is 2; The number 2 can&apos;t find next greater number; The second 1&apos;s next greater number needs to search circularly, which is also 2.Note: The length of given array won&apos;t exceed 10000. 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return vector&lt;int&gt;(); int len = nums.size(); stack&lt;int&gt; s; vector&lt;int&gt; ret(len, -1); for (int i = 0; i &lt; len * 2; i++) &#123; while (!s.empty() &amp;&amp; nums[s.top()] &lt; nums[i % len]) &#123; ret[s.top()] = nums[i % len]; s.pop(); &#125; if (i &lt; len) s.push(i); &#125; return ret; &#125;&#125;; Binary Search Tree Iterator Leetcode 173 Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123;public: stack&lt;TreeNode*&gt; s; void helper(TreeNode* cur) &#123; while (cur) &#123; s.push(cur); cur = cur-&gt;left; &#125; &#125; BSTIterator(TreeNode *root) &#123; helper(root); &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !s.empty(); &#125; /** @return the next smallest number */ int next() &#123; auto cur = s.top(); s.pop(); helper(cur-&gt;right); return cur-&gt;val; &#125;&#125;;/** * Your BSTIterator will be called like this: * BSTIterator i = BSTIterator(root); * while (i.hasNext()) cout &lt;&lt; i.next(); */ Verify Preorder Serialization of a Binary Tree Leetcode 331 One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #.1234567 _9_ / \ 3 2 / \ / \ 4 1 # 6/ \ / \ / \# # # # # # For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”. 1234567891011Example 1:Input: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;Output: trueExample 2:Input: &quot;1,#&quot;Output: falseExample 3:Input: &quot;9,#,#,1&quot;Output: false 1234567891011121314151617181920212223242526class Solution &#123;public: bool isValidSerialization(string preorder) &#123; if (preorder.empty()) return false; vector&lt;string&gt; s; string ans; for (auto c : preorder) &#123; if (c == ',') &#123; s.push_back(ans); ans = ""; &#125; else ans.push_back(c); &#125; s.push_back(ans); int d = 0; for (int i = 0; i &lt; s.size() - 1; i++) &#123; string temp = s[i]; if (temp == "#") &#123; if (!d) return false; else d--; &#125; else d++; &#125; return !d &amp;&amp; s.back() == "#"; &#125;&#125;; HashTable 哈希表通常用来记录一些中间状态从而实现O(1)，这里提供一些比较典型的例子，之后不断补充… Max Points on a Line Leetcode 149 Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.12345678910111213141516171819202122232425Example 1:Input: [[1,1],[2,2],[3,3]]Output: 3Explanation:^|| o| o| o +-------------&gt;0 1 2 3 4Example 2:Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]Output: 4Explanation:^|| o| o o| o| o o+-------------------&gt;0 1 2 3 4 5 6 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a point. * struct Point &#123; * int x; * int y; * Point() : x(0), y(0) &#123;&#125; * Point(int a, int b) : x(a), y(b) &#123;&#125; * &#125;; */class Solution &#123;public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; int ret = 0; int len = points.size(); if (len &lt; 3) return len; for (int i = 0; i &lt; len; i++) &#123; map&lt;pair&lt;int, int&gt;, int&gt; m; int vertical = 0, overlap = 0, local_ret = 0; for (int j = i + 1; j &lt; len; j++) &#123; int a = points[i].x - points[j].x; int b = points[i].y - points[j].y; if (!a &amp;&amp; !b) overlap ++; else if (!a) vertical ++; else &#123; int k = GCD(a, b); auto ans = make_pair(a / k, b / k); m[ans] ++; local_ret = max(local_ret, m[ans]); &#125; local_ret = max(local_ret, vertical); &#125; ret = max(ret, local_ret + overlap + 1); &#125; return ret; &#125; int GCD(int a, int b) &#123; if (!b) return a; else return GCD(b, a % b); &#125;&#125;; 桶Contains Duplicate III Leetcode 220 Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. 1234567891011Example 1:Input: nums = [1,2,3,1], k = 3, t = 0Output: trueExample 2:Input: nums = [1,0,1,1], k = 1, t = 2Output: trueExample 3:Input: nums = [1,5,9,1,5,9], k = 2, t = 3Output: false 123456789101112131415161718192021222324class Solution &#123;public: long long helper(long long num, long long w) &#123; return num &gt;= 0 ? num / w : ((num + 1) / w - 1); &#125; bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; if (t &lt; 0) return false; int n = nums.size(); long long w = t + 1; unordered_map&lt;long long, int&gt; m; for (int i = 0; i &lt; n; i++) &#123; long long ID = helper(nums[i], w); if (m.find(ID) != m.end()) return true; // 要注意不能用t比较大小否则int会溢出 if (m.find(ID - 1) != m.end() &amp;&amp; abs(nums[i] - nums[m[ID - 1]]) &lt; w) return true; if (m.find(ID + 1) != m.end() &amp;&amp; abs(nums[i] - nums[m[ID + 1]]) &lt; w) return true; m[ID] = i; if (i &gt;= k) &#123; m.erase(helper(nums[i - k], w)); &#125; &#125; return false; &#125;&#125;; 树最近公共祖先1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;struct TreeNode &#123; int val; TreeNode* left; TreeNode* right; TreeNode(int x): val(x), left(NULL), right(NULL) &#123;&#125;&#125;;TreeNode* build() &#123; int x; cin &gt;&gt; x; if (x == -1) return NULL; TreeNode* ret = new TreeNode(x); ret-&gt;left = build(); ret-&gt;right = build(); return ret;&#125;int helper(TreeNode* root, int&amp; x, int&amp; y) &#123; if (!root) return -1; if (root-&gt;val == x) &#123; x = INT_MIN; helper(root-&gt;left, x, y); helper(root-&gt;right, x, y); if (y == INT_MIN) return root-&gt;val; &#125; else if (root-&gt;val == y) &#123; y = INT_MIN; helper(root-&gt;left, x, y); helper(root-&gt;right, x, y); if (x == INT_MIN) return root-&gt;val; &#125; else &#123; int ans = 0; int l = helper(root-&gt;left, x, y); ans = (x == INT_MIN) + (y == INT_MIN); if ((x == INT_MIN) &amp;&amp; (y == INT_MIN)) return l; int r = helper(root-&gt;right, x, y); if ((x == INT_MIN) &amp;&amp; (y == INT_MIN)) &#123; if (ans) return root-&gt;val; else return r; &#125; &#125; return -1;&#125;int main() &#123; TreeNode* root = build(); cout &lt;&lt; "Tree Finish" &lt;&lt; endl; while (true) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; helper(root, x, y) &lt;&lt; endl; &#125; return 0;&#125; 指定节点距离叶子节点最近的距离此题是之前面试中一道题，题目意思是如果指定一个值（若存在则唯一存在），寻找距离此节点最近叶子节点的距离，因为此题的细节比较多，所以这里也列出来 例如：按前序遍历的树 1,2,3,4,5,#,#,#,6,7,#,#,8,9,#,10,#,#,11,#,#,#,12,#,# 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;struct TreeNode &#123; int val; TreeNode* left, *right; TreeNode(int x): val(x), left(NULL), right(NULL) &#123;&#125;;&#125;;TreeNode* build(int&amp; index, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (index == n) return NULL; int val = nums[index++]; if (val == -1) return NULL; TreeNode* ret = new TreeNode(val); ret-&gt;left = build(index, nums); ret-&gt;right = build(index, nums); return ret;&#125;void helper(int&amp; ret, int&amp; l, int&amp; r, int&amp; m, int target, TreeNode* root) &#123; l = r = m = 0; if (!root) return; int val = root-&gt;val; if (val == target) &#123; m = 1; &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; if (m) ret = 0; return; &#125; int ll, lr, rl, rr, ml, mr; helper(ret, ll, lr, ml, target, root-&gt;left); helper(ret, rl, rr, mr, target, root-&gt;right); if (m) &#123; if (!root-&gt;left) ret = min(ret, min(rl, rr) + 1); if (!root-&gt;right) ret = min(ret, min(ll, lr) + 1); if (root-&gt;left &amp;&amp; root-&gt;right) &#123; int ans = min(min(ll, lr) + 1, min(rl, rr) + 1); ret = min(ret, ans); &#125; return; &#125; if (ml) &#123; if (root-&gt;right) &#123; ret = min(ret, min(rl, rr) + ll + 2); //cout &lt;&lt; "ml " &lt;&lt; ret&lt;&lt; endl; &#125; l = r = ll + 1; m = 1; return; &#125; else if (mr) &#123; if (root-&gt;left) &#123; ret = min(ret, min(ll, lr) + rr + 2); //cout &lt;&lt; "mr " &lt;&lt; ret&lt;&lt; endl; &#125; l = r = rr + 1; m = 1; return; &#125; else &#123; l = !root-&gt;left ? INT_MAX : min(ll, lr) + 1; r = !root-&gt;right ? INT_MAX : min(rr, rl) + 1; //cout &lt;&lt; "mid: " &lt;&lt; val &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; int index = 0; TreeNode* root = build(index, nums); for (int i = 0; i &lt; 12; i++) &#123; int ret = INT_MAX; int m = 0, l, r; helper(ret, l, r, m, i + 1, root); cout &lt;&lt; i + 1 &lt;&lt; " "; if (m) cout &lt;&lt; ret &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; return 0;&#125;/*251 2 3 4 5 -1 -1 -1 6 7 -1 -1 8 9 -1 10 -1 -1 11 -1 -1 -1 12 -1 -11 12 23 24 15 46 17 38 19 110 311 312 3*//*251 2 3 4 5 -1 -1 -1 6 7 -1 -1 8 9 -1 10 -1 -1 11 -1 -1 -1 12 -1 -1*/ Populating Next Right Pointers in Each Node II Leetcode 117 Given a binary tree12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. 1234567891011121314151617181920Note:You may only use constant extra space.Recursive approach is fine, implicit stack space does not count as extra space for this problem.Example:Given the following binary tree, 1 / \ 2 3 / \ \4 5 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \4-&gt; 5 -&gt; 7 -&gt; NULL 1234567891011121314151617181920212223242526272829303132333435/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) return; TreeLinkNode* pre = root; pre-&gt;next = NULL; while (pre) &#123; while (pre &amp;&amp; !pre-&gt;left &amp;&amp; !pre-&gt;right) pre = pre-&gt;next; if (!pre) continue; TreeLinkNode* head = pre-&gt;left ? pre-&gt;left : pre-&gt;right; TreeLinkNode* cur = head; while (pre) &#123; if (pre-&gt;left) &#123; cur-&gt;next = pre-&gt;left; cur = cur-&gt;next; &#125; if (pre-&gt;right) &#123; cur-&gt;next = pre-&gt;right; cur = cur-&gt;next; &#125; pre = pre-&gt;next; &#125; cur-&gt;next = NULL; pre = head; &#125; &#125;&#125;; Count Complete Tree Nodes Leetcode 222 Given a complete binary tree, count the number of nodes. Note: Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.12345678910Example:Input: 1 / \ 2 3 / \ /4 5 6Output: 6 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; // 本题的重点是不能遍历所有， // 所以如果是完全树，则直接返回该树的节点数， // 如果不是，则返回左子树加右子树加自己的节点数 if (!root) return 0; int h1 = 0, h2 = 0; TreeNode* l = root, *r = root; while (l) &#123; h1 ++; l = l-&gt;left; &#125; while (r) &#123; h2 ++; r = r-&gt;right; &#125; if (h1 == h2) return pow(2, h1) - 1; return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125;&#125;; Delete Node in a BST Leetcode 450 Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove.If the node is found, delete the node.Note: Time complexity should be O(height of tree).12345678910111213141516171819202122232425262728Example:root = [5,3,6,2,4,null,7]key = 3 5 / \ 3 6 / \ \2 4 7Given key to delete is 3. So we find the node with value 3 and delete it.One valid answer is [5,4,6,2,null,null,7], shown in the following BST. 5 / \ 4 6 / \2 7Another valid answer is [5,2,6,null,4,null,7]. 5 / \ 2 6 \ \ 4 7 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* deleteNode(TreeNode* root, int key) &#123; if (!root) return NULL; if (root-&gt;val == key) &#123; if (!root-&gt;left) return root-&gt;right; if (!root-&gt;right) return root-&gt;left; TreeNode* cur = root-&gt;right; while (cur-&gt;left) cur = cur-&gt;left; swap(root-&gt;val, cur-&gt;val); &#125; root-&gt;left = deleteNode(root-&gt;left, key); root-&gt;right = deleteNode(root-&gt;right, key); return root; &#125;&#125;; Serialize and Deserialize BST Leetcode 449 Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Codec &#123;public: void helper(TreeNode* root, string&amp; ret) &#123; if (!root) ret += ",#"; else &#123; ret += "," + to_string(root-&gt;val); helper(root-&gt;left, ret); helper(root-&gt;right, ret); &#125; &#125; // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string ret; helper(root, ret); return ret.substr(1); &#125; TreeNode* helper1(string&amp; data, int&amp; index) &#123; string ans; while (index &lt; data.size() &amp;&amp; data[index] != ',') &#123; ans.push_back(data[index++]); &#125; if (index &lt; data.size()) index ++; if (ans == "#") return NULL; int syn = 1; if (ans[0] == '-') &#123; ans.erase(ans.begin()); syn = -1; &#125; int val = 0; for (auto i : ans) &#123; val = val * 10 + (i - '0'); &#125; val *= syn; TreeNode* ret = new TreeNode(val); ret-&gt;left = helper1(data, index); ret-&gt;right = helper1(data, index); return ret; &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; int index = 0; return helper1(data, index); &#125;&#125;;// Your Codec object will be instantiated and called as such:// Codec codec;// codec.deserialize(codec.serialize(root)); 前缀树Implement Trie (Prefix Tree) Leetcode 208 Implement a trie with insert, search, and startsWith methods. 12345678910Example:Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // returns truetrie.search(&quot;app&quot;); // returns falsetrie.startsWith(&quot;app&quot;); // returns truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // returns true 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct TrieNode &#123; TrieNode* child[26]; bool isKey; TrieNode() : isKey(false) &#123; memset(child, NULL, sizeof(child)); &#125;&#125;;class Trie &#123;public: TrieNode* root; /** Initialize your data structure here. */ Trie() &#123; root = new TrieNode(); &#125; /** Inserts a word into the trie. */ void insert(string word) &#123; TrieNode* cur = root; for (auto i : word) &#123; int c = i - 'a'; if (!cur-&gt;child[c]) cur-&gt;child[c] = new TrieNode(); cur = cur-&gt;child[c]; &#125; cur-&gt;isKey = true; &#125; /** Returns if the word is in the trie. */ bool search(string word) &#123; TrieNode* cur = root; for (auto i : word) &#123; int c = i - 'a'; if (!cur-&gt;child[c]) return false; cur = cur-&gt;child[c]; &#125; return cur-&gt;isKey; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) &#123; TrieNode* cur = root; for (auto i : prefix) &#123; int c = i - 'a'; if (!cur-&gt;child[c]) return false; cur = cur-&gt;child[c]; &#125; return true; &#125;&#125;;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * bool param_2 = obj.search(word); * bool param_3 = obj.startsWith(prefix); */ Maximum XOR of Two Numbers in an Array Leetcode 421 Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai &lt; 231. Find the maximum result of ai XOR aj, where 0 ≤ i, j &lt; n. Could you do this in O(n) runtime? 1234567Example:Input: [3, 10, 5, 25, 2, 8]Output: 28Explanation: The maximum result is 5 ^ 25 = 28. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct TrieNode &#123; TrieNode* child[2]; TrieNode() &#123; memset(child, NULL, sizeof(child)); &#125;&#125;;class Solution &#123;public: int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123; TrieNode* root = new TrieNode(); for (auto n : nums) &#123; TrieNode* cur = root; // 必须是从左往右，因为不是这样的话就不是最大，这里用了贪心 for (int i = 31; i &gt;= 0; i--) &#123; int c = ((n &gt;&gt; i) &amp; 1); if (!cur-&gt;child[c]) cur-&gt;child[c] = new TrieNode(); cur = cur-&gt;child[c]; &#125; &#125; int ret = 0; for (auto n : nums) &#123; TrieNode* cur = root; int ans = 0; for (int i = 31; i &gt;= 0; i--) &#123; int c = ((n &gt;&gt; i) &amp; 1); if (cur-&gt;child[!c]) &#123; ans &lt;&lt;= 1; ans |= 1; cur = cur-&gt;child[!c]; &#125; // 只要有一条路肯定能走到底，所以不用判断为空的情况 else &#123; ans &lt;&lt;= 1; cur = cur-&gt;child[c]; &#125; &#125; for (int i = 0; i &lt; 32; i++) &#123; cout &lt;&lt; ((2147483648 &gt;&gt; i) &amp; 1); &#125; cout &lt;&lt; endl; ret = max(ret, ans); &#125; return ret; &#125;&#125;; Word Search II Leetcode 212 Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. 123456789101112Example:Input: words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]Output: [&quot;eat&quot;,&quot;oath&quot;] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354struct TrieNode &#123; TrieNode* child[26]; bool isKey; TrieNode() : isKey(false) &#123; memset(child, NULL, sizeof(child)); &#125;&#125;;class Solution &#123;public: void helper(TrieNode* root, vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, string ans, unordered_set&lt;string&gt;&amp; ret) &#123; ans = ans + board[x][y]; if (root-&gt;isKey) &#123; ret.insert(ans); &#125; board[x][y] = '\0'; int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; int m = board.size(), n = board[0].size(); for (int i = 0; i &lt; 4; i++) &#123; int X = x + a[i], Y = y + b[i]; if (X &gt;= 0 &amp;&amp; X &lt; m &amp;&amp; Y &gt;= 0 &amp;&amp; Y &lt; n &amp;&amp; board[X][Y] != '\0') &#123; int c = board[X][Y] - 'a'; if (root-&gt;child[c]) &#123; helper(root-&gt;child[c], board, X, Y, ans, ret); &#125; &#125; &#125; board[x][y] = ans.back(); &#125; vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123; if (board.empty() || board[0].empty()) return vector&lt;string&gt;(); TrieNode* root = new TrieNode(); for (auto s : words) &#123; auto cur = root; for (auto i : s) &#123; int c = i - 'a'; if (!cur-&gt;child[c]) cur-&gt;child[c] = new TrieNode(); cur = cur-&gt;child[c]; &#125; cur-&gt;isKey = true; &#125; unordered_set&lt;string&gt; ret_set; for (int i = 0; i &lt; board.size(); i++) &#123; for (int j = 0; j &lt; board[0].size(); j++) &#123; int c = board[i][j] - 'a'; if (root-&gt;child[c]) helper(root-&gt;child[c], board, i, j, "", ret_set); &#125; &#125; vector&lt;string&gt; ret; for (auto s : ret_set) &#123; ret.push_back(s); &#125; return ret; &#125;&#125;; 堆TopKKth Largest Element in an Array Leetcode 215 Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.1234567Example 1:Input: [3,2,1,5,6,4] and k = 2Output: 5Example 2:Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: void heapfy(vector&lt;int&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; nums[left] &lt; nums[smallest]) smallest = left; if (right &lt; max &amp;&amp; nums[right] &lt; nums[smallest]) smallest = right; if (index != smallest) &#123; swap(nums[index], nums[smallest]); heapfy(nums, smallest, max); &#125; &#125; int helper(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); if (n &lt; k) return -1; vector&lt;int&gt; ans; for (int i = 0; i &lt; k; i++) ans.push_back(nums[i]); for (int i = k / 2; i &gt;= 0; i--) heapfy(ans, i, k); for (int i = k; i &lt; n; i++) &#123; if (nums[i] &gt; ans[0]) &#123; ans[0] = nums[i]; heapfy(ans, 0, k); &#125; &#125; return ans[0]; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; return helper(nums, k); &#125;&#125;; Top K Frequent Elements Leetcode 347 Given a non-empty array of integers, return the k most frequent elements.1234567Example 1:Input: nums = [1,1,1,2,2,3], k = 2Output: [1,2]Example 2:Input: nums = [1], k = 1Output: [1] 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: void heapfy(vector&lt;int&gt;&amp; nums, int index, int max, unordered_map&lt;int, int&gt;&amp; m) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; m[nums[left]] &lt; m[nums[smallest]]) smallest = left; if (right &lt; max &amp;&amp; m[nums[right]] &lt; m[nums[smallest]]) smallest = right; if (smallest != index) &#123; swap(nums[smallest], nums[index]); heapfy(nums, smallest, max, m); &#125; &#125; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; m; vector&lt;int&gt; ans; for (auto i : nums) &#123; m[i] ++; if (m[i] == 1) ans.push_back(i); &#125; int len = ans.size(); if (len &lt; k) return ans; vector&lt;int&gt; ret; for (int i = 0; i &lt; k; i++) ret.push_back(ans[i]); for (int i = k / 2 - 1; i &gt;= 0; i--) heapfy(ret, i, k, m); for (int i = k; i &lt; len; i++) &#123; if (m[ans[i]] &gt; m[ret[0]]) &#123; ret[0] = ans[i]; for (int j = k / 2 - 1; j &gt;= 0; j--) heapfy(ret, j, k, m); &#125; &#125; return ret; &#125;&#125;; Find K Pairs with Smallest Sums Leetcode 373 You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums.1234567891011121314151617Example 1:Given nums1 = [1,7,11], nums2 = [2,4,6], k = 3Return: [1,2],[1,4],[1,6]The first 3 pairs are returned from the sequence:[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]Example 2:Given nums1 = [1,1,2], nums2 = [1,2,3], k = 2Return: [1,1],[1,1]The first 2 pairs are returned from the sequence:[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]Example 3:Given nums1 = [1,2], nums2 = [3], k = 3 Return: [1,3],[2,3]All possible pairs are returned from the sequence:[1,3],[2,3] 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: void heapfy(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; A[nums[left].first] + B[nums[left].second] &lt; A[nums[smallest].first] + B[nums[smallest].second]) smallest = left; if (right &lt; max &amp;&amp; A[nums[right].first] + B[nums[right].second] &lt; A[nums[smallest].first] + B[nums[smallest].second]) smallest = right; if (index != smallest) &#123; swap(nums[index], nums[smallest]); heapfy(nums, A, B, smallest, max); &#125; &#125; vector&lt;pair&lt;int, int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; if (nums1.empty() || nums2.empty()) return vector&lt;pair&lt;int, int&gt;&gt;(); vector&lt;pair&lt;int, int&gt;&gt; ret; vector&lt;pair&lt;int, int&gt;&gt; ans; ans.push_back(make_pair(0, 0)); for (int i = 0; i &lt; k &amp;&amp; !ans.empty(); i++) &#123; auto t = ans[0]; ans.erase(ans.begin()); ret.push_back(make_pair(nums1[t.first], nums2[t.second])); if (t.first == 0 &amp;&amp; t.second + 1 &lt; nums2.size()) ans.push_back(make_pair(0, t.second + 1)); if (t.first + 1 &lt; nums1.size()) ans.push_back(make_pair(t.first + 1, t.second)); int len = ans.size(); for (int j = len / 2; j &gt;= 0; j--) heapfy(ans, nums1, nums2, j, len); &#125; return ret; &#125;&#125;; Find Median from Data Stream Leetcode 295 Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example,[2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure.double findMedian() - Return the median of all elements so far. 1234567Example:addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2 12345678910111213141516171819202122232425262728293031class MedianFinder &#123;public: /** initialize your data structure here. */ priority_queue&lt;int&gt; small; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; large; MedianFinder() &#123; &#125; void addNum(int num) &#123; small.push(num); large.push(small.top()); small.pop(); if (small.size() &lt; large.size()) &#123; small.push(large.top()); large.pop(); &#125; &#125; double findMedian() &#123; if (large.size() == small.size()) return (large.top() + small.top()) / 2.0; return small.top(); &#125;&#125;;/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */ Sliding Window Median Leetcode 480 Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. 12345678910111213141516171819Examples: [2,3,4] , the median is 3[2,3], the median is (2 + 3) / 2 = 2.5Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.For example,Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.Window position Median--------------- -----[1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6Therefore, return the median sliding window as [1,-1,-1,3,5,6]. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123;public: vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); if (len &lt; k) return vector&lt;double&gt;(); vector&lt;double&gt; ret; unordered_map&lt;int, int&gt; m; priority_queue&lt;int&gt; small; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; large; for (int i = 0; i &lt; k; i++) &#123; small.push(nums[i]); &#125; for (int i = 0; i &lt; k / 2; i++) &#123; large.push(small.top()); small.pop(); &#125; for (int i = k; i &lt;= len; i++) &#123; if (k &amp; 1) ret.push_back(small.top()); // 这里要用double，否则可能会溢出 else ret.push_back(((double)small.top() + (double)large.top()) / 2.0); if (i == len) continue; int blance = 0; int ans = nums[i]; if (ans &gt; small.top()) &#123; large.push(ans); blance ++; &#125; else &#123; small.push(ans); blance --; &#125; ans = nums[i - k]; if (ans &gt; small.top()) &#123; if (large.top() == ans) large.pop(); else m[ans]++; blance --; &#125; else &#123; if (small.top() == ans) small.pop(); else m[ans]++; blance ++; &#125; if (blance &gt; 0) &#123; small.push(large.top()); large.pop(); &#125; if (blance &lt; 0) &#123; large.push(small.top()); small.pop(); &#125; while (!small.empty() &amp;&amp; m[small.top()]) &#123; m[small.top()] --; small.pop(); &#125; while (!large.empty() &amp;&amp; m[large.top()]) &#123; m[large.top()] --; large.pop(); &#125; &#125; return ret; &#125;&#125;; Design Twitter Leetcode 355 Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods: postTweet(userId, tweetId): Compose a new tweet.getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.follow(followerId, followeeId): Follower follows a followee.unfollow(followerId, followeeId): Follower unfollows a followee.1234567891011121314151617181920212223242526Example:Twitter twitter = new Twitter();// User 1 posts a new tweet (id = 5).twitter.postTweet(1, 5);// User 1&apos;s news feed should return a list with 1 tweet id -&gt; [5].twitter.getNewsFeed(1);// User 1 follows user 2.twitter.follow(1, 2);// User 2 posts a new tweet (id = 6).twitter.postTweet(2, 6);// User 1&apos;s news feed should return a list with 2 tweet ids -&gt; [6, 5].// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.twitter.getNewsFeed(1);// User 1 unfollows user 2.twitter.unfollow(1, 2);// User 1&apos;s news feed should return a list with 1 tweet id -&gt; [5],// since user 1 is no longer following user 2.twitter.getNewsFeed(1); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677struct tweet &#123; int id; int time; tweet(int id, int time) : id(id), time(time) &#123;&#125;;&#125;;class Twitter &#123;public: unordered_map&lt;int, unordered_set&lt;int&gt;&gt; fo; unordered_map&lt;int, vector&lt;tweet&gt;&gt; po; int current; /** Initialize your data structure here. */ Twitter() &#123; current = 0; &#125; /** Compose a new tweet. */ void postTweet(int userId, int tweetId) &#123; current ++; po[userId].push_back(tweet(tweetId, current)); &#125; void heapfy(vector&lt;tweet&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; nums[left].time &gt; nums[smallest].time) smallest = left; if (right &lt; max &amp;&amp; nums[right].time &gt; nums[smallest].time) smallest = right; if (smallest != index) &#123; swap(nums[smallest], nums[index]); heapfy(nums, smallest, max); &#125; &#125; /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ vector&lt;int&gt; getNewsFeed(int userId) &#123; // 此处在实际使用中应该使用多路归并的思路，但是这里为了简便就将所有数据放到堆中然后选出top10 vector&lt;tweet&gt; ans; for (auto i : fo[userId]) &#123; for (auto j : po[i]) &#123; ans.push_back(j); &#125; &#125; for (auto i : po[userId]) &#123; ans.push_back(i); &#125; int len = ans.size(); for (int i = len / 2 - 1; i &gt;= 0; i--) heapfy(ans, i, len); vector&lt;int&gt; ret; for (int i = len - 1; i &gt;= 0 &amp;&amp; ret.size() &lt; 10; i--) &#123; ret.push_back(ans[0].id); swap(ans[i], ans[0]); // 此处注意堆排序调整只需要调整一个路径就可以 heapfy(ans, 0, i); &#125; return ret; &#125; /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ void follow(int followerId, int followeeId) &#123; if (followerId == followeeId) return; fo[followerId].insert(followeeId); &#125; /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ void unfollow(int followerId, int followeeId) &#123; fo[followerId].erase(followeeId); &#125;&#125;;/** * Your Twitter object will be instantiated and called as such: * Twitter obj = new Twitter(); * obj.postTweet(userId,tweetId); * vector&lt;int&gt; param_2 = obj.getNewsFeed(userId); * obj.follow(followerId,followeeId); * obj.unfollow(followerId,followeeId); */ 实际中应该使用的是对已经排序了的数组使用多路归并，思路是堆中存放的是路角标和列角标的pair： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;iostream&gt;using namespace std;void heapfy(vector&lt;pair&lt;int, int&gt;&gt;&amp; ans, vector&lt;vector&lt;int&gt;&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; nums[ans[left].first][ans[left].second] &lt; nums[ans[smallest].first][ans[smallest].second]) smallest = left; if (right &lt; max &amp;&amp; nums[ans[right].first][ans[right].second] &lt; nums[ans[smallest].first][ans[smallest].second]) smallest = right; if (index != smallest) &#123; swap(ans[index], ans[smallest]); heapfy(ans, nums, smallest, max); &#125;&#125;vector&lt;int&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; ret; vector&lt;pair&lt;int, int&gt;&gt; ans; int N = 0; for (int i = 0; i &lt; n; i++) &#123; N += nums[i].size(); ans.push_back(make_pair(i, 0)); &#125; for (int i = n /2; i &gt;= 0; i--) &#123; heapfy(ans, nums, i, n); &#125; while (ret.size() &lt; N) &#123; auto temp = ans[0]; ret.push_back(nums[temp.first][temp.second]); cout &lt;&lt; temp.first &lt;&lt; ":" &lt;&lt; temp.second &lt;&lt; ": "&lt;&lt; ret.back() &lt;&lt; endl; ans.erase(ans.begin()); if (temp.second + 1 &lt; nums[temp.first].size()) &#123; ans.push_back(make_pair(temp.first, temp.second + 1)); &#125; int len = ans.size(); for (int i = len / 2; i &gt;= 0; i--) heapfy(ans, nums, i, len); &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; nums; for (int i = 0; i &lt; n; i++) &#123; int t; cin &gt;&gt; t; vector&lt;int&gt; ans(t, 0); for (int j = 0; j &lt; t; j++) &#123; cin &gt;&gt; ans[j]; &#125; nums.push_back(ans); &#125; auto ret = helper(nums); for (auto i : ret) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>总结</tag>
        <tag>Leetcode</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 位操作相关整理]]></title>
    <url>%2F2018%2F08%2F11%2Fleetcode-summary-bit-manipulation%2F</url>
    <content type="text"><![CDATA[这里总结一些leetcode上比较经典的位操作例题与思路，分类和题目正在更新… 四则运算 Pow(x, n) Leetcode 50 Implement pow(x, n), which calculates x raised to the power n (xn). 12Input: 2.00000, 10Output: 1024.00000 代码1234567891011121314class Solution &#123;public: double myPow(double x, int n) &#123; double ret = 1.0; // 注意要整型溢出 long N = abs((long) n); while (N) &#123; if (N &amp; 1) ret *= x; N &gt;&gt;= 1; x *= x; &#125; return n &gt; 0 ? ret : 1 / ret; &#125;&#125;; Divide Two Integers Leetcode 29 Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1:12Input: dividend = 10, divisor = 3Output: 3 Example 2:12Input: dividend = 7, divisor = -3Output: -2 123456789101112// 第一种思路是使用logclass Solution &#123;public: int divide(int dividend, int divisor) &#123; if (!divisor || (dividend == INT_MIN &amp;&amp; divisor == -1)) return INT_MAX; double t1 = log(fabs(dividend)); double t2 = log(fabs(divisor)); long long ret = exp(t1 - t2); int syn = (dividend &gt; 0) ^ (divisor &gt; 0); return syn &gt; 0 ? -ret : ret; &#125;&#125;; 123456789101112131415161718192021// 第二种思路是dividend = 2^k1*divisor + 2^k2*divisor + ...class Solution &#123;public: int divide(int dividend, int divisor) &#123; if (!divisor || (dividend == INT_MIN &amp;&amp; divisor == -1)) return INT_MAX; long long ret = 0; long long m = abs((long long)dividend); long long n = abs((long long)divisor); int syn = (dividend &gt; 0) ^ (divisor &gt; 0) ? -1 : 1; while (m &gt;= n) &#123; long long s = n, ans = 1; while (m &gt;= (s &lt;&lt; 1)) &#123; s &lt;&lt;= 1; ans &lt;&lt;= 1; &#125; m -= s; ret += ans; &#125; return syn * ret; &#125;&#125;; Sum of Two Integers Leetcode 371 Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Given a = 1 and b = 2, return 3. 代码123456789101112class Solution &#123;public: int getSum(int a, int b) &#123; while (b) &#123; // 加法器原理 int temp = a ^ b; b = (a &amp; b) &lt;&lt; 1; a = temp; &#125; return a; &#125;&#125;; 前缀相关Power of Two Leetcode 231 Given an integer, write a function to determine if it is a power of two.123Input: 1Output: true Explanation: 20 = 1 代码1234567class Solution &#123;public: bool isPowerOfTwo(int n) &#123; if (n &lt;= 0) return false; return !(n &amp; (n - 1)); &#125;&#125;; Bitwise AND of Numbers Range Leetcode 201 Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. 12345Input: [5,7]Output: 4Input: [0,1]Output: 0 代码1234567class Solution &#123;public: int rangeBitwiseAnd(int m, int n) &#123; // 看相同的前缀 return n == m ? m : (rangeBitwiseAnd(m / 2, n / 2) &lt;&lt; 1); &#125;&#125;; Number Complement Leetcode 476 Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. 123Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. 代码123456class Solution &#123;public: int findComplement(int num) &#123; return ~num &amp; ((1 &lt;&lt; (int)log2(num)) - 1); &#125;&#125;; 位个数和位移动操作Number of 1 Bits Leetcode 191 Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight). 代码123456789101112class Solution &#123;public: int hammingWeight(uint32_t n) &#123; // 此题在剑指offer也有 n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) + (n &amp; 0x55555555); n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) + (n &amp; 0x33333333); n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) + (n &amp; 0x0F0F0F0F); n = ((n &amp; 0xFF00FF00) &gt;&gt; 8) + (n &amp; 0x00FF00FF); n = ((n &amp; 0xFFFF0000) &gt;&gt; 16) + (n &amp; 0x0000FFFF); return n; &#125;&#125;; Reverse Bits Leetcode 190 Reverse bits of a given 32 bits unsigned integer. 1234Input: 43261596Output: 964176192Explanation: 43261596 represented in binary as 00000010100101000001111010011100, return 964176192 represented in binary as 00111001011110000010100101000000. 1234567891011class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1); n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2); n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) | ((n &amp; 0x0F0F0F0F) &lt;&lt; 4); n = ((n &amp; 0xFF00FF00) &gt;&gt; 8) | ((n &amp; 0x00FF00FF) &lt;&lt; 8); n = ((n &amp; 0xFFFF0000) &gt;&gt; 16) | ((n &amp; 0x0000FFFF) &lt;&lt; 16); return n; &#125;&#125;; Total Hamming Distance Leetcode 477 The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Now your job is to find the total Hamming distance between all pairs of the given numbers. 1234567Input: 4, 14, 2Output: 6Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (justshowing the four bits relevant in this case). So the answer will be:HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6. 代码123456789101112131415class Solution &#123;public: int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123; // 此题主要思想是将每一位分开计算 int ret = 0, n = nums.size(); for (int i = 0; i &lt; 31; i++) &#123; int cnt = 0; for (auto j : nums) &#123; cnt += (j &gt;&gt; i) &amp; 1; &#125; ret += cnt * (n - cnt); &#125; return ret; &#125;&#125;; 重复使用抑或操作在同一个整型上重复偶数次抑或同一个数会导致该数消失，可以使用抑或操作进行一些变化或引导一些变化 Missing Number Leetcode 268 Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.1234567Example 1:Input: [3,0,1]Output: 2Example 2:Input: [9,6,4,2,3,5,7,0,1]Output: 8 代码12345678910111213class Solution &#123;public: // 从1到n都被抑或一遍，然后再被覆盖一遍就会消失，被抑或一遍的就会剩下。 int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int ans = n; for (int i = 0; i &lt; n; i++) &#123; ans ^= i; ans ^= nums[i]; &#125; return ans; &#125;&#125;; Single Number Leetcode 136 Given a non-empty array of integers, every element appears twice except for one. Find that single one.1234567Example 1:Input: [2,2,1]Output: 1Example 2:Input: [4,1,2,1,2]Output: 4 代码12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for (auto i : nums) &#123; ans ^= i; &#125; return ans; &#125;&#125;; Single Number II Leetcode 137 Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. 1234567Example 1:Input: [2,2,3,2]Output: 3Example 2:Input: [0,1,0,1,0,1,99]Output: 99 代码1234567891011121314151617181920212223class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; /* 此题比较难理解，核心思想是利用状态机将每一位经过抑或操作后按照一定的条件变化 例如用三位数表示一位数分别经过1,2,3次抑或后的状态，即001-&gt;010-&gt;100 因为除了一个数都出现三次，所以只需要用两个数保存状态即可 通过总结规律发现，[0][1]-&gt;[1][0]-&gt;[0][0]， two保存所有经过两次抑或后的数的结果，one保存经过一次抑或操作后的数的结果 two一次由抑或之后和~one做与就可以完成状态的转换，one也是一样的 因为只有一个数出现一次，所以one就是最终结果。 */ int one = 0, two = 0; for (auto i : nums) &#123; one = ~two &amp; (i ^ one); two = ~one &amp; (i ^ two); &#125; return one; &#125;&#125;; Single Number III Leetcode 260 Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. 1234Example:Input: [1,2,1,3,2,5]Output: [3,5] 代码1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for (auto i : nums) &#123; ans ^= i; &#125; // 此步比较重要，选取一位为1的数，说明该位出现过一次 int m = (ans &amp; (ans - 1)) ^ ans; int a = 0, b = 0; for (auto i : nums) &#123; if (i &amp; m) a ^= i; else b ^= i; &#125; return vector&lt;int&gt;&#123;a, b&#125;; &#125;&#125;; 与位操作相关的数学题与位操作相关的数学题通常需要找规律或者先证明，此部分也会不断补充… Integer Replacement Leetcode 397 1234567891011121314151617181920212223Given a positive integer n and you can do operations as follow:If n is even, replace n with n/2.If n is odd, you can replace n with either n + 1 or n - 1.What is the minimum number of replacements needed for n to become 1?Example 1:Input:8Output:3Explanation:8 -&gt; 4 -&gt; 2 -&gt; 1Example 2:Input:7Output:4Explanation:7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1or7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1 代码12345678910111213141516class Solution &#123;public: int integerReplacement(int N) &#123; long long n = N; int ret = 0; while (n != 1) &#123; ret ++; if (n &amp; 1) &#123; if (n &amp; 2 &amp;&amp; n != 3) n++; else n --; &#125; else n &gt;&gt;= 1; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>总结</tag>
        <tag>Leetcode</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图相关内容总结]]></title>
    <url>%2F2018%2F06%2F21%2FgrGraph-Theory-Algorithm%2F</url>
    <content type="text"><![CDATA[此部分是遇到的图论相关算法总结，正在不断更新….关于图论的相关基础知识和每个算法的具体推导，可以参考演算法笔记中的Graph Theory和Combinatorial Optimization部分。 路径相关算法欧拉回路和欧拉路径欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。同样，欧拉路径就是从一点出发，能遍历所有图中的边，从而形成的路径。 判断欧拉回路的条件从图论里面可以知道，是整个图连通，然后每个点的入度等于出度就可以确定从任何一点出发都可遍历所有图。 寻找欧拉回路和路径的算法，也是一种贪心，每次尽量选择出度未走路径多的点作为下一个遍历的点，否则如果选择了该点，则无法再回来。因为这个算法是一种贪心，又保证连通，所以可以用栈保存行走的路径，如果不能再走向其他点，则说明不能再走到别的点，此时说明路径无法再扩展路径已经形成，所以。 因此如果用dfs回溯也是可以一边迭代完成。 欧拉路径的算法验证可以参考leetcode332 这里给出leetcode332的算法解答，也可以看做模板：12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; findItinerary(vector&lt;pair&lt;string, string&gt;&gt; tickets) &#123; vector&lt;string&gt; ret; unordered_map&lt;string, vector&lt;string&gt;&gt; map; for (auto i : tickets) &#123; map[i.first].push_back(i.second); &#125; for (auto &amp;i : map) &#123; sort(i.second.begin(), i.second.end()); &#125; stack&lt;string&gt; s; s.push("JFK"); while (!s.empty()) &#123; auto temp = s.top(); if (map[temp].empty()) &#123; ret.push_back(temp); s.pop(); &#125; else &#123; s.push(map[temp][0]); map[temp].erase(map[temp].begin()); &#125; &#125; reverse(ret.begin(), ret.end()); return ret; &#125;&#125;; 单源最短路径算法单元最短路径的意思为给定七点，求出起点到图上每个点的最短路径，一对多。 通常求最短路径的思路有两种 第一种是逐步确定每个点的最短路径长度，一旦确定后就不会再更改了，负边不适用。 第二种是某点确定最短路径长度之后，还要不断修正，整个过程就是不断修正的过程，负边也适用。 Dijkstra算法 最短路径最经典的算法，是贪心发的一种应用，对于处理非负权的图比较有效。 同样，此算法也可以用于计算最长路，但是需要把所有的权值都改成负数。 Dijkstra算法模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;climits&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;int&gt;&amp; parents, vector&lt;unordered_set&lt;int&gt;&gt;&amp; adj) &#123; int n = parents.size(); unordered_set&lt;int&gt; s; // 没有访问的点 vector&lt;int&gt; dp(n, INT_MAX); // 保存当前每个点最短距离 for (int i = 0; i &lt; n; i++) &#123; s.insert(i); &#125; // 初始化 dp[0] = 0; parents[0] = 0; while (!s.empty()) &#123; int index, ans = INT_MAX; // 查找当前距离起点最近的未访问点 for (auto i : s) &#123; if (ans &gt; dp[i]) &#123; ans = dp[i]; index = i; &#125; &#125; // 访问该节点 s.erase(index); // 根据已经访问的节点更新距离 relaxation for (auto j : adj[index]) &#123; if (matrix[index][j] + dp[index] &lt; dp[j]) &#123; // 这里不需要判断是不是已经访问过了，因为根据贪心保存过得一定是最小的 dp[j] = matrix[index][j] + dp[index]; parents[j] = index; &#125; &#125; &#125; return dp;&#125;void find_path(vector&lt;int&gt;&amp; parents, int x) &#123; if (x != parents[x]) find_path(parents, parents[x]); cout &lt;&lt; x &lt;&lt; " ";&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, INT_MAX)); vector&lt;unordered_set&lt;int&gt;&gt; edges(n, unordered_set&lt;int&gt;()); for (int i = 0; i &lt; k; i++) &#123; int x, y, d; cin &gt;&gt; x &gt;&gt; y &gt;&gt; d; matrix[x][y] = d; matrix[y][x] = d; edges[x].insert(y); edges[y].insert(x); &#125; vector&lt;int&gt; parents(n, 0); vector&lt;int&gt; dp = helper(matrix, parents, edges); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; dp[i] &lt;&lt; endl; find_path(parents, i); cout &lt;&lt; endl; &#125; return 0;&#125;/*5 70 1 1000 2 300 4 102 1 602 3 603 1 104 3 50*/ Dijkstra看图论书容易陷入误区，会以为每次保存最新纳入的节点作为下次搜索的起始节点，然后进行下次搜索最小值并更新。然而这搞错了步骤，首先，更新过距离的未访问点已经是该点当前距离起点最近的距离了，从其中选择最短路然后访问，再通过当前最短路更新其余点的最短路，这样稳定的进行贪心算法。 当前代码的时间复杂度是O(V2)，但是如果使用V个元素的斐波那契堆，用decrease key函数来进行relaxtion，使用extract min来找下一个点，就可以将时间简化到O(E+VlgV)，所以理论上Dijkstra算法为O(E+VlgV)，此处的代码之后更新。 关于单源最短路径还可以有更多优化，由于面试中可能涉及的较少这里不做总结，感兴趣的同学可以参考最短路径的优化。 Dijkstra算法扩展给定起始点，寻找其间第K小的路径。 参考文献为csdn 代码模板参考链接 SPFA算法 这部分内容参考资料台湾师范大学的推算法笔记，这里只做算法实现的总结。 主题思想是用BFS的思想，不断访问已经访问的点并扩展到邻节点，并更新节点距离，同时要检测负环，防止负环边数大于V-1而循环到负无穷。如果路径中有负环，那么负环无限循环路径权值就为负无穷，也就不存在最短路径，算法结束。 SPFA算法模板：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;void find_negative_cycle(int index, vector&lt;int&gt;&amp; parents, int n) &#123; cout &lt;&lt; "负环:" &lt;&lt; endl; int x = parents[index]; while (index != parents[x]) &#123; cout &lt;&lt; x &lt;&lt; endl; x = parents[x]; &#125;&#125;vector&lt;int&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;int&gt;&amp; parents, vector&lt;unordered_set&lt;int&gt;&gt;&amp; adj) &#123; int n = parents.size(); vector&lt;bool&gt; inqueue(n, false); // 已经在队列中 vector&lt;int&gt; dp(n, INT_MAX); // 保存当前每个点最短距离 vector&lt;int&gt; cnt(n, 0); // 记录最短路径的边数 // 初始化 dp[0] = 0; parents[0] = 0; cnt[0] = 0; queue&lt;int&gt; q; q.push(0); while (!q.empty()) &#123; int index = q.front(); q.pop(); inqueue[index] = false; if (inqueue[parents[index]]) // 加速：queue中已经有了parents[index]，舍弃index继续，说明index已经稳定 continue; // 根据已经访问的节点更新距离 for (auto j : adj[index]) &#123; if (matrix[index][j] + dp[index] &lt; dp[j]) &#123; dp[j] = matrix[index][j] + dp[index]; parents[j] = index; cnt[j] = cnt[index] + 1; // 边数增加 if (cnt[j] &gt;= n) &#123; // 有负环 find_negative_cycle(j, parents, n); return dp; &#125; if (!inqueue[j]) &#123; // 如果队列中没有就加入 inqueue[j] = true; q.push(j); &#125; &#125; &#125; &#125; return dp;&#125;void find_path(vector&lt;int&gt;&amp; parents, int x) &#123; if (x != parents[x]) find_path(parents, parents[x]); cout &lt;&lt; x &lt;&lt; " ";&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, INT_MAX)); vector&lt;unordered_set&lt;int&gt;&gt; edges(n, unordered_set&lt;int&gt;()); for (int i = 0; i &lt; k; i++) &#123; int x, y, d; cin &gt;&gt; x &gt;&gt; y &gt;&gt; d; matrix[x][y] = d; matrix[y][x] = d; edges[x].insert(y); edges[y].insert(x); &#125; vector&lt;int&gt; parents(n, 0); vector&lt;int&gt; dp = helper(matrix, parents, edges); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; dp[i] &lt;&lt; endl; find_path(parents, i); cout &lt;&lt; endl; &#125; return 0;&#125; 图的直径树形图的直径 这个算法也是较为经典的算法，使用BFS从所有悬挂点出发，并把悬挂点剥离，最后根据BFS迭代的次数判断无向图的最长路，也就是图的直径。注意此算法的前提是保证无向图为连通图，如果不是连通图首先要判断一下连通性。 验证地址leetcode 310 从方法无法处理有环图，因为有环存在只有一个叶子节点的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_set&gt;#include &lt;utility&gt;using namespace std;int helper(int n, vector&lt;pair&lt;int, int&gt;&gt;&amp; grap) &#123; if (n == 1) return 0; vector&lt;unordered_set&lt;int&gt;&gt; count(n, unordered_set&lt;int&gt;()); for (auto i : grap) &#123; if (i.first == i.second) continue; // 去掉环 count[i.first].insert(i.second); count[i.second].insert(i.first); &#125; int ret = 0; vector&lt;int&gt; current; for (int i = 0; i &lt; n; i++) &#123; int len = count[i].size(); if (len == 1) current.push_back(i); &#125; while (true) &#123; vector&lt;int&gt; next; ret ++; for (auto i : current) &#123; // 默认所有current中的点都是悬挂点 // 所以遍历叶子节点的相邻点并去掉与之相连的边，这些边就不能被访问到。 for (auto j : count[i]) &#123; count[j].erase(i); if (count[j].size() == 1) next.push_back(j); &#125; &#125; if (next.empty()) break; current = next; &#125; // 终止集合是单点是迭代次数的二倍，集合为两个点还要多算连接这两个点的边 // 因为终止条件是next为空，所以会将终止集合也多算一次迭代，所以需要减去。 return current.size() == 1 ? ret * 2 - 2: ret * 2 - 1;&#125;int main() &#123; int n, k; cin &gt;&gt; k &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; grap; for (int i = 0; i &lt; k; i ++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; grap.push_back(make_pair(x, y)); &#125; cout &lt;&lt; helper(n, grap) &lt;&lt; endl; return 0;&#125;/*5 40 11 22 30 23 3*/ 无向图的直径如果是要求非树形连通图，就需要定义几个概念： 偏心距 ：以最短路径长度作为距离，一张无向图中距离一点最远的距离被称为该点的偏心距。 直径与半径 : 一张无向图的直径是所有偏心距中最大的一个，半径是途中所有偏心距离中最小的一个。直径也可以直接认为是图上最长的一条最短路径的长度。 直径与半径代码模板（Floyd-Warshall算法）:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;cmath&gt;using namespace std;void helper(int n, vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int&amp; d, int&amp; r) &#123; // Floyd-Warshall Algorithm for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; // 注意溢出 matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]); &#125; &#125; &#125; // 计算偏心距 vector&lt;int&gt; ecc(n, 0); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (matrix[i][j] != 1E9) &#123; ecc[i] = max(ecc[i], matrix[i][j]); &#125; &#125; &#125; // 半径与直径 d = 0, r = 1E9; for (int i = 0; i &lt; n; i++) &#123; d = max(d, ecc[i]); r = min(r, ecc[i]); &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, 1E9)); for (int i = 0; i &lt; k; i++) &#123; int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; matrix[x][y] = v; matrix[y][x] = v; &#125; int d, r; helper(n, matrix, d, r); cout &lt;&lt; "diameter: " &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; "radius: " &lt;&lt; r &lt;&lt; endl; return 0;&#125; 图的连通性 使用并查集，测试样例可以参考cnblog 这里先给出并查集的模板：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int find(int x, vector&lt;int&gt;&amp; set) &#123; int y = x; while (set[x] != x) &#123; x = set[x]; &#125; while (x != y) &#123; int t = set[y]; set[y] = x; y = t; &#125; return x;&#125;void merge(int x, int y, vector&lt;int&gt;&amp; set) &#123; int p1 = find(x, set); int p2 = find(y, set); if (p1 != p2) &#123; set[p1] = p2; &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; set(n + 1, 0); for (int i = 1; i &lt;= n; i++) &#123; set[i] = i; &#125; for (int i = 0; i &lt; k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, set); &#125; int ret = 0; for (int i = 1; i &lt;= n; i++) &#123; if (set[i] == i) ret ++; &#125; cout &lt;&lt; ret &lt;&lt; endl; return 0;&#125; 使用图结构后计算并查集并计算连通分量：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;using namespace std;int find(int x, vector&lt;int&gt;&amp; set) &#123; int y = x; while (x != set[x]) &#123; x = set[x]; &#125; while (y != x) &#123; int t = set[y]; set[y] = x; y = t; &#125; return x;&#125;void merge(int x, int y, vector&lt;int&gt;&amp; set) &#123; int p1 = find(x, set); int p2 = find(y, set); if (p1 != p2) &#123; set[p1] = p2; &#125;&#125;void helper(vector&lt;unordered_set&lt;int&gt;&gt;&amp; edges) &#123; int n = edges.size(); vector&lt;int&gt; set(n, 0); for (int i = 0; i &lt; n; i++) &#123; set[i] = i; &#125; for (int i = 0; i &lt; n; i++) &#123; for (auto j : edges[i]) &#123; merge(i, j, set); &#125; &#125; vector&lt;unordered_set&lt;int&gt;&gt; ret(n, unordered_set&lt;int&gt;()); for (int i = 0; i &lt; n; i++) &#123; ret[set[i]].insert(i); &#125; for (auto i : ret) &#123; if (i.empty()) continue; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;unordered_set&lt;int&gt;&gt; edges(n, unordered_set&lt;int&gt;()); for (int i = 0; i &lt; k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; edges[x].insert(y); edges[y].insert(x); &#125; helper(edges); return 0;&#125;/*4 50 10 21 21 13 3*/ 拓扑排序拓扑排序的要点是要注意加入队列的条件，需要入度为0的时候才可以加入。可以使用leetcode的Reconstruct Itinerary进行验证。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;unordered_set&gt;#include &lt;unordered_set&gt;using namespace std;void helper(int n, vector&lt;pair&lt;int, int&gt;&gt;&amp; edges) &#123; vector&lt;int&gt; degree(n, 0); vector&lt;unordered_set&lt;int&gt;&gt; count(n, unordered_set&lt;int&gt;()); for (auto i : edges) &#123; degree[i.second]++; count[i.first].insert(i.second); &#125; vector&lt;int&gt; cur; for (int i = 0; i &lt; n; i++) &#123; if (degree[i] == 0) &#123; cur.push_back(i); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; ret; while (!cur.empty()) &#123; vector&lt;int&gt; ans; for (auto i : cur) &#123; for (auto j : count[i]) &#123; degree[j] --; if (degree[j] == 0) ans.push_back(j); &#125; &#125; ret.push_back(cur); cur = ans; &#125; for (auto i : ret) &#123; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;pair&lt;int, int&gt;&gt; edges; for (int i = 0; i &lt; k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt;y; edges.push_back(make_pair(x, y)); &#125; helper(n, edges); return 0;&#125; 网络流相关算法最大流 本文的参考文献是最大流（网络流基础概念+三个算法），可以用POJ1273验证。 EK（Edmond—Karp）算法第一种算法EK（Edmond—Karp）算法，主要的要去是每做一次更新都会建立一条反向的边，从而建立返回的渠道减少替代回溯的高消耗。模板如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int BFS(vector&lt;int&gt;&amp; pre, int start, int end, vector&lt;vector&lt;int&gt;&gt;&amp; cap) &#123; queue&lt;int&gt; q; int n = cap.size(); for (int i = 0; i &lt; n; i++) &#123; pre[i] = -1; &#125; vector&lt;int&gt; flow(n, 0); // 保存流 // 初始化 pre[start] = start; flow[start] = 0x7FFFFFFF; q.push(start); while (!q.empty()) &#123; // 用bfs搜索整个路 int index = q.front(); q.pop(); if (index == end) break; // 到达终点为可增路 for (int i = 0; i &lt; n; i++) &#123; if (i != start &amp;&amp; cap[index][i] &gt; 0 &amp;&amp; pre[i] == -1) &#123; // 更新流 pre[i] = index; flow[i] = min(flow[index], cap[index][i]); q.push(i); &#125; &#125; &#125; // 可增路无法到达终点 if (pre[end] == -1) return -1; else return flow[end];&#125;int helper(int n, vector&lt;vector&lt;int&gt;&gt;&amp; cap, vector&lt;int&gt;&amp; pre, int start, int end) &#123; int ret = 0; int increase = 0; // 单次可增路的增大流容量 while ((increase = BFS(pre, start, end, cap)) != -1) &#123; // 返回-1代表没有可增路 int temp = end; while (temp != start) &#123; // 更新可增路上的容量 int last = pre[temp]; cap[last][temp] -= increase; // 反向也要增加 cap[temp][last] += increase; temp = last; &#125; ret += increase; &#125; return ret;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; cap(n, vector&lt;int&gt;(n, 0)); vector&lt;int&gt; pre(n, -1); // 用来标记可增路的路径 for (int i = 0; i &lt; m; i++) &#123; int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; if (x == y) continue; cap[x][y] = v; &#125; cout &lt;&lt; helper(n, cap, pre, 0, n - 1) &lt;&lt; endl;; return 0;&#125;/*4 50 1 401 2 301 3 200 3 202 3 10*/ Ford-Fulkerson算法Ford-Fulkerson算法可认为是DFS版本的EK，由于是递归，会带来空间消耗。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;using namespace std;int dfs(int start, int end, vector&lt;vector&lt;int&gt;&gt;&amp; cap, vector&lt;bool&gt;&amp; visited, int flow) &#123; int n = visited.size(); if (start == end) &#123; return flow; &#125; for (int i = 0; i &lt; n; i++) &#123; if (cap[start][i] &gt; 0 &amp;&amp; !visited[i]) &#123; visited[i] = true; int f = dfs(i, end, cap, visited, min(flow, cap[start][i])); if (f &gt; 0) &#123; cap[start][i] -= f; cap[i][start] += f; return f; &#125; &#125; &#125; // 没有可增路返回0 return 0;&#125;int helper(int n, vector&lt;vector&lt;int&gt;&gt;&amp; cap, int start, int end) &#123; int ret = 0; while (true) &#123; vector&lt;bool&gt; visited(n, false); int flow = dfs(start, end, cap, visited, 0x7FFFFFFF); if (flow == 0) break; ret += flow; &#125; return ret;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; cap(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; cap[x][y] = v; &#125; cout &lt;&lt; helper(n, cap, 0, n - 1) &lt;&lt; endl; return 0;&#125;/*4 50 1 401 2 301 3 200 3 202 3 10*/ Dinic算法Dinic算法是网络流最大流的优化算法之一，每一步对原图进行分层，然后用DFS求增广路。时间复杂度是O(n^2*m)，Dinic算法最多被分为n个阶段，每个阶段包括建层次网络和寻找增广路两部分。 Dinic算法的思想是分阶段地在层次网络中增广。它与最短增广路算法不同之处是：最短增广路每个阶段执行完一次BFS增广后，要重新启动BFS从源点Vs开始寻找另一条增广路;而在Dinic算法中，只需一次BFS过程就可以实现多次增广。 观察前面的dfs算法，对于层次相同的边，会经过多次重复运算，很浪费时间，那么，可以考虑先对原图分好层产生新的层次图，即保存了每个点的层次，注意，很多人会把这里的边的最大容量跟以前算最短路时的那个权值混淆，其实这里每个点之间的距离都可以看作单位距离，然后对新图进行dfs，这时的dfs就非常有层次感，有筛选感了，同层次的点不可能在同一跳路径中，直接排除。那么运行速度就会快很多了。 Dinic算法模板：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstdlib&gt;using namespace std;int bfs(int start, int end, vector&lt;vector&lt;int&gt;&gt;&amp; cap, vector&lt;int&gt;&amp; dep) &#123; queue&lt;int&gt; q; q.push(start); int n = dep.size(); for (int i = 0; i &lt; n; i++) &#123; dep[i] = -1; &#125; dep[start] = 0; while (!q.empty()) &#123; int index = q.front(); q.pop(); for (int i = 0; i &lt; n; i++) &#123; if (cap[index][i] &gt; 0 &amp;&amp; dep[i] == -1) &#123; dep[i] = dep[index] + 1; q.push(i); &#125; &#125; &#125; return dep[end] != -1;&#125;int dfs(int start, int end, vector&lt;vector&lt;int&gt;&gt;&amp; cap, vector&lt;int&gt;&amp; dep, int flow) &#123; if (start == end) return flow; int n = dep.size(); for (int i = 0; i &lt; n; i++) &#123; if (cap[start][i] &gt; 0 &amp;&amp; dep[i] == dep[start] + 1) &#123; int temp = dfs(i, end, cap, dep, min(flow, cap[start][i])); if (temp != 0) &#123; cap[start][i] -= temp; cap[i][start] += temp; return temp; &#125; &#125; &#125; return 0;&#125;int helper(int n, int start, int end, vector&lt;vector&lt;int&gt;&gt;&amp; cap) &#123; int ret = 0; vector&lt;int&gt; dep(n, -1); while (bfs(start, end, cap, dep)) &#123; while (true) &#123; int temp = dfs(start, end, cap, dep, 0x7FFFFFFF); if (!temp) break; ret += temp; &#125; &#125; return ret;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; cap(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; cap[x][y] = v; &#125; cout &lt;&lt; helper(n, 0, n - 1, cap) &lt;&lt; endl; return 0;&#125;/*4 50 1 401 2 301 3 200 3 202 3 10*/ 最大流问题还有很多种变种，因为本身面试中涉及基础图论比较少，不做涉及，更多了解可以参考资料 最小割SW（Stoer-Wagner）算法最小割算法有很多算法，这里只提供一种模板，就是比较常用的Stoer-Wagner Algorithm，其中的推导和更多算法可以访问资料 这个算法的验证地址是POJ2914模板如下（代码参考自cnblog）：123456789101112131415161718192021222324252627282930313233343536373839404142434445const int maxn = 550;const int inf = 1000000000;int n, r;int edge[maxn][maxn], dist[maxn];bool vis[maxn], bin[maxn];void init()&#123; memset(edge, 0, sizeof(edge)); memset(bin, false, sizeof(bin));&#125;int contract( int &amp;s, int &amp;t ) // 寻找 s,t&#123; memset(dist, 0, sizeof(dist)); memset(vis, false, sizeof(vis)); int i, j, k, mincut, maxc; for(i = 1; i &lt;= n; i++) &#123; k = -1; maxc = -1; for(j = 1; j &lt;= n; j++)if(!bin[j] &amp;&amp; !vis[j] &amp;&amp; dist[j] &gt; maxc) &#123; k = j; maxc = dist[j]; &#125; if(k == -1)return mincut; s = t; t = k; mincut = maxc; vis[k] = true; for(j = 1; j &lt;= n; j++)if(!bin[j] &amp;&amp; !vis[j]) dist[j] += edge[k][j]; &#125; return mincut;&#125;int Stoer_Wagner()&#123; int mincut, i, j, s, t, ans; for(mincut = inf, i = 1; i &lt; n; i++) &#123; ans = contract( s, t ); bin[t] = true; if(mincut &gt; ans)mincut = ans; if(mincut == 0)return 0; for(j = 1; j &lt;= n; j++)if(!bin[j]) edge[s][j] = (edge[j][s] += edge[j][t]); &#125; return mincut;&#125; BFS/DFS待更新…]]></content>
      <tags>
        <tag>算法</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer部分题目思路总结]]></title>
    <url>%2F2018%2F06%2F13%2Ftargeting-offer-in-nowcoder%2F</url>
    <content type="text"><![CDATA[这部分主要是在牛客网上进行的验证，部分简单的题目没有进行总结，如果有别的思路，欢迎联系我进行交流。 变态跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 可以发现：则f(1)=1,f(2)=2,f(3)=4,f(4)=8,我们隐约感觉到f(n)=2^(n-1)，但是需要证明下，同样根据我们根据上篇文章中跳台阶的思路，可以得到f(n)=f(n-1)+f(n-2)+….+f(1)+1,而f(n-1)=f(n-2)+….+f(1)+1,两个式子相减，得到f(n) = 2f(n-1),很明显可以得到f(n)=2^(n-1)。 123456class Solution &#123;public: int jumpFloorII(int number) &#123; return 1 &lt;&lt; (number - 1); &#125;&#125;; 矩形覆盖 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 123456789101112class Solution &#123;public: int rectCover(int number) &#123; if (number &lt;= 2) return number; int pre = 1, cur = 2; for (int i = 3; i &lt;= number; i++) &#123; cur += pre; pre = cur - pre; &#125; return cur; &#125;&#125;; 二进制中1的个数 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 1234567891011class Solution &#123;public: int NumberOf1(int n) &#123; n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) + (n &amp; 0x55555555); n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) + (n &amp; 0x33333333); n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) + (n &amp; 0x0F0F0F0F); n = ((n &amp; 0xFF00FF00) &gt;&gt; 8) + (n &amp; 0x00FF00FF); n = ((n &amp; 0xFFFF0000) &gt;&gt; 16) + (n &amp; 0x0000FFFF); return n; &#125;&#125;; 浮点数快速幂 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 1234567891011121314class Solution &#123;public: double Power(double base, int exponent) &#123; int syn = exponent &gt; 0 ? 1 : -1; double ret = 1.0; long long N = abs((long long) exponent); // 注意可能取负溢出 while (N) &#123; if (N &amp; 1) ret *= base; base *= base; N &gt;&gt;= 1; &#125; return syn == 1 ? ret : 1/ ret; &#125;&#125;; 调整数组顺序使奇数位于偶数前面（冒泡排序相关） 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 123456789101112131415161718192021222324252627282930class Solution &#123;public: // 排序算法的另外一种运用，因为要使用稳定的排序，所以可以利用冒泡排序 // 冒泡排序的两种写法：https://blog.csdn.net/shuaizai88/article/details/73250615 // 第一种： /* // 向下沉 void reOrderArray(vector&lt;int&gt; &amp;nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = 0;j &lt; n - 1 - i; j++) &#123; if (nums[j] % 2 == 0 &amp;&amp; nums[j + 1] % 2) swap(nums[j], nums[j + 1]); &#125; &#125; &#125; */ // 第二种：向上飘 void reOrderArray(vector&lt;int&gt; &amp;nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n; i ++) &#123; for (int j = n - 1;j &gt; i; j --) &#123; if (nums[j] % 2 &amp;&amp; nums[j - 1] % 2 == 0) swap(nums[j], nums[j - 1]); &#125; &#125; &#125;&#125;; 如果要是不要求保证原始顺序不变，就用双指针1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int left = 0, right = n - 1; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[left] % 2) left++; while (left &lt; right &amp;&amp; nums[right] % 2 == 0) right --; if (left &lt; right) &#123; swap(nums[left], nums[right]); left ++, right --; &#125; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; helper(nums); for (auto i : nums) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; 翻转单链表 输入一个链表，反转链表后，输出链表的所有元素。 123456789101112131415161718192021222324252627282930313233/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // 递归方法 空间O(n) ListNode* ReverseList(ListNode* pHead) &#123; if (!pHead || !pHead-&gt;next) return pHead; ListNode* ret = ReverseList(pHead-&gt;next); pHead-&gt;next-&gt;next = pHead; pHead-&gt;next = NULL; return ret; &#125; // 迭代 空间O(1) ListNode* ReverseList(ListNode* pHead) &#123; if (!pHead || !pHead-&gt;next) return pHead; ListNode* cur = pHead; ListNode* ret = NULL; while (cur) &#123; ListNode* temp = cur-&gt;next; cur-&gt;next = ret; ret = cur; cur = temp; &#125; pHead-&gt;next = NULL; return ret; &#125;&#125;; 树的子结构 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 12345678910111213141516171819202122232425/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool helper(TreeNode* A, TreeNode* B) &#123; if (B == NULL) return true; if (A == NULL) return false; if (A-&gt;val == B-&gt;val) &#123; return helper(A-&gt;left, B-&gt;left) &amp;&amp; helper(A-&gt;right, B-&gt;right); &#125; else return false; &#125; bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; if (pRoot1 == NULL || pRoot2 == NULL) return false; return helper(pRoot1, pRoot2) || HasSubtree(pRoot1-&gt;left, pRoot2) || HasSubtree(pRoot1-&gt;right, pRoot2); &#125;&#125;; 二叉树中和为某个值的路径 输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 12345678910111213141516171819202122232425262728/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void helper(vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt; ans, int sum, TreeNode* root, int target) &#123; if (!root) return; sum += root-&gt;val; ans.push_back(root-&gt;val); if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == target) &#123; ret.push_back(ans); &#125; helper(ret, ans, sum, root-&gt;left, target); helper(ret, ans, sum, root-&gt;right, target); &#125; vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123; vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; ans; helper(ret, ans, 0, root, expectNumber); return ret; &#125;&#125;; 复杂链表的复制 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead)&#123; if (!pHead) return NULL; RandomListNode* cur = pHead; while (cur) &#123; RandomListNode* temp = new RandomListNode(cur-&gt;label); temp-&gt;next = cur-&gt;next; cur-&gt;next = temp; cur = temp-&gt;next; &#125; cur = pHead; while (cur) &#123; RandomListNode* temp = cur-&gt;next; if (cur-&gt;random) &#123; temp-&gt;random = cur-&gt;random-&gt;next; &#125; cur = temp-&gt;next; &#125; RandomListNode* ret = pHead-&gt;next; cur = pHead; RandomListNode* c1 = NULL, *c2 = NULL; while (cur) &#123; if (!c1) &#123; c1 = cur; c2 = cur-&gt;next; &#125; else &#123; c1-&gt;next = cur; c2-&gt;next = cur-&gt;next; c1 = c1-&gt;next; c2 = c2-&gt;next; &#125; cur = cur-&gt;next-&gt;next; c1-&gt;next = NULL; c2-&gt;next = NULL; &#125; return ret; &#125;&#125;; 二叉树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 12345678910111213141516171819202122232425262728293031323334353637/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void helper(TreeNode* root, TreeNode* &amp;left, TreeNode* &amp;right) &#123; left = right = NULL; TreeNode* l, *r; if (root-&gt;left) &#123; helper(root-&gt;left, l, r); left = l, r-&gt;right = root, root-&gt;left = r; &#125; else &#123; left = root; &#125; if (root-&gt;right) &#123; helper(root-&gt;right, l, r); right = r, root-&gt;right = l, l-&gt;left = root; &#125; else &#123; right = root; &#125; &#125; TreeNode* Convert(TreeNode* pRootOfTree) &#123; if (!pRootOfTree) return NULL; TreeNode* left, *right; helper(pRootOfTree, left, right); return left; &#125;&#125;; 字符串的排列 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 12345678910111213141516171819202122class Solution &#123;public: void helper(string ans, int index, vector&lt;string&gt;&amp; ret) &#123; int len = ans.size(); if (index == len - 1) ret.push_back(ans); // 因为是有顺序的，所以等于是依次把后面的数提到前面来 // 比如：1234,2134,3124,4123 // 所以保证了后面的有序性，从而保证了唯一性，充分利用了递归的思想，每一层只做每一层的事情，不回溯 for (int i = index; i &lt; len; i++) &#123; if (i != index &amp;&amp; ans[index] == ans[i]) continue; swap(ans[i], ans[index]); helper(ans, index + 1, ret); &#125; &#125; vector&lt;string&gt; Permutation(string str) &#123; vector&lt;string&gt; ret; if (str.empty()) return ret; sort(str.begin(), str.end()); helper(str, 0, ret); return ret; &#125;&#125;; 数字中出现次数超过一半 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 123456789101112131415161718192021class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if (numbers.empty()) return 0; int ans = numbers[0]; int count = 0; for (auto i : numbers) &#123; if (ans == i) count ++; else count --; if (count &lt; 0) &#123; count = 0; ans = i; &#125; &#125; count = 0; for (auto i : numbers) &#123; if (ans == i) count ++; &#125; return count &gt; numbers.size() / 2 ? ans : 0; &#125;&#125;; 最小的k个数 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 12345678910111213141516171819202122232425262728293031// 堆排序思路class Solution &#123;public: void heapfy(vector&lt;int&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int small = index; if (left &lt; max &amp;&amp; nums[left] &lt; nums[small]) small = left; if (right &lt; max &amp;&amp; nums[right] &lt; nums[small]) small = right; if (small != index) &#123; swap(nums[index], nums[small]); heapfy(nums, small, max); &#125; &#125; void helper(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; ret, int k) &#123; int len = nums.size(); for (int i = len / 2; i &gt;= 0; i--) heapfy(nums, i, len); for (int i = len - 1; i &gt;= 0 &amp;&amp; ret.size() &lt; k; i--) &#123; ret.push_back(nums[0]); swap(nums[0], nums[i]); heapfy(nums, 0, i); &#125; &#125; vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; int len = input.size(); vector&lt;int&gt; ret; if (k &gt; len) return ret; helper(input, ret, k); return ret; &#125;&#125;; 连续子数组的最大和 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) 思路：dp[i] = dp[i - 1] + a[i] (&gt;=0), 0 (&lt;0) 12345678910111213class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if (array.empty()) return 0; int ret = array[0], ans = array[0]; for (int i = 1; i &lt; array.size(); i++) &#123; ans += array[i]; ret = max(ret, ans); if (ans &lt; 0) ans = 0; &#125; return ret; &#125;&#125;; 整数中1出现的次数(*) 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 1234567891011121314151617181920class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; int len = floor(log10(n)) + 1; char str[100]; sprintf(str, "%d", n); for (int i = 0; i &lt; len; i++) &#123; int temp = str[len - 1 - i] - '0'; // 每次加的是该位为1的一共有多少个数 if (temp == 0) count += n / (int)pow(10, i + 1) * pow(10, i); // 比如123'0'1, 就有123*10个十位为1的数, 从00010到12210一共有123*10个数 else if (temp == 1) count += n / (int)pow(10, i + 1) * pow(10, i) + n % (int)pow(10, i) + 1; // 比如123'1'1, 从0到12210就有123*10个数，大于12310就有12311 % 10 = 1个数，再加上12311这一个 else count += (n / (int)pow(10, i + 1) + 1) * pow(10, i); // 比如123'4'1, 就有124*10个十位为1的数，例如0-12341共124*10十位为1的数 &#125; return count; &#125;&#125;; 把数组排成最小的数 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 123456789101112131415class Solution &#123;public: bool static cmp(const int&amp; a, const int&amp; b) &#123; return to_string(a) + to_string(b) &lt; to_string(b) + to_string(a); &#125; string PrintMinNumber(vector&lt;int&gt; numbers) &#123; string ret; if (numbers.empty()) return ret; sort(numbers.begin(), numbers.end(), cmp); for (auto i : numbers) &#123; ret += to_string(i); &#125; return ret; &#125;&#125;; 丑数 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 1234567891011121314151617class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if (index &lt;= 0) return false; if (index == 1) return true; vector&lt;int&gt; dp(index, 1); int t2 = 0, t3 = 0, t5 = 0; for (int i = 1; i &lt; index; i++) &#123; dp[i] = min(dp[t2] * 2, min(dp[t3] * 3, dp[t5] * 5)); // 这里就是标明没有放入数组的最小的乘以(2,3,5)数的角标 if (dp[i] == dp[t2] * 2) t2 ++; if (dp[i] == dp[t3] * 3) t3 ++; if (dp[i] == dp[t5] * 5) t5 ++; &#125; return dp[index - 1]; &#125;&#125;; 数组中的逆序对(*) 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 思路1：字典树和二叉搜索树的思路，记录左右子树分别有多少节点和自己落了多少个数，落到左子树说明右边和根节点都是自己的逆序对，最差情况下是O(n^2)。 123456789101112131415161718192021222324252627282930313233343536373839struct Node &#123; int val; struct Node* left; struct Node* right; int lcount; int rcount; int cnt; Node(int x): val(x), left(NULL), right(NULL), lcount(0), rcount(0), cnt(1) &#123;&#125;&#125;;class Solution &#123;public: long long MOD = 1000000007; long long ret = 0; void helper(Node* root, int val) &#123; if (!root) return; int temp = root-&gt;val; if (temp == val) root-&gt;cnt ++; else if (temp &gt; val) &#123; ret = (((ret % MOD + root-&gt;rcount) % MOD) + root-&gt;cnt) % MOD; root-&gt;lcount ++; if (root-&gt;left) helper(root-&gt;left, val); else root-&gt;left = new Node(val); &#125; else &#123; root-&gt; rcount ++; if (root-&gt;right) helper(root-&gt;right, val); else root-&gt;right = new Node(val); &#125; &#125; int InversePairs(vector&lt;int&gt; data) &#123; if(data.size()&lt;=1) return 0; Node* root = new Node(data[0]); for (int i = 1; i &lt; data.size(); i++) helper(root, data[i]); return ret; &#125;&#125;; 思路2：归并排 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: long long MOD = 1000000007; int InversePairs(vector&lt;int&gt; data) &#123; if(data.size()&lt;=1) return 0; vector&lt;int&gt; copy(data); return InversePairsCore(data,copy,0,data.size()-1); &#125;private: int InversePairsCore(vector&lt;int&gt; &amp;data,vector&lt;int&gt; &amp;copy, int begin, int end) &#123;//合并data的两半段到辅助数组copy中有序 if(begin==end) &#123; copy[end]=data[end]; return 0; &#125; else &#123; int mid=begin+(end-begin)/2; int left=InversePairsCore(copy,data,begin,mid);//使data的左半段有序 int right=InversePairsCore(copy,data,mid+1,end);//使data的右半段有序 int cnt=0; int cpIndex=end; int pre=mid; int post=end; //合并两个有序段，到copy数组 while(pre&gt;=begin &amp;&amp; post&gt;=mid+1) &#123; if(data[pre]&gt;data[post])//每次比较的是两个有序序列 &#123; cnt=(cnt+(post-mid-1+1)) % MOD; copy[cpIndex--]=data[pre]; pre--; &#125; else &#123; copy[cpIndex--]=data[post]; post--; &#125; &#125; for(;pre&gt;=begin;--pre) copy[cpIndex--]=data[pre]; for(;post&gt;=mid+1;--post) copy[cpIndex--]=data[post]; return ((left+right)%MOD+cnt) % MOD; &#125; &#125;&#125;; 数字在排序数组中的次数 统计一个数字在排序数组中出现的次数。 leetcode中的search for a range牛客网的判定稍微有问题, 最后的返回值改成left - low + 1可以过，但是实际是有错误的。 12345678910111213141516171819202122232425262728class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; int len = data.size(); if (len == 0) return 0; int left = 0, right = len - 1; while (left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); // 手推，左端不相等向右移 if (data[mid] &lt; k) left = mid + 1; // 小于等于更新右边界 else right = mid; // 因为有left = mid + 1，所以不会出现left = right - 1的时候left不更新的情况。 &#125; if (data[left] != k) return 0; right = len - 1; int low = left, ret; while (left &lt; right) &#123; // 手推，大于的时候右边界向左移 // 等于的时候保存当前值，然后将左值向右移 int mid = left + ((right - left) &gt;&gt; 1); if (data[mid] &gt; k) right = mid - 1, ret = mid; else left = mid + 1; &#125; return ret - low + 1; &#125;&#125;; singel number iii 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 12345678910111213141516class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int ans = 0; for (auto i : data) &#123; ans ^= i; &#125; // 此处位操作比较关键 int c = ans ^ (ans &amp; (ans - 1)); *num1 = 0, * num2 = 0; for (auto i : data) &#123; if (i &amp; c) *num1 ^= i; else *num2 ^= i; &#125; &#125;&#125;; 和为s的连续正数序列 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 这道题的思路可以参考leetcode 523，也可以参考 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt;&gt; ret; // 双指针法 if (sum &lt; 3) return ret; int ans = 3; int left = 1, right = 2; while (left &lt; ((sum + 1) &gt;&gt; 1) &amp;&amp; right &lt; sum) &#123; while (ans &gt; sum) &#123; ans -= left; left ++; &#125; if (ans == sum) &#123; vector&lt;int&gt; temp; for (int i = left; i &lt;= right; i++) temp.push_back(i); ret.push_back(temp); &#125; right ++; ans += right; &#125; return ret; &#125;&#125;; 我的思路比较数理一点，用sum表示要求的和，比如sum为15的时候，7，8满足条件，7，8之所以满足，是因为 15/2 = 7.5，所以正好左右各取一个数：7和8，就使得和为15。 4,5,6 之所以满足条件，是因为15/3 = 5，正好5可以放在中间，左右再拿一个4和6，所以满足。 因此，对于sum，如果我们想确定它有没有长度为n的连续序列使得这个序列的和等于sum，我们只要算算sum%n，若n是奇数，sum%n == 0，那么就意味着存在这样的序列。而且这个序列的中间那个数就是 sum/n；若n是偶数，sum%n == n/2，也就是说sum除以n的结果是一个以 .5 结尾的数，余数是除数的一半, 那么就意味着这样的序列存在，向两边各延伸n/2就是答案。 这种思路的代码会更简单，但是适用范围很窄，如果把可选的数字换成只能从一个递增数组中选择，就只能用窗口思想了。 12345678910111213141516171819202122class Solution &#123;public: void helper(int left, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; vector&lt;int&gt; temp; for (int i = 0; i &lt; n; i++) &#123; temp.push_back(i + left); &#125; ret.push_back(temp); &#125; vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (sum &lt; 3) return ret; for(int i = 2;i * i &lt;= sum * 2; i++)&#123; if (((i &amp; 1) &amp;&amp; sum % i == 0) || (sum % i) * 2 == i) &#123; int start = (sum / i) - (i - 1) / 2; helper(start, i, ret); &#125; &#125; reverse(ret.begin(), ret.end()); return ret; &#125;&#125;; 左旋转字符串 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 123456789101112class Solution &#123;public: string LeftRotateString(string str, int n) &#123; int len = str.size(); if (!len) return ""; n = (n + len) % len; reverse(str.begin(), str.begin() + n); reverse(str.begin() + n, str.end()); reverse(str.begin(), str.end()); return str; &#125;&#125;; 翻转单词顺序 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 12345678910111213141516171819202122class Solution &#123;public: string ReverseSentence(string str) &#123; if (str.empty()) return str; reverse(str.begin(), str.end()); int index = 0, len = str.size(); for (int i = 0; i &lt; len; i++) &#123; if (str[i] != ' ') &#123; if (index != 0) str[index++] = ' '; // 在单词前面加一个空格 int j = i; while (j &lt; len &amp;&amp; str[j] != ' ') str[index ++] = str[j++]; reverse(str.begin() + index - (j - i), str.begin() + index); i = j; // 加一之后就是空格后一个 &#125; &#125; // str.erase(str.begin() + storeIndex, str.end()); // leetcode还要加上这句 return str; &#125;&#125;; 扑克牌顺子 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。 123456789101112131415161718class Solution &#123;public: bool IsContinuous( vector&lt;int&gt; numbers ) &#123; if (numbers.empty()) return false; int zeros = 0; int gap = 0; int len = numbers.size(); sort(numbers.begin(), numbers.end()); for (int i = 0; i &lt; len; i++) &#123; if (numbers[i] == 0) zeros ++; if (i != 0 &amp;&amp; numbers[i] != numbers[i - 1] + 1 &amp;&amp; numbers[i - 1] != 0) gap += numbers[i] - numbers[i - 1] - 1; if (i != 0 &amp;&amp; numbers[i] != 0 &amp;&amp; numbers[i] == numbers[i - 1]) return false; &#125; return zeros &gt;= gap; &#125;&#125;; 孩子们的游戏(约瑟夫环)【着重看推导】 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 推导过程约瑟夫环详解 1234567891011class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if (!n) return -1; int ret = 0; for (int i = 2; i &lt;= n; i++) &#123; ret = (ret + m) % i; &#125; return ret; &#125;&#125;; 1+2+3+..+n 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 123456789class Solution &#123;public: int Sum_Solution(int n) &#123; int ans = n; // 与的短路作用，如果n==0就结束 ans &amp;&amp; (ans += Sum_Solution(n - 1)); return ans; &#125;&#125;; 不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 首先看十进制是如何做的： 5+7=12，三步走第一步：相加各位的值，不算进位，得到2。第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 1234567891011class Solution &#123;public: int Add(int num1, int num2) &#123; while (num2) &#123; int temp = num1 ^ num2; num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = temp; &#125; return num1; &#125;&#125;; 数组中重复的数字 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 12345678910111213141516171819class Solution &#123;public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate(int numbers[], int length, int* duplication) &#123; for (int i = 0; i &lt; length; i++) &#123; if (numbers[abs(numbers[i])] &lt; 0) &#123; *duplication = abs(numbers[i]); return true; &#125; numbers[numbers[i]] *= -1; &#125; return false; &#125;&#125;; 构建乘积数组 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123; int len = A.size(); if (len == 0) return vector&lt;int&gt;(); vector&lt;int&gt; ret(len, 1); for (int i = 1; i &lt; len; i++) &#123; ret[i] = ret[i - 1] * A[i - 1]; &#125; int temp = 1; for (int i = len - 1; i &gt;= 0; i--) &#123; ret[i] *= temp; temp *= A[i]; &#125; return ret; &#125;&#125;; 删除链表中重复的节点 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 123456789101112131415161718192021222324252627/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if (!pHead) return NULL; int val = pHead-&gt;val; if (pHead-&gt;next) &#123; if (pHead-&gt;next-&gt;val == val) &#123; while (pHead &amp;&amp; pHead-&gt;val == val) pHead = pHead-&gt;next; return deleteDuplication(pHead); &#125; else &#123; pHead-&gt;next = deleteDuplication(pHead-&gt;next); return pHead; &#125; &#125; else return pHead; &#125;&#125;; 正则匹配(重要) 请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool match(char* s, char* p) &#123; int m = 0, n = 0; for (; s[m] != '\0'; m++); for (; p[n] != '\0'; n++); bool dp[m + 1][n + 1]; for (int i = 0; i &lt;= m; i++) &#123; for (int j = 0; j &lt;= n; j++) dp[i][j] = false; &#125; dp[0][0] = true; for (int i = 1; i &lt;= n; i++) // 默认所有p都合法的，所以不会越界，不然要首先检查一下pattern是否满足 if (p[i-1] == '*' &amp;&amp; dp[0][i-2]) dp[0][i] = true; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; // 第j个字符为'*' if (p[j-1] == '*') &#123; // 获得第j-1字符 char ch = p[j-2]; if (ch != '.' &amp;&amp; ch != s[i-1]) dp[i][j] = dp[i][j-2]; // 如果出现无法追加的情况（不相等），只能不匹配ch* else dp[i][j] = (dp[i][j - 2] || dp[i - 1][j] || dp[i - 1][j - 2]); // 剩下或者相等或者是.都可以追加成功 // 前两种为相等的情况：不匹配ch*; 继续追加； // 然后只剩下.*的情况了，这种只需要看前面符不符合就可以 &#125; else &#123; if (p[j-1] == '.' || p[j-1] == s[i-1]) dp[i][j] = dp[i-1][j-1]; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 表示数值的字符串 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 方法一class Solution &#123;public: bool isNumeric(char* string) &#123; int len = 0; while (string[len] != '\0') len ++; if (!len) return false; int m1 = 0, m2 = 0, m3 = 0; for (int i = 0; i &lt; len; i++) &#123; if (m3) &#123; if (string[i] &gt; '9' || string[i] &lt; '0') return false; &#125; else if (m2) &#123; if (string[i] == 'e' || string[i] == 'E') &#123; if (i == len - 1) return false; char temp = string[i + 1]; if (temp != '+' &amp;&amp; temp != '-' &amp;&amp; temp &lt; '0' &amp;&amp; temp &gt; '9') return false; if (temp == '+' || temp == '-') i ++; m3 = 1; &#125; else if (string[i] &gt; '9' || string[i] &lt; '0') &#123; return false; &#125; &#125; else if (m1) &#123; if (string[i] == 'e' || string[i] == 'E') &#123; if (i == len - 1) return false; char temp = string[i + 1]; if (temp != '+' &amp;&amp; temp != '-' &amp;&amp; temp &lt; '0' &amp;&amp; temp &gt; '9') return false; if (temp == '+' || temp == '-') i ++; m3 = 1; &#125; else if ((string[i] &gt; '9' || string[i] &lt; '0') &amp;&amp; string[i] != '.') &#123; return false; &#125; else if (string[i] == '.') m2 = 1; &#125; else &#123; char temp = string[i]; if (temp != '+' &amp;&amp; temp != '-' &amp;&amp; temp &lt; '0' &amp;&amp; temp &gt; '9') return false; m1 = 1; &#125; &#125; return true; &#125;&#125;;// 方法二class Solution &#123;public: bool isNumeric(char* str) &#123; // 标记符号、小数点、e是否出现过 bool sign = false, decimal = false, hasE = false; for (int i = 0; i &lt; strlen(str); i++) &#123; if (str[i] == 'e' || str[i] == 'E') &#123; if (i == strlen(str)-1) return false; // e后面一定要接数字 if (hasE) return false; // 不能同时存在两个e hasE = true; &#125; else if (str[i] == '+' || str[i] == '-') &#123; // 第二次出现+-符号，则必须紧接在e之后 if (sign &amp;&amp; str[i-1] != 'e' &amp;&amp; str[i-1] != 'E') return false; // 第一次出现+-符号，且不是在字符串开头，则也必须紧接在e之后 if (!sign &amp;&amp; i &gt; 0 &amp;&amp; str[i-1] != 'e' &amp;&amp; str[i-1] != 'E') return false; sign = true; &#125; else if (str[i] == '.') &#123; // e后面不能接小数点，小数点不能出现两次 if (hasE || decimal) return false; decimal = true; &#125; else if (str[i] &lt; '0' || str[i] &gt; '9') // 不合法字符 return false; &#125; return true; &#125;&#125;; 字符流中第一个出现的不重复的字符 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 1234567891011121314151617181920212223242526272829class Solution&#123;public: int store[256]; int index = 0; Solution() &#123; memset(store, -1, sizeof(store)); &#125; //Insert one char from stringstream void Insert(char ch) &#123; if (store[ch] == -1) store[ch] = index; else store[ch] = -2; index ++; &#125; //return the first appearence once char in current stringstream char FirstAppearingOnce() &#123; int ret_index = INT_MAX; char ret = '\0'; for (int i = 0; i &lt; 256; i++) &#123; if (store[i] &gt;= 0 &amp;&amp; ret_index &gt; store[i]) &#123; ret_index = store[i]; ret = (char) i; &#125; &#125; if (ret == '\0') return '#'; else return ret; &#125;&#125;; 链表中的入口节点 一个链表中包含环，请找出该链表的环的入口结点。 12345678910111213141516171819202122232425262728293031/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (!pHead) return NULL; if (!pHead-&gt;next) return NULL; ListNode* p1 = pHead; ListNode* p2 = pHead; while (p2 != NULL &amp;&amp; p2-&gt;next != NULL) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; if (p1 == p2) &#123; p1 = pHead; while (p1 != p2) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; return p1; &#125; &#125; return NULL; &#125;&#125;; 二叉树的下一个节点 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 12345678910111213141516171819202122232425262728293031323334353637383940414243/*struct TreeLinkNode &#123; int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeLinkNode* GetNext(TreeLinkNode* pNode) &#123; if (pNode == NULL) return NULL; TreeLinkNode* pre = pNode-&gt;next; if (pre == NULL) &#123; // 根节点 TreeLinkNode* temp = pNode-&gt;right; if (!temp) return temp; while (temp-&gt;left) &#123; temp = temp-&gt;left; &#125; return temp; &#125; if (pre-&gt;left == pNode) &#123; // 自己是左节点 if (pNode-&gt;right == NULL) return pre; return pNode-&gt;right; &#125; else &#123; // 自己是右节点 if (pNode-&gt;right != NULL) return pNode-&gt;right; while (pre-&gt;next != NULL) &#123; TreeLinkNode* temp = pre-&gt;next; if (temp-&gt;left == pre) return temp; pre = temp; &#125; &#125; return NULL; &#125;&#125;; 按之字形顺序打印二叉树 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;// 用栈而不是队列做bfspublic: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (!pRoot) return ret; stack&lt;TreeNode*&gt; cur; int dir = 1; cur.push(pRoot); while (true) &#123; vector&lt;int&gt; ans; stack&lt;TreeNode*&gt; next; while (!cur.empty()) &#123; ans.push_back(cur.top()-&gt;val); auto temp = cur.top(); cur.pop(); if (dir) &#123; if (temp-&gt;left) next.push(temp-&gt;left); if (temp-&gt;right) next.push(temp-&gt;right); &#125; else &#123; if (temp-&gt;right) next.push(temp-&gt;right); if (temp-&gt;left) next.push(temp-&gt;left); &#125; &#125; ret.push_back(ans); if (next.empty()) break; dir ^= 1; cur = next; &#125; return ret; &#125; &#125;; 序列化二叉树 请实现两个函数，分别用来序列化和反序列化二叉树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void helper(TreeNode* root, vector&lt;int&gt;&amp; buf) &#123; if (!root) &#123; buf.push_back(INT_MAX); return; &#125; buf.push_back(root-&gt;val); helper(root-&gt;left, buf); helper(root-&gt;right, buf); &#125; char* Serialize(TreeNode *root) &#123; vector&lt;int&gt; buf; helper(root, buf); int len = buf.size(); int* temp = new int[len]; for (int i = 0; i &lt; len; i++) &#123; temp[i] = buf[i]; &#125; return (char*) temp; &#125; TreeNode* helper1(int*&amp; s) &#123; if (*s == INT_MAX) &#123; s++; return NULL; &#125; TreeNode* ret = new TreeNode(*s); s ++; ret-&gt;left = helper1(s); ret-&gt;right = helper1(s); return ret; &#125; TreeNode* Deserialize(char *str) &#123; int *p = (int*) str; return helper1(p); &#125;&#125;; 二叉搜索树的第k个节点 给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / \ 3 7 /\ /\ 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 1234567891011121314151617181920212223242526/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* helper(TreeNode* root, int&amp; ans) &#123; if (root) &#123; auto temp = helper(root-&gt;left, ans); return !ans ? temp : (ans -- == 1 ? root : helper(root-&gt;right, ans)); &#125; return NULL; &#125; TreeNode* KthNode(TreeNode* pRoot, int k) &#123; return helper(pRoot, k); &#125; &#125;; 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 12345678910111213141516171819class Solution &#123;public: priority_queue&lt;int&gt; small, large; // 优先级队列 void Insert(int num) &#123; small.push(num); large.push(-small.top()); small.pop(); if (small.size() &lt; large.size()) &#123; small.push(-large.top()); large.pop(); &#125; &#125; double GetMedian() &#123; return small.size() &gt; large.size() ? small.top() : (small.top() - large.top()) / 2.0; &#125;&#125;; 滑动窗口最大值 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) &#123; int len = (long long)size; int n = num.size(); if (!len) return vector&lt;int&gt;(); deque&lt;int&gt; d; vector&lt;int&gt; ret; for (int i = 0; i &lt; n; i++) &#123; while (!d.empty() &amp;&amp; num[d.back()] &lt;= num[i]) d.pop_back(); d.push_back(i); while (!d.empty() &amp;&amp; d.front() &lt;= i - len) d.pop_front(); if (i &gt;= len - 1) ret.push_back(num[d.front()]); &#125; return ret; &#125;&#125;; 矩阵中的路径 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int m, n; bool helper(char* matrix, const char* s, int x, int y) &#123; if (*s == '\0') return true; if (x &lt; 0 || x &gt;= m || y &gt;= n || y &lt; 0) return false; char temp = matrix[x * n + y]; if (*s != temp) return false; matrix[x * n + y] = '\0'; if (helper(matrix, s + 1, x + 1, y) || helper(matrix, s + 1, x, y + 1) || helper(matrix, s + 1, x - 1, y) || helper(matrix, s + 1, x, y - 1)) return true; matrix[x * n + y] = temp; return false; &#125; bool hasPath(char* matrix, int rows, int cols, char* str) &#123; m = rows, n = cols; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (helper(matrix, str, i, j)) return true; &#125; &#125; return false; &#125;&#125;; 机器人的运动范围 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int m, n, k; bool check(int x, int y) &#123; int ans = 0; while (x) &#123; ans += x % 10; x /= 10; &#125; while (y) &#123; ans += y % 10; y /=10; &#125; return ans &gt; k; &#125; void helper(int x, int y, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int&amp; ret) &#123; if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || visited[x][y] || check(x, y)) return; ret ++; visited[x][y] = true; int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; for (int i = 0; i &lt; 4; i++) &#123; helper(x + a[i], y + b[i], visited, ret); &#125; &#125; int movingCount(int threshold, int rows, int cols) &#123; m = rows, n = cols, k = threshold; if (m &lt; 0 || n &lt; 0) &#123; return 0; &#125; vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false)); int ret = 0; helper(0, 0, visited, ret); return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>算法</tag>
        <tag>总结</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeM 2018 资格赛]]></title>
    <url>%2F2018%2F06%2F09%2FcodeM-2018-qualify%2F</url>
    <content type="text"><![CDATA[去年没参加，今年抽空参加一下，因为没什么时间，六道题中就做了4题，剩下两题出来有空再更新具体详情可以参考参赛地址 2018-6-12官方更新了解题方法，如果想验证请尝试验证地址 A 下单题目：美团在吃喝玩乐等很多方面都给大家提供了便利。最近又增加了一项新业务：小象生鲜。这是新零售超市，你既可以在线下超市门店选购生鲜食品，也可以在手机App上下单，最快30分钟就配送到家。 新店开张免不了大优惠。我们要在小象生鲜超市里采购n个物品，每个物品价格为ai，有一些物品可以选择八折优惠（称为特价优惠）。 有m种满减优惠方式，满减优惠方式只有在所有物品都不选择特价优惠时才能使用，且最多只可以选择最多一款。 每种满减优惠描述为(bi,ci)，即满bi减ci（当消费&gt;=bi时优惠ci）。 求要买齐这n个物品（必须一单买齐），至少需要多少钱（保留两位小数）。 输入描述: 第一行，两个整数n,m。接下来n行，每行一个正整数ai，以及一个0/1表示是否可以选择特价优惠（1表示可以）。接下来m行，每行两个正整数bi,ci，描述一款满减优惠。 1 &lt;= n,m &lt;=101 &lt;= ai &lt;= 1001 &lt;= ci &lt; bi &lt;= 1000 输出描述:一行一个实数，表示至少需要消耗的钱数（保留恰好两位小数）。 示例1输入 12342 1 6 1 10 1 12 2 输出112.80 示例2输入123452 2 6 1 10 1 5 1 16 6 输出110.00 思路暴力枚举…. 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;stdio.h&gt;using namespace std;double helper(vector&lt;pair&lt;double, double&gt;&gt;&amp; nums, vector&lt;pair&lt;double, double&gt;&gt;&amp; rule) &#123; double ans = 0; double ret = 0; for (auto i : nums) &#123; ans += i.first; ret += i.second == 1.0 ? i.first * 0.8 : i.first; &#125; for (auto i : rule) &#123; if (i.first &lt;= ans) &#123; ret = ret &gt; (ans - i.second) ? (ans - i.second) : ret; &#125; &#125; return ret;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;pair&lt;double, double&gt;&gt; nums, rule; for (int i = 0; i &lt; n; i++) &#123; double a, b; cin &gt;&gt; a &gt;&gt; b; nums.push_back(make_pair(a, b)); &#125; for (int i = 0; i &lt; m; i++) &#123; double a, b; cin &gt;&gt; a &gt;&gt; b; rule.push_back(make_pair(a, b)); &#125; printf("%.2f\n", helper(nums, rule)); return 0;&#125; B 可乐题目描述小美和小团最近沉迷可乐。可供TA们选择的可乐共有k种，比如可口可乐、零度可乐等等，每种可乐会带给小美和小团不同的快乐程度。TA们一共要买n瓶可乐，每种可乐可以买无限多瓶，小美会随机挑选其中的m瓶喝，剩下的n-m瓶小团喝。请问应该如何购买可乐，使得小美和小团得到的快乐程度的和的期望值最大？现在请求出购买可乐的方案。 输入描述: 第一行三个整数n，m，k分别表示要买的可乐数、小美喝的可乐数以及可供选择的可乐种数。接下来k行，每行两个整数a，b分别表示某种可乐分别给予小美和小团的快乐程度。对于所有数据，1 &lt;= n &lt;= 10,000, 0 &lt;= m &lt;= n, 1 &lt;= k &lt;= 10,000, -10,000 &lt;= a, b &lt;= 10,000 输出描述: 一行k个整数，第i个整数表示购买第i种可乐的数目。如果有多解，请输出字典序最小的那个。对于两个序列 a1, a2, …, ak, b1, b2, …, bk，a的字典序小于b，当且仅当存在一个位置i &lt;= k满足：ai &lt; bi且对于所有的位置 j &lt; i，aj = bj； 思路：根据快乐程度的公式可以知道 \sum\limits_{i=1}^{n} (a_{i} w_{a} / w) n_{i} + (b_{i} w_{b} / w) n_{i} = A n_{i} + B n_{i} = (A + B) n_{i}所以这是个线性关系，要求全买其中一瓶可乐哪个最大。 官方解答： 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;using namespace std;void helper(vector&lt;pair&lt;double, double&gt;&gt;&amp; nums, int n, int m) &#123; double ret = -10E9; int index = -1; int len = nums.size(); for (int i = 0; i &lt; len; i++) &#123; auto temp = nums[i]; double ans = temp.first * m / n + temp.second * (n - m) / n; if (ret &lt;= ans) &#123; ret = ans; index = i; &#125; &#125; if (nums.empty()) return; if (index == 0) cout &lt;&lt; n; else cout &lt;&lt; "0"; for (int i = 1; i &lt; len; i++) &#123; if (i == index) &#123; cout &lt;&lt; " " &lt;&lt; n; &#125; else cout &lt;&lt; " 0"; &#125; cout &lt;&lt; endl;&#125;int main () &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; vector&lt;pair&lt;double, double&gt;&gt; nums; for (int i = 0; i &lt; k; i++) &#123; double a, b; cin &gt;&gt; a &gt;&gt; b; nums.push_back(make_pair(a, b)); &#125; helper(nums, n, m); return 0;&#125; C 世界杯 题意：给16支球队互相胜利的概率，问每支球队获胜的概率。 题目描述世界杯就要开始啦！真真正正的战斗从淘汰赛开始，现在我们给出球队之间的胜负概率，来预测每支球队夺冠的可能性。在接下来的篇幅中，我们将简单介绍淘汰赛阶段的规则。淘汰赛阶段的90分钟常规时间内（含补时阶段）进球多的球队取胜，如果参赛双方在90分钟内（含补时阶段）无法决出胜负，将进行上下半场各15分钟的加时赛。加时赛阶段，如果两队仍未分出胜负，则通过点球大战决出胜者。也就是说，每场比赛，有且仅有一个队能够晋级到下一轮。淘汰赛共有16支球队参加（小组赛阶段共分8个小组，每组前两名晋级），对阵安排如下。1/8决赛A组第一对阵B组第二=胜者1B组第一对阵A组第二=胜者2C组第一对阵D组第二=胜者3D组第一对阵C组第二=胜者4E组第一对阵F组第二=胜者5F组第一对阵E组第二=胜者6G组第一对阵H组第二=胜者7H组第一对阵G组第二=胜者8获胜的8个队进入1/4决赛，即所谓“8强”1/4决赛胜者1对阵胜者3=胜者A胜者2对阵胜者4=胜者B胜者5对阵胜者7=胜者C胜者6对阵胜者8=胜者D1/4决赛的4个获胜队进入“4强”半决赛胜者A对阵胜者C胜者B对阵胜者D半决赛获胜两队进入决赛，失利的两队争夺三名决赛获胜的队伍就是最后的冠军！ 输入描述:球队会被以1..16进行标号，其分别表示：1 A组第一；2 B组第二；3 C组第一；4 D组第二；5 E组第一；6 F组第二；7 G组第一；8 H组第二；9 B组第一；10 A组第二；11 D组第一；12 C组第二；13 F组第一；14 E组第二；15 H组第一；16 G组第二。 数据共有16行，每行16个浮点数，第i行第j列的数Fi,j表示i和j进行比赛时i获胜（包括常规时间获胜、加时赛获胜以及点球大战获胜）的概率。对于1 &lt;= i, j &lt;= 16 且 i != j, 满足0 &lt;= Fi,j &lt;= 1, Fi,j + Fj,i = 1；对于1 &lt;= i &lt;= 16, 满足 Fi,i = 0。 输出描述:输出一行16个浮点数，用空格隔开，分别表示每只球队获得世界杯的概率，结尾无空格。绝对误差或相对误差在1e-5之内的解会被判为正确。 输入123456789101112131415160.000 0.133 0.210 0.292 0.670 0.270 0.953 0.353 0.328 0.128 0.873 0.082 0.771 0.300 0.405 0.4550.867 0.000 0.621 0.384 0.934 0.847 0.328 0.488 0.785 0.308 0.158 0.774 0.923 0.261 0.872 0.9240.790 0.379 0.000 0.335 0.389 0.856 0.344 0.998 0.747 0.895 0.967 0.383 0.576 0.943 0.836 0.5370.708 0.616 0.665 0.000 0.146 0.362 0.757 0.942 0.596 0.903 0.381 0.281 0.294 0.788 0.804 0.6550.330 0.066 0.611 0.854 0.000 0.687 0.983 0.217 0.565 0.293 0.256 0.938 0.851 0.487 0.190 0.6800.730 0.153 0.144 0.638 0.313 0.000 0.832 0.526 0.429 0.707 0.414 0.617 0.925 0.638 0.526 0.5450.047 0.672 0.656 0.243 0.017 0.168 0.000 0.357 0.125 0.307 0.879 0.551 0.641 0.959 0.981 0.4650.647 0.512 0.002 0.058 0.783 0.474 0.643 0.000 0.325 0.494 0.893 0.064 0.563 0.429 0.501 0.8720.672 0.215 0.253 0.404 0.435 0.571 0.875 0.675 0.000 0.940 0.053 0.329 0.232 0.280 0.359 0.4740.872 0.692 0.105 0.097 0.707 0.293 0.693 0.506 0.060 0.000 0.040 0.776 0.589 0.704 0.018 0.9680.127 0.842 0.033 0.619 0.744 0.586 0.121 0.107 0.947 0.960 0.000 0.486 0.266 0.662 0.374 0.6980.918 0.226 0.617 0.719 0.062 0.383 0.449 0.936 0.671 0.224 0.514 0.000 0.821 0.027 0.415 0.2270.229 0.077 0.424 0.706 0.149 0.075 0.359 0.437 0.768 0.411 0.734 0.179 0.000 0.841 0.409 0.1580.700 0.739 0.057 0.212 0.513 0.362 0.041 0.571 0.720 0.296 0.338 0.973 0.159 0.000 0.935 0.7650.595 0.128 0.164 0.196 0.810 0.474 0.019 0.499 0.641 0.982 0.626 0.585 0.591 0.065 0.000 0.7610.545 0.076 0.463 0.345 0.320 0.455 0.535 0.128 0.526 0.032 0.302 0.773 0.842 0.235 0.239 0.000 输出10.0080193239 0.1871963989 0.0797523190 0.1233859685 0.0836167329 0.0438390981 0.0079035829 0.0604644891 0.0237087902 0.0050549016 0.1149551151 0.0679247259 0.0511307364 0.0395744604 0.0800843771 0.0233889799 思路16支球队组成一颗4层的二叉树，求每支球队到达根的概率。 官方思路 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;double nums[17][17];double dp[37][17];void helper(int n) &#123; if (n &gt;= 16) &#123; dp[n][n - 16] = 1.0; &#125; else &#123; helper(n &lt;&lt; 1); helper(n &lt;&lt; 1 | 1); for (int i = 0; i &lt; 16; i++) &#123; for (int j = 0; j &lt; 16; j++) &#123; dp[n][i] += nums[i][j] * dp[n &lt;&lt; 1][i] * dp[n &lt;&lt; 1 | 1][j]; dp[n][j] += nums[j][i] * dp[n &lt;&lt; 1][i] * dp[n &lt;&lt; 1 | 1][j]; &#125; &#125; &#125;&#125;int main() &#123; memset(dp, 0.0, sizeof(dp)); for (int i = 0; i &lt; 16; i++) &#123; for (int j = 0; j &lt; 16; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; helper(1); cout &lt;&lt; dp[1][0]; for (int i = 0; i &lt; 16; i++) &#123; cout &lt;&lt; " " &lt;&lt; dp[1][i]; &#125; cout &lt;&lt; endl; return 0;&#125; D 出线题目描述小胖参加了人生中最重要的比赛——MedoC 资格赛。MedoC 的资格赛由 m 轮构成，使用常见的 “加权标准分” 的规则。每位选手需要参加所有的 m 轮的比赛。在一轮中，能取得的分数为自己的成绩除掉最高分的成绩。每个选手的总分为每一轮获得的分数乘上这一轮比赛占得比重。如果在某一轮比赛中所有人获得了零分，那么所有选手在这一轮获得的分数都为 0 分。比如说，资格赛一共 3 轮，三轮的权重分别为 30%, 30%, 40%。在第一轮中，小胖获得了 300 分，最高分也为 300 分。在第二轮中，小胖获得了 0 分，最高分也为 0 分。在第三轮中，小胖获得了 150 分，最高分为 300 分，那么小胖的总分为 (300/300)30%+030%+(150/300)*40%=0.5。一共有 n 位选手参加了比赛，其中成绩最高的 k 位选手能够晋级到初赛。如果有多人在分数线上同分，那么系统会随机在这些同分的人中选取，选满 k 个晋级为止。小胖现在知道了每个选手每场比赛的成绩，但是由于他的疏忽，其中的某个人某场比赛的成绩消失了。所以更多人出线的情况变得未知起来。现在只知道成绩一定是 0 到 C 之间的一个整数（包含 0 和 C）。小胖想知道对于每个人的出线情况是怎么样的，也就是一定能出线，一定不能出线还是有可能出线。 输入描述:第一行四个正整数 n,m,k,C (m &lt;= 6, k &lt;= n &lt;= 500, C &lt;= 500)。接下来一行 m 个整数 w1, w2, …, wm，表示每场比赛的权重，第 i 场比赛的权重为 wi/(w1+w2+…+wm)，保证 wi &gt;= 0 且 1 &lt;= w1 + w2 + … + wm &lt;= 1000。接下来 n 行每行 m 个整数，第 i 个整数表示这个选手在第 i 场比赛中获得的成绩。如果这个数字为 - 1 表示这个数据丢失，保证恰好有一个 - 1。 输出描述:n 行每行输出一个 1 到 3 之间的整数。1 表示一定出线，2 表示一定不出线，3 表示可能出线。 思路这题如果看清楚题意与数据范围真的不难, 因为 - 1 只有一个, 从 0~C 枚举即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;void helper(vector&lt;vector&lt;long long&gt;&gt;&amp; nums, vector&lt;long long&gt; w, const int n, const int m, const int k, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; vector&lt;long long&gt; score(n, 0); vector&lt;long long&gt; mark(n, 0); vector&lt;long long&gt; max_score(m, 0); vector&lt;long long&gt; ans(m, 1); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; max_score[i] = max_score[i] &lt; nums[j][i] ? nums[j][i] : max_score[i]; &#125; if (max_score[i] == 0) &#123; max_score[i] = 1; &#125; &#125; // 直接将所有max_score连称会溢出 for (int i = 0; i &lt; m; i++) &#123; ans[i] = w[i]; for (int j = 0; j &lt; m; j++) &#123; if (j != i) ans[i] *= max_score[j]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; score[i] += nums[i][j] * ans[j]; &#125; mark[i] = score[i]; &#125; sort(mark.begin(), mark.end(), greater&lt;long long&gt;()); for (int i = 0; i &lt; n; i++) &#123; if (mark[k-1] &lt;= score[i]) ret[0][i] ++; // 胜利的局数 if (k != n &amp;&amp; mark[k] &gt;= score[i]) ret[1][i] ++; // 失败的局数 &#125;&#125;int main() &#123; int n, m, k, C; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; C; vector&lt;long long&gt; w(m, 0); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; w[i]; &#125; int x, y; vector&lt;vector&lt;long long&gt;&gt; nums(n, vector&lt;long long&gt;(m, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; nums[i][j]; if (nums[i][j] == -1) x = i, y = j; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; ret(2, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt;= C; i++) &#123; nums[x][y] = i; helper(nums, w, n, m, k, ret); &#125; for (int i = 0; i &lt; n; i++) &#123; if (ret[1][i] == 0) cout &lt;&lt; 1 &lt;&lt; endl; else if (ret[0][i] == 0) cout &lt;&lt; 2 &lt;&lt; endl; else cout &lt;&lt; 3 &lt;&lt; endl; &#125; return 0;&#125; E 你的城市题目描述2018年第一季度，美团旅行的酒店业务以5770万的订单总量，成为行业第一名。与此同时，美团旅行也提供机票、火车票、船票等各种服务，不断开辟新的目的旅游城市。最近新开的目的地，就包括对小A有特殊意义的偏僻小城C。“我来到 你的城市 熟悉的那一条街。”小A哼着歌，从北京出发，要去C城。这对他非常重要，必须当天到达，虽然交通并不是非常方便。但是，错过火车并不是一个小概率事件。为了保险起见，小A决定选择一个即使错过火车也存在补救措施的交通方案。（即假使未赶上原方案中的任何一班火车，依然可以改乘其他的车次能够在当天到达C城，但同时小A是一个乐观主义者，所以他认为改乘以后的所有车次都不会延误。）当然了，在满足上述条件的情况下，小A希望花费的钱越少越好（只考虑计划中的，不考虑发生意外时换乘带来的代价）。城市及交通网可以看做一张n个点m条边的有向图。每个点代表一个城市（1号点代表北京，n号点代表C城）。每条边由一个五元组组成，表示存在一个车次，由ts时刻从城市x出发，在td时刻到达城市y，且花费为c元。为了简化问题，ts，td均为以半小时为基本单位（具体格式见样例及Hint）。并假设每次中转最少需要花费半个小时，且中转只能发生在同一城市（即到达一个城市距离再次从这个城市出发至少需要间隔半个小时），注意，小 A 如果因为没赶上车次需要改乘，也需要半个小时的时间。问小A到达C城最少需要花费多少钱（行程必须在这一天内完成，可以在0:00上车，也可以在24:00到达）。 输入描述:第一行，两个正整数n, m。n表示城市数量，m表示当天不同班次的火车数量。接下来m行，每行3个整数x, y, c加两个字符串ts, td，均以空格作为分隔，表示当天的某一班火车。其中x, y, c, ts, td的含义如前描述。所有的车次都是当天的，没有隔夜的票。2 &lt;= n &lt;= 500, m &lt;= 15000, c &lt;= 1000, ts &lt; td，所有数均为正整数。车次保证不过夜，时间范围0:00, 0:30, 1:00, … , 23:00, 23:30, 24:00，可能存在重复车次。 输出描述:一个整数，表示存在补救措施的前提下，小A到达C城的最小花费。如果不存在这样的路径，则输出-1。 示例1输入1234563 51 3 800 18:00 21:001 2 650 13:30 14:002 3 100 14:00 18:002 3 300 14:30 19:002 3 200 15:00 19:30 输出1950 说明选择第二个和第四个车次。第三个车次由于中转时间太短无法选择。第五个车次由于没有可改乘的航班无法选择。如果错过第二个车次，可以改乘第一个车次。如果错过第四个车次，可以改乘第五个车次。 示例2输入1234563 51 2 1000 0:00 12:001 2 100 0:30 14:001 2 100 0:30 15:002 3 300 16:00 24:002 3 200 16:30 24:00 输出11300 说明选择第一个和第四个车次。不能选择第二个车次是因为，如果错过了0:30的车次2，那么同样在0:30出发的车次3也是来不及改乘的。 示例3输入123453 41 2 100 0:30 14:001 2 200 0:30 15:002 3 300 16:00 24:002 3 200 16:30 24:00 输出1-1 说明和样例二类似，但是缺少了原先的车次一，所以没有换乘方案。 示例4输入123453 41 2 100 0:30 14:001 2 200 1:00 16:002 3 300 16:00 24:002 3 200 16:30 24:00 输出1400 说明选择第一个和第三个车次。 示例5输入123453 41 2 100 0:30 14:001 2 200 1:00 16:302 3 300 16:00 24:002 3 200 16:30 24:00 输出1-1 说明和样例四类似，但假如错过了第一个车次，改乘车次二在16:30到达城市2是不足以赶上16:30出发的车次四的。 D 匹配题目描述美团外卖日订单已经超过2000万，背后有一个非常复杂的智能调度系统。我们考虑一个简化的情形，有n个外卖小哥要去 n 家商店取货，第 i 个外卖小哥到达商店 j 需要时间 e[i][j] 。现在有 m 对外卖小哥和商店的合作关系。假定每个外卖小哥只能取到一个货物，每个商店只需要一位外卖小哥取货。询问最少多少时间，能有 k 位外卖小哥到达 k 个商店取到货物？对于每个 k ，都输出一个数表示最少使用时间，如果无解输出 -1。 输入描述:第一行输入两个整数 n , m （1 &lt;= n &lt;= 1000 , 1 &lt;= m &lt;= 100000）。接下来 m 行，每行输入 3 个整数 i , j , e[i][j] (1 &lt;= i, j &lt;= n , 0 &lt;= e[i][j] &lt;= 10^9)，定义如题所述。注：本题测试用例较多，请耐心等待判题结果，也可以去排行榜刷新查看自己的提交结果。 输出描述:输出一行n个整数，第 i 个整数，表示当 k=i 时，需要的最少时间，如果无解输出-1，结尾无空格。 示例1输入123456783 71 3 52 3 23 1 71 2 02 3 23 2 02 1 5 输出0 2 5]]></content>
      <tags>
        <tag>算法</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deeplearning.ai 笔记作业（一）week4]]></title>
    <url>%2F2018%2F05%2F21%2Fdeeplearning-ai-nn-and-dl-week4%2F</url>
    <content type="text"><![CDATA[第一章 神经网络和深度学习 week4 笔记L层深层神经网络如下图就是一个深层神经网络，相比而言，逻辑回归就是一个浅层的神经网络。 L表示神经网络的层数，L=4，n[1]=5，n[2]=5，n[3]=3，n[4]=1 a[L] = activation in Layer La[L] = g[L](z[L])，W[L]= weight for Z[L] 神经网络的前向传播就如上图所示： Input: a[l-1]Output: a[l], z[l]notes: 通过神经网络训练过程可以发现，z[l]在反向传播的过程中也可以利用，所以输出的z[l]以cache(z[l])保存 单层计算：z[l]=W[l]a[l-1]+b[l]a[l]=g[l](z[l]) 矢量化计算：Z[l]=W[l]A[l-1]+b[l]A[l]=g[l](Z[l]) 矢量化时保证矩阵维度正确（重要）通过观察得出：W[l]: (n[l], n[l-1])b[l]: (n[l], 1)dW[l]: (n[l], n[l-1])db[l]: (n[l], 1)Z[l]: (n[l], m)A[l]: (n[l], m)dZ[l]: (n[l], m)dA[l]: (n[l], m) 前向传播与反向传播前向传播图示：反向传播图示： 为什么使用深层表示 以下内容的表达参考自cnblogs 直观理解深层网络。上图所示是一个人脸识别的过程，具体的实现步骤如下： 通过深层神经网络首先会选取一些边缘信息，例如脸形，眼框，总之是一些边框之类的信息(我自己的理解是之所以先找出边缘信息是为了将要观察的事物与周围环境分割开来)，这也就是第一层的作用。 找到边缘信息后，开始放大，将信息聚合在一起。例如找到眼睛轮廓信息后，通过往上一层汇聚从而得到眼睛的信息；同理通过汇聚脸的轮廓信息得到脸颊信息等等 在第二步的基础上将各个局部信息(眼睛、眉毛……)汇聚成一张人脸，最终达到人脸识别的效果。 同样的过程也可以用来表示声音识别过程：一个声音分割成一个一个的片段，然后再选取单个发音（例如C,A,T），然后再组合成单词（CAT），最后在聚合成一个句子或单词。 为什么用深层神经网络而不用浅层神经网络有一个电路原理，就是说由小的网络单元组成的深层电路往往比浅层电路需要更多的元器件。比如X1XOR X2XOR X3XOR…Xn如果是深层网络，只需要O(logn)的数量级，但是如果使用浅层网络的话，就需要遍历所有的情况设置真值表，需要O(2n-1)。转化成神经网络，要达到相同的目的，浅层网络需要比深层网络更多地神经元个数。 构建深层神经网络块前向传播：反向传播：标准流程： 参数与超参数参数：W[l]，b[l]超参数： 学习速率 迭代次数 隐藏层数 神经元个数 激活函数的选择 minibatch size 正则化方法 momentum 所以，对于资深的算法工程师，随着计算资源的不断迭代，适时调整自己的超参数可能会取得更好地结果。 作业课堂的小quiz可以点击下载 Building your Deep Neural Network: Step by StepWelcome to your week 4 assignment (part 1 of 2)! You have previously trained a 2-layer Neural Network (with a single hidden layer). This week, you will build a deep neural network, with as many layers as you want! In this notebook, you will implement all the functions required to build a deep neural network. In the next assignment, you will use these functions to build a deep neural network for image classification. After this assignment you will be able to: Use non-linear units like ReLU to improve your model Build a deeper neural network (with more than 1 hidden layer) Implement an easy-to-use neural network class Notation: Superscript $[l]$ denotes a quantity associated with the $l^&#123;th&#125;$ layer. Example: $a^&#123;[L]&#125;$ is the $L^&#123;th&#125;$ layer activation. $W^&#123;[L]&#125;$ and $b^&#123;[L]&#125;$ are the $L^&#123;th&#125;$ layer parameters. Superscript $(i)$ denotes a quantity associated with the $i^&#123;th&#125;$ example. Example: $x^&#123;(i)&#125;$ is the $i^&#123;th&#125;$ training example. Lowerscript $i$ denotes the $i^&#123;th&#125;$ entry of a vector. Example: $a^&#123;[l]&#125;_i$ denotes the $i^&#123;th&#125;$ entry of the $l^&#123;th&#125;$ layer’s activations). Let’s get started! 1 - PackagesLet’s first import all the packages that you will need during this assignment. numpy is the main package for scientific computing with Python. matplotlib is a library to plot graphs in Python. dnn_utils provides some necessary functions for this notebook. testCases provides some test cases to assess the correctness of your functions np.random.seed(1) is used to keep all the random function calls consistent. It will help us grade your work. Please don’t change the seed. 123456789101112131415import numpy as npimport h5pyimport matplotlib.pyplot as pltfrom testCases_v4 import *from dnn_utils_v2 import sigmoid, sigmoid_backward, relu, relu_backward%matplotlib inlineplt.rcParams['figure.figsize'] = (5.0, 4.0) # set default size of plotsplt.rcParams['image.interpolation'] = 'nearest'plt.rcParams['image.cmap'] = 'gray'%load_ext autoreload%autoreload 2np.random.seed(1) /opt/conda/lib/python3.5/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment. warnings.warn(&#39;Matplotlib is building the font cache using fc-list. This may take a moment.&#39;) /opt/conda/lib/python3.5/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment. warnings.warn(&#39;Matplotlib is building the font cache using fc-list. This may take a moment.&#39;) 2 - Outline of the AssignmentTo build your neural network, you will be implementing several “helper functions”. These helper functions will be used in the next assignment to build a two-layer neural network and an L-layer neural network. Each small helper function you will implement will have detailed instructions that will walk you through the necessary steps. Here is an outline of this assignment, you will: Initialize the parameters for a two-layer network and for an $L$-layer neural network. Implement the forward propagation module (shown in purple in the figure below). Complete the LINEAR part of a layer’s forward propagation step (resulting in $Z^&#123;[l]&#125;$). We give you the ACTIVATION function (relu/sigmoid). Combine the previous two steps into a new [LINEAR-&gt;ACTIVATION] forward function. Stack the [LINEAR-&gt;RELU] forward function L-1 time (for layers 1 through L-1) and add a [LINEAR-&gt;SIGMOID] at the end (for the final layer $L$). This gives you a new L_model_forward function. Compute the loss. Implement the backward propagation module (denoted in red in the figure below). Complete the LINEAR part of a layer’s backward propagation step. We give you the gradient of the ACTIVATE function (relu_backward/sigmoid_backward) Combine the previous two steps into a new [LINEAR-&gt;ACTIVATION] backward function. Stack [LINEAR-&gt;RELU] backward L-1 times and add [LINEAR-&gt;SIGMOID] backward in a new L_model_backward function Finally update the parameters. **Figure 1** **Note** that for every forward function, there is a corresponding backward function. That is why at every step of your forward module you will be storing some values in a cache. The cached values are useful for computing gradients. In the backpropagation module you will then use the cache to calculate the gradients. This assignment will show you exactly how to carry out each of these steps. #### 3 - Initialization You will write two helper functions that will initialize the parameters for your model. The first function will be used to initialize parameters for a two layer model. The second one will generalize this initialization process to $L$ layers. ##### 3.1 - 2-layer Neural Network **Exercise**: Create and initialize the parameters of the 2-layer neural network. **Instructions**: - The model's structure is: *LINEAR -> RELU -> LINEAR -> SIGMOID*. - Use random initialization for the weight matrices. Use `np.random.randn(shape)*0.01` with the correct shape. - Use zero initialization for the biases. Use `np.zeros(shape)`. 1234567891011121314151617181920212223242526272829303132333435363738# GRADED FUNCTION: initialize_parametersdef initialize_parameters(n_x, n_h, n_y): """ Argument: n_x -- size of the input layer n_h -- size of the hidden layer n_y -- size of the output layer Returns: parameters -- python dictionary containing your parameters: W1 -- weight matrix of shape (n_h, n_x) b1 -- bias vector of shape (n_h, 1) W2 -- weight matrix of shape (n_y, n_h) b2 -- bias vector of shape (n_y, 1) """ np.random.seed(1) ### START CODE HERE ### (≈ 4 lines of code) # random不要用元组, zeros用元组 W1 = np.random.randn(n_h, n_x) * 0.01 b1 = np.zeros((n_h, 1)) W2 = np.random.randn(n_y, n_h) * 0.01 b2 = np.zeros((n_y, 1)) ### END CODE HERE ### assert(W1.shape == (n_h, n_x)) assert(b1.shape == (n_h, 1)) assert(W2.shape == (n_y, n_h)) assert(b2.shape == (n_y, 1)) parameters = &amp;#123;"W1": W1, "b1": b1, "W2": W2, "b2": b2&amp;#125; return parameters 12345parameters = initialize_parameters(3,2,1)print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) W1 = [[ 0.01624345 -0.00611756 -0.00528172] [-0.01072969 0.00865408 -0.02301539]] b1 = [[ 0.] [ 0.]] W2 = [[ 0.01744812 -0.00761207]] b2 = [[ 0.]] **Expected output**: **W1** [[ 0.01624345 -0.00611756 -0.00528172] [-0.01072969 0.00865408 -0.02301539]] **b1** [[ 0.] [ 0.]] **W2** [[ 0.01744812 -0.00761207]] **b2** [[ 0.]] ##### 3.2 - L-layer Neural Network The initialization for a deeper L-layer neural network is more complicated because there are many more weight matrices and bias vectors. When completing the `initialize_parameters_deep`, you should make sure that your dimensions match between each layer. Recall that $n^&#123;[l]&#125;$ is the number of units in layer $l$. Thus for example if the size of our input $X$ is $(12288, 209)$ (with $m=209$ examples) then: **Shape of W** **Shape of b** **Activation** **Shape of Activation** **Layer 1** $(n^&#123;[1]&#125;,12288)$ $(n^&#123;[1]&#125;,1)$ $Z^&#123;[1]&#125; = W^&#123;[1]&#125; X + b^&#123;[1]&#125; $ $(n^&#123;[1]&#125;,209)$ **Layer 2** $(n^&#123;[2]&#125;, n^&#123;[1]&#125;)$ $(n^&#123;[2]&#125;,1)$ $Z^&#123;[2]&#125; = W^&#123;[2]&#125; A^&#123;[1]&#125; + b^&#123;[2]&#125;$ $(n^&#123;[2]&#125;, 209)$ $\vdots$ $\vdots$ $\vdots$ $\vdots$ $\vdots$ **Layer L-1** $(n^&#123;[L-1]&#125;, n^&#123;[L-2]&#125;)$ $(n^&#123;[L-1]&#125;, 1)$ $Z^&#123;[L-1]&#125; = W^&#123;[L-1]&#125; A^&#123;[L-2]&#125; + b^&#123;[L-1]&#125;$ $(n^&#123;[L-1]&#125;, 209)$ **Layer L** $(n^&#123;[L]&#125;, n^&#123;[L-1]&#125;)$ $(n^&#123;[L]&#125;, 1)$ $Z^&#123;[L]&#125; = W^&#123;[L]&#125; A^&#123;[L-1]&#125; + b^&#123;[L]&#125;$ $(n^&#123;[L]&#125;, 209)$ Remember that when we compute $W X + b$ in python, it carries out broadcasting. For example, if: $$ W = \begin&#123;bmatrix&#125; j & k & l\\ m & n & o \\ p & q & r \end&#123;bmatrix&#125;\;\;\; X = \begin&#123;bmatrix&#125; a & b & c\\ d & e & f \\ g & h & i \end&#123;bmatrix&#125; \;\;\; b =\begin&#123;bmatrix&#125; s \\ t \\ u \end&#123;bmatrix&#125;\tag&#123;2&#125;$$ Then $WX + b$ will be: $$ WX + b = \begin&#123;bmatrix&#125; (ja + kd + lg) + s & (jb + ke + lh) + s & (jc + kf + li)+ s\\ (ma + nd + og) + t & (mb + ne + oh) + t & (mc + nf + oi) + t\\ (pa + qd + rg) + u & (pb + qe + rh) + u & (pc + qf + ri)+ u \end&#123;bmatrix&#125;\tag&#123;3&#125; $$ **Exercise**: Implement initialization for an L-layer Neural Network. **Instructions**: - The model's structure is *[LINEAR -> RELU] $ \times$ (L-1) -> LINEAR -> SIGMOID*. I.e., it has $L-1$ layers using a ReLU activation function followed by an output layer with a sigmoid activation function. - Use random initialization for the weight matrices. Use `np.random.randn(shape) * 0.01`. - Use zeros initialization for the biases. Use `np.zeros(shape)`. - We will store $n^&#123;[l]&#125;$, the number of units in different layers, in a variable `layer_dims`. For example, the `layer_dims` for the "Planar Data classification model" from last week would have been [2,4,1]: There were two inputs, one hidden layer with 4 hidden units, and an output layer with 1 output unit. Thus means `W1`'s shape was (4,2), `b1` was (4,1), `W2` was (1,4) and `b2` was (1,1). Now you will generalize this to $L$ layers! - Here is the implementation for $L=1$ (one layer neural network). It should inspire you to implement the general case (L-layer neural network). 123if L == 1: parameters["W" + str(L)] = np.random.randn(layer_dims[1], layer_dims[0]) * 0.01 parameters["b" + str(L)] = np.zeros((layer_dims[1], 1)) 12345678910111213141516171819202122232425262728# GRADED FUNCTION: initialize_parameters_deepdef initialize_parameters_deep(layer_dims): """ Arguments: layer_dims -- python array (list) containing the dimensions of each layer in our network Returns: parameters -- python dictionary containing your parameters "W1", "b1", ..., "WL", "bL": Wl -- weight matrix of shape (layer_dims[l], layer_dims[l-1]) bl -- bias vector of shape (layer_dims[l], 1) """ np.random.seed(3) parameters = &amp;#123;&amp;#125; L = len(layer_dims) # number of layers in the network for l in range(1, L): ### START CODE HERE ### (≈ 2 lines of code) parameters['W' + str(l)] = np.random.randn(layer_dims[l], layer_dims[l-1]) * 0.01 parameters['b' + str(l)] = np.zeros((layer_dims[l], 1)) ### END CODE HERE ### assert(parameters['W' + str(l)].shape == (layer_dims[l], layer_dims[l-1])) assert(parameters['b' + str(l)].shape == (layer_dims[l], 1)) return parameters 12345parameters = initialize_parameters_deep([5,4,3])print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) W1 = [[ 0.01788628 0.0043651 0.00096497 -0.01863493 -0.00277388] [-0.00354759 -0.00082741 -0.00627001 -0.00043818 -0.00477218] [-0.01313865 0.00884622 0.00881318 0.01709573 0.00050034] [-0.00404677 -0.0054536 -0.01546477 0.00982367 -0.01101068]] b1 = [[ 0.] [ 0.] [ 0.] [ 0.]] W2 = [[-0.01185047 -0.0020565 0.01486148 0.00236716] [-0.01023785 -0.00712993 0.00625245 -0.00160513] [-0.00768836 -0.00230031 0.00745056 0.01976111]] b2 = [[ 0.] [ 0.] [ 0.]] **Expected output**: **W1** [[ 0.01788628 0.0043651 0.00096497 -0.01863493 -0.00277388] [-0.00354759 -0.00082741 -0.00627001 -0.00043818 -0.00477218] [-0.01313865 0.00884622 0.00881318 0.01709573 0.00050034] [-0.00404677 -0.0054536 -0.01546477 0.00982367 -0.01101068]] **b1** [[ 0.] [ 0.] [ 0.] [ 0.]] **W2** [[-0.01185047 -0.0020565 0.01486148 0.00236716] [-0.01023785 -0.00712993 0.00625245 -0.00160513] [-0.00768836 -0.00230031 0.00745056 0.01976111]] **b2** [[ 0.] [ 0.] [ 0.]] #### 4 - Forward propagation module ##### 4.1 - Linear Forward Now that you have initialized your parameters, you will do the forward propagation module. You will start by implementing some basic functions that you will use later when implementing the model. You will complete three functions in this order: - LINEAR - LINEAR -> ACTIVATION where ACTIVATION will be either ReLU or Sigmoid. - [LINEAR -> RELU] $\times$ (L-1) -> LINEAR -> SIGMOID (whole model) The linear forward module (vectorized over all the examples) computes the following equations: $$Z^&#123;[l]&#125; = W^&#123;[l]&#125;A^&#123;[l-1]&#125; +b^&#123;[l]&#125;\tag&#123;4&#125;$$ where $A^&#123;[0]&#125; = X$. **Exercise**: Build the linear part of forward propagation. **Reminder**: The mathematical representation of this unit is $Z^&#123;[l]&#125; = W^&#123;[l]&#125;A^&#123;[l-1]&#125; +b^&#123;[l]&#125;$. You may also find `np.dot()` useful. If your dimensions don't match, printing `W.shape` may help. 123456789101112131415161718192021222324# GRADED FUNCTION: linear_forwarddef linear_forward(A, W, b): """ Implement the linear part of a layer's forward propagation. Arguments: A -- activations from previous layer (or input data): (size of previous layer, number of examples) W -- weights matrix: numpy array of shape (size of current layer, size of previous layer) b -- bias vector, numpy array of shape (size of the current layer, 1) Returns: Z -- the input of the activation function, also called pre-activation parameter cache -- a python dictionary containing "A", "W" and "b" ; stored for computing the backward pass efficiently """ ### START CODE HERE ### (≈ 1 line of code) Z = np.dot(W, A) + b ### END CODE HERE ### assert(Z.shape == (W.shape[0], A.shape[1])) cache = (A, W, b) return Z, cache 1234A, W, b = linear_forward_test_case()Z, linear_cache = linear_forward(A, W, b)print("Z = " + str(Z)) Z = [[ 3.26295337 -1.23429987]] **Expected output**: **Z** [[ 3.26295337 -1.23429987]] ##### 4.2 - Linear-Activation Forward In this notebook, you will use two activation functions: - **Sigmoid**: $\sigma(Z) = \sigma(W A + b) = \frac&#123;1&#125;&#123; 1 + e^&#123;-(W A + b)&#125;&#125;$. We have provided you with the `sigmoid` function. This function returns **two** items: the activation value "`a`" and a "`cache`" that contains "`Z`" (it's what we will feed in to the corresponding backward function). To use it you could just call: 1A, activation_cache = sigmoid(Z) - **ReLU**: The mathematical formula for ReLu is $A = RELU(Z) = max(0, Z)$. We have provided you with the `relu` function. This function returns **two** items: the activation value "`A`" and a "`cache`" that contains "`Z`" (it's what we will feed in to the corresponding backward function). To use it you could just call: 1A, activation_cache = relu(Z) For more convenience, you are going to group two functions (Linear and Activation) into one function (LINEAR->ACTIVATION). Hence, you will implement a function that does the LINEAR forward step followed by an ACTIVATION forward step. **Exercise**: Implement the forward propagation of the *LINEAR->ACTIVATION* layer. Mathematical relation is: $A^&#123;[l]&#125; = g(Z^&#123;[l]&#125;) = g(W^&#123;[l]&#125;A^&#123;[l-1]&#125; +b^&#123;[l]&#125;)$ where the activation "g" can be sigmoid() or relu(). Use linear_forward() and the correct activation function. 123456789101112131415161718192021222324252627282930313233343536# GRADED FUNCTION: linear_activation_forwarddef linear_activation_forward(A_prev, W, b, activation): """ Implement the forward propagation for the LINEAR-&gt;ACTIVATION layer Arguments: A_prev -- activations from previous layer (or input data): (size of previous layer, number of examples) W -- weights matrix: numpy array of shape (size of current layer, size of previous layer) b -- bias vector, numpy array of shape (size of the current layer, 1) activation -- the activation to be used in this layer, stored as a text string: "sigmoid" or "relu" Returns: A -- the output of the activation function, also called the post-activation value cache -- a python dictionary containing "linear_cache" and "activation_cache"; stored for computing the backward pass efficiently """ if activation == "sigmoid": # Inputs: "A_prev, W, b". Outputs: "A, activation_cache". ### START CODE HERE ### (≈ 2 lines of code) Z, linear_cache = linear_forward(A_prev, W, b) A, activation_cache = sigmoid(Z) ### END CODE HERE ### elif activation == "relu": # Inputs: "A_prev, W, b". Outputs: "A, activation_cache". ### START CODE HERE ### (≈ 2 lines of code) Z, linear_cache = linear_forward(A_prev, W, b) A, activation_cache = relu(Z) ### END CODE HERE ### assert (A.shape == (W.shape[0], A_prev.shape[1])) cache = (linear_cache, activation_cache) return A, cache 1234567A_prev, W, b = linear_activation_forward_test_case()A, linear_activation_cache = linear_activation_forward(A_prev, W, b, activation = "sigmoid")print("With sigmoid: A = " + str(A))A, linear_activation_cache = linear_activation_forward(A_prev, W, b, activation = "relu")print("With ReLU: A = " + str(A)) With sigmoid: A = [[ 0.96890023 0.11013289]] With ReLU: A = [[ 3.43896131 0. ]] **Expected output**: **With sigmoid: A ** [[ 0.96890023 0.11013289]] **With ReLU: A ** [[ 3.43896131 0. ]] **Note**: In deep learning, the "[LINEAR->ACTIVATION]" computation is counted as a single layer in the neural network, not two layers. ##### d) L-Layer Model For even more convenience when implementing the $L$-layer Neural Net, you will need a function that replicates the previous one (`linear_activation_forward` with RELU) $L-1$ times, then follows that with one `linear_activation_forward` with SIGMOID. **Figure 2** : *[LINEAR -> RELU] $\times$ (L-1) -> LINEAR -> SIGMOID* model **Exercise**: Implement the forward propagation of the above model. **Instruction**: In the code below, the variable `AL` will denote $A^&#123;[L]&#125; = \sigma(Z^&#123;[L]&#125;) = \sigma(W^&#123;[L]&#125; A^&#123;[L-1]&#125; + b^&#123;[L]&#125;)$. (This is sometimes also called `Yhat`, i.e., this is $\hat&#123;Y&#125;$.) **Tips**: - Use the functions you had previously written - Use a for loop to replicate [LINEAR->RELU] (L-1) times - Don't forget to keep track of the caches in the "caches" list. To add a new value `c` to a `list`, you can use `list.append(c)`. 12345678910111213141516171819202122232425262728293031323334353637# GRADED FUNCTION: L_model_forwarddef L_model_forward(X, parameters): """ Implement forward propagation for the [LINEAR-&gt;RELU]*(L-1)-&gt;LINEAR-&gt;SIGMOID computation Arguments: X -- data, numpy array of shape (input size, number of examples) parameters -- output of initialize_parameters_deep() Returns: AL -- last post-activation value caches -- list of caches containing: every cache of linear_activation_forward() (there are L-1 of them, indexed from 0 to L-1) """ caches = [] A = X L = len(parameters) // 2 # number of layers in the neural network # Implement [LINEAR -&gt; RELU]*(L-1). Add "cache" to the "caches" list. for l in range(1, L): A_prev = A ### START CODE HERE ### (≈ 2 lines of code) A, cache = linear_activation_forward(A_prev, parameters["W" + str(l)], parameters["b" + str(l)], "relu") caches.append(cache) ### END CODE HERE ### # Implement LINEAR -&gt; SIGMOID. Add "cache" to the "caches" list. ### START CODE HERE ### (≈ 2 lines of code) AL, cache = linear_activation_forward(A, parameters["W" + str(L)], parameters["b" + str(L)], "sigmoid") caches.append(cache) ### END CODE HERE ### assert(AL.shape == (1,X.shape[1])) return AL, caches 1234X, parameters = L_model_forward_test_case_2hidden()AL, caches = L_model_forward(X, parameters)print("AL = " + str(AL))print("Length of caches list = " + str(len(caches))) AL = [[ 0.03921668 0.70498921 0.19734387 0.04728177]] Length of caches list = 3 **AL** [[ 0.03921668 0.70498921 0.19734387 0.04728177]] **Length of caches list ** 3 Great! Now you have a full forward propagation that takes the input X and outputs a row vector $A^&#123;[L]&#125;$ containing your predictions. It also records all intermediate values in "caches". Using $A^&#123;[L]&#125;$, you can compute the cost of your predictions. #### 5 - Cost function Now you will implement forward and backward propagation. You need to compute the cost, because you want to check if your model is actually learning. **Exercise**: Compute the cross-entropy cost $J$, using the following formula: $$-\frac&#123;1&#125;&#123;m&#125; \sum\limits_&#123;i = 1&#125;^&#123;m&#125; (y^&#123;(i)&#125;\log\left(a^&#123;[L] (i)&#125;\right) + (1-y^&#123;(i)&#125;)\log\left(1- a^&#123;[L](i)&#125;\right)) \tag&#123;7&#125;$$ 12345678910111213141516171819202122232425# GRADED FUNCTION: compute_costdef compute_cost(AL, Y): """ Implement the cost function defined by equation (7). Arguments: AL -- probability vector corresponding to your label predictions, shape (1, number of examples) Y -- true "label" vector (for example: containing 0 if non-cat, 1 if cat), shape (1, number of examples) Returns: cost -- cross-entropy cost """ m = Y.shape[1] # Compute loss from aL and y. ### START CODE HERE ### (≈ 1 lines of code) cost = np.sum(np.multiply(np.log(AL),Y) + np.multiply(np.log(1 - AL), 1 - Y)) / (-m) ### END CODE HERE ### cost = np.squeeze(cost) # To make sure your cost's shape is what we expect (e.g. this turns [[17]] into 17). assert(cost.shape == ()) return cost 123Y, AL = compute_cost_test_case()print("cost = " + str(compute_cost(AL, Y))) cost = 0.414931599615 **Expected Output**: **cost** 0.41493159961539694 #### 6 - Backward propagation module Just like with forward propagation, you will implement helper functions for backpropagation. Remember that back propagation is used to calculate the gradient of the loss function with respect to the parameters. **Reminder**: **Figure 3** : Forward and Backward propagation for *LINEAR->RELU->LINEAR->SIGMOID* *The purple blocks represent the forward propagation, and the red blocks represent the backward propagation.* Now, similar to forward propagation, you are going to build the backward propagation in three steps: LINEAR backward LINEAR -&gt; ACTIVATION backward where ACTIVATION computes the derivative of either the ReLU or sigmoid activation [LINEAR -&gt; RELU] $\times$ (L-1) -&gt; LINEAR -&gt; SIGMOID backward (whole model) 6.1 - Linear backwardFor layer $l$, the linear part is: $Z^&#123;[l]&#125; = W^&#123;[l]&#125; A^&#123;[l-1]&#125; + b^&#123;[l]&#125;$ (followed by an activation). Suppose you have already calculated the derivative $dZ^&#123;[l]&#125; = \frac&#123;\partial \mathcal&#123;L&#125; &#125;&#123;\partial Z^&#123;[l]&#125;&#125;$. You want to get $(dW^&#123;[l]&#125;, db^&#123;[l]&#125; dA^&#123;[l-1]&#125;)$. **Figure 4** The three outputs $(dW^&#123;[l]&#125;, db^&#123;[l]&#125;, dA^&#123;[l]&#125;)$ are computed using the input $dZ^&#123;[l]&#125;$.Here are the formulas you need: dW^&#123;[l]&#125; = \frac&#123;\partial \mathcal&#123;L&#125; &#125;&#123;\partial W^&#123;[l]&#125;&#125; = \frac&#123;1&#125;&#123;m&#125; dZ^&#123;[l]&#125; A^&#123;[l-1] T&#125; \tag&#123;8&#125;db^&#123;[l]&#125; = \frac&#123;\partial \mathcal&#123;L&#125; &#125;&#123;\partial b^&#123;[l]&#125;&#125; = \frac&#123;1&#125;&#123;m&#125; \sum_&#123;i = 1&#125;^&#123;m&#125; dZ^&#123;[l](i)&#125;\tag&#123;9&#125;dA^&#123;[l-1]&#125; = \frac&#123;\partial \mathcal&#123;L&#125; &#125;&#123;\partial A^&#123;[l-1]&#125;&#125; = W^&#123;[l] T&#125; dZ^&#123;[l]&#125; \tag&#123;10&#125;Exercise: Use the 3 formulas above to implement linear_backward(). 1234567891011121314151617181920212223242526272829# GRADED FUNCTION: linear_backwarddef linear_backward(dZ, cache): """ Implement the linear portion of backward propagation for a single layer (layer l) Arguments: dZ -- Gradient of the cost with respect to the linear output (of current layer l) cache -- tuple of values (A_prev, W, b) coming from the forward propagation in the current layer Returns: dA_prev -- Gradient of the cost with respect to the activation (of the previous layer l-1), same shape as A_prev dW -- Gradient of the cost with respect to W (current layer l), same shape as W db -- Gradient of the cost with respect to b (current layer l), same shape as b """ A_prev, W, b = cache m = A_prev.shape[1] ### START CODE HERE ### (≈ 3 lines of code) dW = np.dot(dZ, A_prev.T) / m db = np.sum(dZ, axis=1, keepdims=True) / m dA_prev = np.dot(W.T, dZ) ### END CODE HERE ### assert (dA_prev.shape == A_prev.shape) assert (dW.shape == W.shape) assert (db.shape == b.shape) return dA_prev, dW, db 1234567# Set up some test inputsdZ, linear_cache = linear_backward_test_case()dA_prev, dW, db = linear_backward(dZ, linear_cache)print ("dA_prev = "+ str(dA_prev))print ("dW = " + str(dW))print ("db = " + str(db)) dA_prev = [[ 0.51822968 -0.19517421] [-0.40506361 0.15255393] [ 2.37496825 -0.89445391]] dW = [[-0.10076895 1.40685096 1.64992505]] db = [[ 0.50629448]] Expected Output: **dA_prev** [[ 0.51822968 -0.19517421] [-0.40506361 0.15255393] [ 2.37496825 -0.89445391]] **dW** [[-0.10076895 1.40685096 1.64992505]] **db** [[ 0.50629448]] 6.2 - Linear-Activation backwardNext, you will create a function that merges the two helper functions: linear_backward and the backward step for the activation linear_activation_backward. To help you implement linear_activation_backward, we provided two backward functions: sigmoid_backward: Implements the backward propagation for SIGMOID unit. You can call it as follows: 1dZ = sigmoid_backward(dA, activation_cache) relu_backward: Implements the backward propagation for RELU unit. You can call it as follows: 1dZ = relu_backward(dA, activation_cache) If $g(.)$ is the activation function,sigmoid_backward and relu_backward compute dZ^&#123;[l]&#125; = dA^&#123;[l]&#125; * g'(Z^&#123;[l]&#125;) \tag&#123;11&#125;. Exercise: Implement the backpropagation for the LINEAR-&gt;ACTIVATION layer. 12345678910111213141516171819202122232425262728293031# GRADED FUNCTION: linear_activation_backwarddef linear_activation_backward(dA, cache, activation): """ Implement the backward propagation for the LINEAR-&gt;ACTIVATION layer. Arguments: dA -- post-activation gradient for current layer l cache -- tuple of values (linear_cache, activation_cache) we store for computing backward propagation efficiently activation -- the activation to be used in this layer, stored as a text string: "sigmoid" or "relu" Returns: dA_prev -- Gradient of the cost with respect to the activation (of the previous layer l-1), same shape as A_prev dW -- Gradient of the cost with respect to W (current layer l), same shape as W db -- Gradient of the cost with respect to b (current layer l), same shape as b """ linear_cache, activation_cache = cache if activation == "relu": ### START CODE HERE ### (≈ 2 lines of code) dZ = relu_backward(dA, activation_cache) dA_prev, dW, db = linear_backward(dZ, linear_cache) ### END CODE HERE ### elif activation == "sigmoid": ### START CODE HERE ### (≈ 2 lines of code) dZ = sigmoid_backward(dA, activation_cache) dA_prev, dW, db = linear_backward(dZ, linear_cache) ### END CODE HERE ### return dA_prev, dW, db 12345678910111213dAL, linear_activation_cache = linear_activation_backward_test_case()dA_prev, dW, db = linear_activation_backward(dAL, linear_activation_cache, activation = "sigmoid")print ("sigmoid:")print ("dA_prev = "+ str(dA_prev))print ("dW = " + str(dW))print ("db = " + str(db) + "\n")dA_prev, dW, db = linear_activation_backward(dAL, linear_activation_cache, activation = "relu")print ("relu:")print ("dA_prev = "+ str(dA_prev))print ("dW = " + str(dW))print ("db = " + str(db)) sigmoid: dA_prev = [[ 0.11017994 0.01105339] [ 0.09466817 0.00949723] [-0.05743092 -0.00576154]] dW = [[ 0.10266786 0.09778551 -0.01968084]] db = [[-0.05729622]] relu: dA_prev = [[ 0.44090989 0. ] [ 0.37883606 0. ] [-0.2298228 0. ]] dW = [[ 0.44513824 0.37371418 -0.10478989]] db = [[-0.20837892]] Expected output with sigmoid: dA_prev [[ 0.11017994 0.01105339] [ 0.09466817 0.00949723] [-0.05743092 -0.00576154]] dW [[ 0.10266786 0.09778551 -0.01968084]] db [[-0.05729622]] Expected output with relu: dA_prev [[ 0.44090989 0. ] [ 0.37883606 0. ] [-0.2298228 0. ]] dW [[ 0.44513824 0.37371418 -0.10478989]] db [[-0.20837892]] 6.3 - L-Model BackwardNow you will implement the backward function for the whole network. Recall that when you implemented the L_model_forward function, at each iteration, you stored a cache which contains (X,W,b, and z). In the back propagation module, you will use those variables to compute the gradients. Therefore, in the L_model_backward function, you will iterate through all the hidden layers backward, starting from layer $L$. On each step, you will use the cached values for layer $l$ to backpropagate through layer $l$. Figure 5 below shows the backward pass. **Figure 5** : Backward pass Initializing backpropagation:To backpropagate through this network, we know that the output is,$A^&#123;[L]&#125; = \sigma(Z^&#123;[L]&#125;)$. Your code thus needs to compute dAL $= \frac&#123;\partial \mathcal&#123;L&#125;&#125;&#123;\partial A^&#123;[L]&#125;&#125;$.To do so, use this formula (derived using calculus which you don’t need in-depth knowledge of):1dAL = - (np.divide(Y, AL) - np.divide(1 - Y, 1 - AL)) # derivative of cost with respect to AL You can then use this post-activation gradient dAL to keep going backward. As seen in Figure 5, you can now feed in dAL into the LINEAR-&gt;SIGMOID backward function you implemented (which will use the cached values stored by the L_model_forward function). After that, you will have to use a for loop to iterate through all the other layers using the LINEAR-&gt;RELU backward function. You should store each dA, dW, and db in the grads dictionary. To do so, use this formula : grads["dW" + str(l)] = dW^&#123;[l]&#125;\tag&#123;15&#125;For example, for $l=3$ this would store $dW^&#123;[l]&#125;$ in grads[&quot;dW3&quot;]. Exercise: Implement backpropagation for the [LINEAR-&gt;RELU] $\times$ (L-1) -&gt; LINEAR -&gt; SIGMOID model. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# GRADED FUNCTION: L_model_backwarddef L_model_backward(AL, Y, caches): """ Implement the backward propagation for the [LINEAR-&gt;RELU] * (L-1) -&gt; LINEAR -&gt; SIGMOID group Arguments: AL -- probability vector, output of the forward propagation (L_model_forward()) Y -- true "label" vector (containing 0 if non-cat, 1 if cat) caches -- list of caches containing: every cache of linear_activation_forward() with "relu" (it's caches[l], for l in range(L-1) i.e l = 0...L-2) the cache of linear_activation_forward() with "sigmoid" (it's caches[L-1]) Returns: grads -- A dictionary with the gradients grads["dA" + str(l)] = ... grads["dW" + str(l)] = ... grads["db" + str(l)] = ... """ grads = &amp;#123;&amp;#125; L = len(caches) # the number of layers m = AL.shape[1] Y = Y.reshape(AL.shape) # after this line, Y is the same shape as AL # Initializing the backpropagation ### START CODE HERE ### (1 line of code) dAL = -(np.divide(Y, AL) - np.divide((1-Y), (1-AL))) ### END CODE HERE ### # Lth layer (SIGMOID -&gt; LINEAR) gradients. Inputs: "dAL, current_cache". Outputs: "grads["dAL-1"], grads["dWL"], grads["dbL"] ### START CODE HERE ### (approx. 2 lines) current_cache = caches[L - 1] grads["dA" + str(L-1)], grads["dW" + str(L)], grads["db" + str(L)] = linear_activation_backward(dAL, current_cache, "sigmoid") ### END CODE HERE ### # Loop from l=L-2 to l=0 for l in reversed(range(L-1)): # lth layer: (RELU -&gt; LINEAR) gradients. # Inputs: "grads["dA" + str(l + 1)], current_cache". Outputs: "grads["dA" + str(l)] , grads["dW" + str(l + 1)] , grads["db" + str(l + 1)] ### START CODE HERE ### (approx. 5 lines) current_cache = caches[l] dA_prev_temp, dW_temp, db_temp = linear_activation_backward(grads["dA" + str(l + 1)], current_cache, "relu") grads["dA" + str(l)] = dA_prev_temp grads["dW" + str(l + 1)] = dW_temp grads["db" + str(l + 1)] = db_temp ### END CODE HERE ### return grads 123AL, Y_assess, caches = L_model_backward_test_case()grads = L_model_backward(AL, Y_assess, caches)print_grads(grads) dW1 = [[ 0.41010002 0.07807203 0.13798444 0.10502167] [ 0. 0. 0. 0. ] [ 0.05283652 0.01005865 0.01777766 0.0135308 ]] db1 = [[-0.22007063] [ 0. ] [-0.02835349]] dA1 = [[ 0.12913162 -0.44014127] [-0.14175655 0.48317296] [ 0.01663708 -0.05670698]] Expected Output dW1 [[ 0.41010002 0.07807203 0.13798444 0.10502167] [ 0. 0. 0. 0. ] [ 0.05283652 0.01005865 0.01777766 0.0135308 ]] db1 [[-0.22007063] [ 0. ] [-0.02835349]] dA1 [[ 0.12913162 -0.44014127] [-0.14175655 0.48317296] [ 0.01663708 -0.05670698]] 6.4 - Update ParametersIn this section you will update the parameters of the model, using gradient descent: W^&#123;[l]&#125; = W^&#123;[l]&#125; - \alpha \text&#123; &#125; dW^&#123;[l]&#125; \tag&#123;16&#125;b^&#123;[l]&#125; = b^&#123;[l]&#125; - \alpha \text&#123; &#125; db^&#123;[l]&#125; \tag&#123;17&#125;where $\alpha$ is the learning rate. After computing the updated parameters, store them in the parameters dictionary. Exercise: Implement update_parameters() to update your parameters using gradient descent. Instructions:Update parameters using gradient descent on every $W^&#123;[l]&#125;$ and $b^&#123;[l]&#125;$ for $l = 1, 2, …, L$. 12345678910111213141516171819202122232425# GRADED FUNCTION: update_parametersdef update_parameters(parameters, grads, learning_rate): """ Update parameters using gradient descent Arguments: parameters -- python dictionary containing your parameters grads -- python dictionary containing your gradients, output of L_model_backward Returns: parameters -- python dictionary containing your updated parameters parameters["W" + str(l)] = ... parameters["b" + str(l)] = ... """ L = len(parameters) // 2 # number of layers in the neural network # Update rule for each parameter. Use a for loop. ### START CODE HERE ### (≈ 3 lines of code) for l in range(L): parameters["W" + str(l+1)] = parameters['W' + str(l + 1)] - learning_rate * grads["dW" + str(l + 1)] parameters["b" + str(l+1)] = parameters['b' + str(l + 1)] - learning_rate * grads["db" + str(l + 1)] ### END CODE HERE ### return parameters 1234567parameters, grads = update_parameters_test_case()parameters = update_parameters(parameters, grads, 0.1)print ("W1 = "+ str(parameters["W1"]))print ("b1 = "+ str(parameters["b1"]))print ("W2 = "+ str(parameters["W2"]))print ("b2 = "+ str(parameters["b2"])) W1 = [[-0.59562069 -0.09991781 -2.14584584 1.82662008] [-1.76569676 -0.80627147 0.51115557 -1.18258802] [-1.0535704 -0.86128581 0.68284052 2.20374577]] b1 = [[-0.04659241] [-1.28888275] [ 0.53405496]] W2 = [[-0.55569196 0.0354055 1.32964895]] b2 = [[-0.84610769]] Expected Output: W1 [[-0.59562069 -0.09991781 -2.14584584 1.82662008] [-1.76569676 -0.80627147 0.51115557 -1.18258802] [-1.0535704 -0.86128581 0.68284052 2.20374577]] b1 [[-0.04659241] [-1.28888275] [ 0.53405496]] W2 [[-0.55569196 0.0354055 1.32964895]] b2 [[-0.84610769]] 7 - ConclusionCongrats on implementing all the functions required for building a deep neural network! We know it was a long assignment but going forward it will only get better. The next part of the assignment is easier. In the next assignment you will put all these together to build two models: A two-layer neural network An L-layer neural network You will in fact use these models to classify cat vs non-cat images! Deep Neural Network for Image Classification: ApplicationWhen you finish this, you will have finished the last programming assignment of Week 4, and also the last programming assignment of this course! You will use use the functions you’d implemented in the previous assignment to build a deep network, and apply it to cat vs non-cat classification. Hopefully, you will see an improvement in accuracy relative to your previous logistic regression implementation. After this assignment you will be able to: Build and apply a deep neural network to supervised learning. Let’s get started! 1 - PackagesLet’s first import all the packages that you will need during this assignment. numpy is the fundamental package for scientific computing with Python. matplotlib is a library to plot graphs in Python. h5py is a common package to interact with a dataset that is stored on an H5 file. PIL and scipy are used here to test your model with your own picture at the end. dnn_app_utils provides the functions implemented in the “Building your Deep Neural Network: Step by Step” assignment to this notebook. np.random.seed(1) is used to keep all the random function calls consistent. It will help us grade your work. 123456789101112131415161718import timeimport numpy as npimport h5pyimport matplotlib.pyplot as pltimport scipyfrom PIL import Imagefrom scipy import ndimagefrom dnn_app_utils_v3 import *%matplotlib inlineplt.rcParams['figure.figsize'] = (5.0, 4.0) # set default size of plotsplt.rcParams['image.interpolation'] = 'nearest'plt.rcParams['image.cmap'] = 'gray'%load_ext autoreload%autoreload 2np.random.seed(1) /opt/conda/lib/python3.5/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment. warnings.warn(&#39;Matplotlib is building the font cache using fc-list. This may take a moment.&#39;) /opt/conda/lib/python3.5/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment. warnings.warn(&#39;Matplotlib is building the font cache using fc-list. This may take a moment.&#39;) 2 - DatasetYou will use the same “Cat vs non-Cat” dataset as in “Logistic Regression as a Neural Network” (Assignment 2). The model you had built had 70% test accuracy on classifying cats vs non-cats images. Hopefully, your new model will perform a better! Problem Statement: You are given a dataset (“data.h5”) containing: - a training set of m_train images labelled as cat (1) or non-cat (0) - a test set of m_test images labelled as cat and non-cat - each image is of shape (num_px, num_px, 3) where 3 is for the 3 channels (RGB). Let’s get more familiar with the dataset. Load the data by running the cell below. 1train_x_orig, train_y, test_x_orig, test_y, classes = load_data() The following code will show you an image in the dataset. Feel free to change the index and re-run the cell multiple times to see other images. 1234# Example of a pictureindex = 10plt.imshow(train_x_orig[index])print ("y = " + str(train_y[0,index]) + ". It's a " + classes[train_y[0,index]].decode("utf-8") + " picture.") y = 0. It&#39;s a non-cat picture. 123456789101112# Explore your dataset m_train = train_x_orig.shape[0]num_px = train_x_orig.shape[1]m_test = test_x_orig.shape[0]print ("Number of training examples: " + str(m_train))print ("Number of testing examples: " + str(m_test))print ("Each image is of size: (" + str(num_px) + ", " + str(num_px) + ", 3)")print ("train_x_orig shape: " + str(train_x_orig.shape))print ("train_y shape: " + str(train_y.shape))print ("test_x_orig shape: " + str(test_x_orig.shape))print ("test_y shape: " + str(test_y.shape)) Number of training examples: 209 Number of testing examples: 50 Each image is of size: (64, 64, 3) train_x_orig shape: (209, 64, 64, 3) train_y shape: (1, 209) test_x_orig shape: (50, 64, 64, 3) test_y shape: (1, 50) As usual, you reshape and standardize the images before feeding them to the network. The code is given in the cell below. Figure 1: Image to vector conversion. 12345678910# Reshape the training and test examples train_x_flatten = train_x_orig.reshape(train_x_orig.shape[0], -1).T # The "-1" makes reshape flatten the remaining dimensionstest_x_flatten = test_x_orig.reshape(test_x_orig.shape[0], -1).T# Standardize data to have feature values between 0 and 1.train_x = train_x_flatten/255.test_x = test_x_flatten/255.print ("train_x's shape: " + str(train_x.shape))print ("test_x's shape: " + str(test_x.shape)) train_x&#39;s shape: (12288, 209) test_x&#39;s shape: (12288, 50) $12,288$ equals $64 \times 64 \times 3$ which is the size of one reshaped image vector. 3 - Architecture of your modelNow that you are familiar with the dataset, it is time to build a deep neural network to distinguish cat images from non-cat images. You will build two different models: A 2-layer neural network An L-layer deep neural network You will then compare the performance of these models, and also try out different values for $L$. Let’s look at the two architectures. 3.1 - 2-layer neural network Figure 2: 2-layer neural network. The model can be summarized as: ***INPUT -> LINEAR -> RELU -> LINEAR -> SIGMOID -> OUTPUT***. Detailed Architecture of figure 2: The input is a (64,64,3) image which is flattened to a vector of size $(12288,1)$. The corresponding vector: $[x0,x_1,…,x&#123;12287&#125;]^T$ is then multiplied by the weight matrix $W^&#123;[1]&#125;$ of size $(n^&#123;[1]&#125;, 12288)$. You then add a bias term and take its relu to get the following vector: $[a0^&#123;[1]&#125;, a_1^&#123;[1]&#125;,…, a&#123;n^&#123;[1]&#125;-1&#125;^&#123;[1]&#125;]^T$. You then repeat the same process. You multiply the resulting vector by $W^&#123;[2]&#125;$ and add your intercept (bias). Finally, you take the sigmoid of the result. If it is greater than 0.5, you classify it to be a cat. 3.2 - L-layer deep neural networkIt is hard to represent an L-layer deep neural network with the above representation. However, here is a simplified network representation: Figure 3: L-layer neural network. The model can be summarized as: ***[LINEAR -> RELU] $\times$ (L-1) -> LINEAR -> SIGMOID*** Detailed Architecture of figure 3: The input is a (64,64,3) image which is flattened to a vector of size (12288,1). The corresponding vector: $[x0,x_1,…,x&#123;12287&#125;]^T$ is then multiplied by the weight matrix $W^&#123;[1]&#125;$ and then you add the intercept $b^&#123;[1]&#125;$. The result is called the linear unit. Next, you take the relu of the linear unit. This process could be repeated several times for each $(W^&#123;[l]&#125;, b^&#123;[l]&#125;)$ depending on the model architecture. Finally, you take the sigmoid of the final linear unit. If it is greater than 0.5, you classify it to be a cat. 3.3 - General methodologyAs usual you will follow the Deep Learning methodology to build the model: 1. Initialize parameters / Define hyperparameters 2. Loop for num_iterations: a. Forward propagation b. Compute cost function c. Backward propagation d. Update parameters (using parameters, and grads from backprop) 4. Use trained parameters to predict labels Let’s now implement those two models! 4 - Two-layer neural networkQuestion: Use the helper functions you have implemented in the previous assignment to build a 2-layer neural network with the following structure: LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID. The functions you may need and their inputs are:123456789101112131415def initialize_parameters(n_x, n_h, n_y): ... return parameters def linear_activation_forward(A_prev, W, b, activation): ... return A, cachedef compute_cost(AL, Y): ... return costdef linear_activation_backward(dA, cache, activation): ... return dA_prev, dW, dbdef update_parameters(parameters, grads, learning_rate): ... return parameters 12345### CONSTANTS DEFINING THE MODEL ####n_x = 12288 # num_px * num_px * 3n_h = 7n_y = 1layers_dims = (n_x, n_h, n_y) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# GRADED FUNCTION: two_layer_modeldef two_layer_model(X, Y, layers_dims, learning_rate = 0.0075, num_iterations = 3000, print_cost=False): """ Implements a two-layer neural network: LINEAR-&gt;RELU-&gt;LINEAR-&gt;SIGMOID. Arguments: X -- input data, of shape (n_x, number of examples) Y -- true "label" vector (containing 0 if cat, 1 if non-cat), of shape (1, number of examples) layers_dims -- dimensions of the layers (n_x, n_h, n_y) num_iterations -- number of iterations of the optimization loop learning_rate -- learning rate of the gradient descent update rule print_cost -- If set to True, this will print the cost every 100 iterations Returns: parameters -- a dictionary containing W1, W2, b1, and b2 """ np.random.seed(1) grads = &amp;#123;&amp;#125; costs = [] # to keep track of the cost m = X.shape[1] # number of examples (n_x, n_h, n_y) = layers_dims # Initialize parameters dictionary, by calling one of the functions you'd previously implemented ### START CODE HERE ### (≈ 1 line of code) parameters = initialize_parameters(n_x, n_h, n_y) ### END CODE HERE ### # Get W1, b1, W2 and b2 from the dictionary parameters. W1 = parameters["W1"] b1 = parameters["b1"] W2 = parameters["W2"] b2 = parameters["b2"] # Loop (gradient descent) for i in range(0, num_iterations): # Forward propagation: LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID. Inputs: "X, W1, b1, W2, b2". Output: "A1, cache1, A2, cache2". ### START CODE HERE ### (≈ 2 lines of code) A1, cache1 = linear_activation_forward(X, W1, b1, "relu") A2, cache2 = linear_activation_forward(A1, W2, b2, "sigmoid") ### END CODE HERE ### # Compute cost ### START CODE HERE ### (≈ 1 line of code) cost = compute_cost(A2, Y) ### END CODE HERE ### # Initializing backward propagation dA2 = - (np.divide(Y, A2) - np.divide(1 - Y, 1 - A2)) # Backward propagation. Inputs: "dA2, cache2, cache1". Outputs: "dA1, dW2, db2; also dA0 (not used), dW1, db1". ### START CODE HERE ### (≈ 2 lines of code) dA1, dW2, db2 = linear_activation_backward(dA2, cache2, "sigmoid") dA0, dW1, db1 = linear_activation_backward(dA1, cache1, "relu") ### END CODE HERE ### # Set grads['dWl'] to dW1, grads['db1'] to db1, grads['dW2'] to dW2, grads['db2'] to db2 grads['dW1'] = dW1 grads['db1'] = db1 grads['dW2'] = dW2 grads['db2'] = db2 # Update parameters. ### START CODE HERE ### (approx. 1 line of code) parameters = update_parameters(parameters, grads, learning_rate) ### END CODE HERE ### # Retrieve W1, b1, W2, b2 from parameters W1 = parameters["W1"] b1 = parameters["b1"] W2 = parameters["W2"] b2 = parameters["b2"] # Print the cost every 100 training example if print_cost and i % 100 == 0: print("Cost after iteration &amp;#123;&amp;#125;: &amp;#123;&amp;#125;".format(i, np.squeeze(cost))) if print_cost and i % 100 == 0: costs.append(cost) # plot the cost plt.plot(np.squeeze(costs)) plt.ylabel('cost') plt.xlabel('iterations (per tens)') plt.title("Learning rate =" + str(learning_rate)) plt.show() return parameters Run the cell below to train your parameters. See if your model runs. The cost should be decreasing. It may take up to 5 minutes to run 2500 iterations. Check if the “Cost after iteration 0” matches the expected output below, if not click on the square (⬛) on the upper bar of the notebook to stop the cell and try to find your error. 1parameters = two_layer_model(train_x, train_y, layers_dims = (n_x, n_h, n_y), num_iterations = 2500, print_cost=True) Cost after iteration 0: 0.693049735659989 Cost after iteration 100: 0.6464320953428849 Cost after iteration 200: 0.6325140647912678 Cost after iteration 300: 0.6015024920354665 Cost after iteration 400: 0.5601966311605748 Cost after iteration 500: 0.515830477276473 Cost after iteration 600: 0.4754901313943325 Cost after iteration 700: 0.43391631512257495 Cost after iteration 800: 0.4007977536203886 Cost after iteration 900: 0.35807050113237987 Cost after iteration 1000: 0.3394281538366413 Cost after iteration 1100: 0.30527536361962654 Cost after iteration 1200: 0.2749137728213015 Cost after iteration 1300: 0.24681768210614827 Cost after iteration 1400: 0.1985073503746611 Cost after iteration 1500: 0.17448318112556593 Cost after iteration 1600: 0.1708076297809661 Cost after iteration 1700: 0.11306524562164737 Cost after iteration 1800: 0.09629426845937163 Cost after iteration 1900: 0.08342617959726878 Cost after iteration 2000: 0.0743907870431909 Cost after iteration 2100: 0.06630748132267938 Cost after iteration 2200: 0.05919329501038176 Cost after iteration 2300: 0.05336140348560564 Cost after iteration 2400: 0.048554785628770226 Expected Output: **Cost after iteration 0** 0.6930497356599888 **Cost after iteration 100** 0.6464320953428849 **...** ... **Cost after iteration 2400** 0.048554785628770206 Good thing you built a vectorized implementation! Otherwise it might have taken 10 times longer to train this. Now, you can use the trained parameters to classify images from the dataset. To see your predictions on the training and test sets, run the cell below. 1predictions_train = predict(train_x, train_y, parameters) Accuracy: 1.0 Expected Output: **Accuracy** 1.0 1predictions_test = predict(test_x, test_y, parameters) Accuracy: 0.72 Expected Output: **Accuracy** 0.72 Note: You may notice that running the model on fewer iterations (say 1500) gives better accuracy on the test set. This is called “early stopping” and we will talk about it in the next course. Early stopping is a way to prevent overfitting. Congratulations! It seems that your 2-layer neural network has better performance (72%) than the logistic regression implementation (70%, assignment week 2). Let’s see if you can do even better with an $L$-layer model. 5 - L-layer Neural NetworkQuestion: Use the helper functions you have implemented previously to build an $L$-layer neural network with the following structure: [LINEAR -&gt; RELU]$\times$(L-1) -&gt; LINEAR -&gt; SIGMOID. The functions you may need and their inputs are:123456789101112131415def initialize_parameters_deep(layers_dims): ... return parameters def L_model_forward(X, parameters): ... return AL, cachesdef compute_cost(AL, Y): ... return costdef L_model_backward(AL, Y, caches): ... return gradsdef update_parameters(parameters, grads, learning_rate): ... return parameters 12### CONSTANTS ###layers_dims = [12288, 20, 7, 5, 1] # 4-layer model 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# GRADED FUNCTION: L_layer_modeldef L_layer_model(X, Y, layers_dims, learning_rate = 0.0075, num_iterations = 3000, print_cost=False):#lr was 0.009 """ Implements a L-layer neural network: [LINEAR-&gt;RELU]*(L-1)-&gt;LINEAR-&gt;SIGMOID. Arguments: X -- data, numpy array of shape (number of examples, num_px * num_px * 3) Y -- true "label" vector (containing 0 if cat, 1 if non-cat), of shape (1, number of examples) layers_dims -- list containing the input size and each layer size, of length (number of layers + 1). learning_rate -- learning rate of the gradient descent update rule num_iterations -- number of iterations of the optimization loop print_cost -- if True, it prints the cost every 100 steps Returns: parameters -- parameters learnt by the model. They can then be used to predict. """ np.random.seed(1) costs = [] # keep track of cost # Parameters initialization. (≈ 1 line of code) ### START CODE HERE ### parameters = initialize_parameters_deep(layers_dims) ### END CODE HERE ### # Loop (gradient descent) for i in range(0, num_iterations): # Forward propagation: [LINEAR -&gt; RELU]*(L-1) -&gt; LINEAR -&gt; SIGMOID. ### START CODE HERE ### (≈ 1 line of code) AL, caches = L_model_forward(X, parameters) ### END CODE HERE ### # Compute cost. ### START CODE HERE ### (≈ 1 line of code) cost = compute_cost(AL, Y) ### END CODE HERE ### # Backward propagation. ### START CODE HERE ### (≈ 1 line of code) grads = L_model_backward(AL, Y, caches) ### END CODE HERE ### # Update parameters. ### START CODE HERE ### (≈ 1 line of code) parameters = update_parameters(parameters, grads, learning_rate) ### END CODE HERE ### # Print the cost every 100 training example if print_cost and i % 100 == 0: print ("Cost after iteration %i: %f" %(i, cost)) if print_cost and i % 100 == 0: costs.append(cost) # plot the cost plt.plot(np.squeeze(costs)) plt.ylabel('cost') plt.xlabel('iterations (per tens)') plt.title("Learning rate =" + str(learning_rate)) plt.show() return parameters You will now train the model as a 4-layer neural network. Run the cell below to train your model. The cost should decrease on every iteration. It may take up to 5 minutes to run 2500 iterations. Check if the “Cost after iteration 0” matches the expected output below, if not click on the square (⬛) on the upper bar of the notebook to stop the cell and try to find your error. 1parameters = L_layer_model(train_x, train_y, layers_dims, num_iterations = 2500, print_cost = True) Cost after iteration 0: 0.771749 Cost after iteration 100: 0.672053 Cost after iteration 200: 0.648263 Cost after iteration 300: 0.611507 Cost after iteration 400: 0.567047 Cost after iteration 500: 0.540138 Cost after iteration 600: 0.527930 Cost after iteration 700: 0.465477 Cost after iteration 800: 0.369126 Cost after iteration 900: 0.391747 Cost after iteration 1000: 0.315187 Cost after iteration 1100: 0.272700 Cost after iteration 1200: 0.237419 Cost after iteration 1300: 0.199601 Cost after iteration 1400: 0.189263 Cost after iteration 1500: 0.161189 Cost after iteration 1600: 0.148214 Cost after iteration 1700: 0.137775 Cost after iteration 1800: 0.129740 Cost after iteration 1900: 0.121225 Cost after iteration 2000: 0.113821 Cost after iteration 2100: 0.107839 Cost after iteration 2200: 0.102855 Cost after iteration 2300: 0.100897 Cost after iteration 2400: 0.092878 Expected Output: **Cost after iteration 0** 0.771749 **Cost after iteration 100** 0.672053 **...** ... **Cost after iteration 2400** 0.092878 1pred_train = predict(train_x, train_y, parameters) Accuracy: 0.985645933014 **Train Accuracy** 0.985645933014 1pred_test = predict(test_x, test_y, parameters) Accuracy: 0.8 Expected Output: **Test Accuracy** 0.8 Congrats! It seems that your 4-layer neural network has better performance (80%) than your 2-layer neural network (72%) on the same test set. This is good performance for this task. Nice job! Though in the next course on “Improving deep neural networks” you will learn how to obtain even higher accuracy by systematically searching for better hyperparameters (learning_rate, layers_dims, num_iterations, and others you’ll also learn in the next course). 6) Results AnalysisFirst, let’s take a look at some images the L-layer model labeled incorrectly. This will show a few mislabeled images. 1print_mislabeled_images(classes, test_x, test_y, pred_test) A few types of images the model tends to do poorly on include: Cat body in an unusual position Cat appears against a background of a similar color Unusual cat color and species Camera Angle Brightness of the picture Scale variation (cat is very large or small in image) 7) Test with your own image (optional/ungraded exercise)Congratulations on finishing this assignment. You can use your own image and see the output of your model. To do that: 1. Click on &quot;File&quot; in the upper bar of this notebook, then click &quot;Open&quot; to go on your Coursera Hub. 2. Add your image to this Jupyter Notebook&#39;s directory, in the &quot;images&quot; folder 3. Change your image&#39;s name in the following code 4. Run the code and check if the algorithm is right (1 = cat, 0 = non-cat)! 12345678910111213## START CODE HERE ##my_image = "my_image.jpg" # change this to the name of your image file my_label_y = [1] # the true class of your image (1 -&gt; cat, 0 -&gt; non-cat)## END CODE HERE ##fname = "" + my_imageimage = np.array(ndimage.imread(fname, flatten=False))my_image = scipy.misc.imresize(image, size=(num_px,num_px)).reshape((num_px*num_px*3,1))my_image = my_image/255.my_predicted_image = predict(my_image, my_label_y, parameters)plt.imshow(image)print ("y = " + str(np.squeeze(my_predicted_image)) + ", your L-layer model predicts a \"" + classes[int(np.squeeze(my_predicted_image)),].decode("utf-8") + "\" picture.") Accuracy: 1.0 y = 1.0, your L-layer model predicts a &quot;cat&quot; picture. References: for auto-reloading external module: http://stackoverflow.com/questions/1907993/autoreload-of-modules-in-ipython]]></content>
      <tags>
        <tag>Deeplearning.ai</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows局域网与手机共享文件以及iOS文件操作]]></title>
    <url>%2F2018%2F05%2F16%2Fwindows-LAN-share-data-ios-upload-airplay%2F</url>
    <content type="text"><![CDATA[相关背景由于最近拍的照片比较多，有一些需要传到电脑里进行备份。还有，有将电脑里的文件用手机投屏到电视上或投影仪上的需求。因此，有网络硬盘做存储中心，手机做控制中心的需求。 我只是个人进行文件备份，对延迟没有突出需求，所以决定将电脑作为局域网中的NAS。 Windows做文件共享此步骤参考了百度经验 右击桌面网络——属性——更改高级共享设置 （注释：查看当前网络 比如：家庭网络、公共网络 等!) “我这里为公共网络” 选择 公共网络—-选择以下选项：启动网络发现———启动文件和打印机共享——-启用共享以便可以访问网络的用户可以读取和写入公用文件夹中的文件(可以不选）——关闭密码保护共享( 注释：其他选项默认即可!) 保存！ 选择需要共享的文件夹 (比如：DY) 右击—属性 共享—— 选择 共享（S）…—-弹出对话框—-添加“Guest”（注释：选择“Guest”是为了降低权限，以方便于所有用户都能访问！）—-共享 选择 高级共享… ——选择 共享此文件 ——确定！ 其他用户，通过开始—-运行—-\IP （快捷键 WIN+R）\IP 访问你共享的文件! 共享成功!ios共享数据下载FileExplorer本教程参考自iOS神器FileExplorer精简使用教程具体操作方法为： 保持 Windows 和 iPad 在同一局域网环境下，如：使用同一个WiFi。 点击右上角“+号”，选择Windows 往下拉，选择网络邻居里的项目（如图即：DESKTOP-71EDJSC），并选择“注册的用户”\ 输入Windows的账户名和密码，然后，尽情浏览你的共享文件吧 win10：遇到权限不足时，点击设置-帐户-你的电子邮件和帐户-改用本地帐户登录，使用此时的帐号密码登录 FileExplorer 即可。 其余操作可以到FE官方文档查看 ios文件上传照片与文件上传具体操作查看FE文件传输 ios11文件格式问题ios11之后，iphone的照片格式变成了.heic，所以windows也无法查看与转换，有两种转换方法： 单独上传可以用ios自带的 文件 进行转换然后将icloud里面的文件复制到windows文件夹中。 批量上传可以使用批量转换工具，我使用的是开源的转换工具HEIF Utility，github地址为HEIF Utility 共享文件投屏具体操作方法查看FE投屏方法。 注意这里需要你的投放设备支持DLNA协议的设备，如果搜不到airplay设备，可以给你的设备下载投屏工具，类似于乐播投屏。 iphone通过airplay音频输出到windows可以使用shairport4w]]></content>
      <tags>
        <tag>运维</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deeplearning.ai 笔记作业（一）week3]]></title>
    <url>%2F2018%2F05%2F15%2Fdeeplearning-ai-nn-and-dl-week3%2F</url>
    <content type="text"><![CDATA[第一章 神经网络和深度学习 Week3 笔记神经网络概要 主要讲了神经网络要分层，分为输入层，隐藏层，输出层。输入层可以认为是layer0，layer1可以认为是hidden layer，layer2可以认为是output layer。参数 W 和 b 可以用上角标表示，比如第一层W[1]和b[1].同时，用反向传播的方法，求dZ[1]等。 神经网络表示 a[i]表示第i层的激励(activation)，W 和 b 类似 计算神经网络的输出（前向传播） Given Input X: Z[1] = W[1]X + b[1] = W[1]a0 + b[1] a1 = $\sigma$(Z[1]) Z[2] = W[2]X + b[2] = W[2]a0 + b[2] a2 = $\sigma$(Z[2]) X = [X(1), X(2),…,X(m)] Z[1] = [Z[1](1), Z[1](2),…,Z[1](m)] 注意计算的时候一定要注意np.ndarry.shape的匹配。方括号表示层数，圆括号表示样本序号 激活函数 $\sigma(x)$: sigmoid函数 tanh(x) = $\frac{e^Z-e^-Z}{e^Z+e^-Z}$ = 1 - $\sigma(x)$ ReLU: max(0, x) leaky ReLU: max(0.001x, x) tanh常用于做激励函数，因为tanh的mean是0，而sigmoid函数的mean是0.5，因此这样做可以做到规格化的作用，使得结果更接近于0，给模型更多优化。使用sigmoid函数的场景是做二分类的时候进行。tanh函数和sigmoid函数会导致梯度弥散，在数值特别大的时候，会导致梯度会无限趋近于0，使得收敛速度慢，模型效果差。ReLU是NG默认使用的最优激励函数，如果不是二分类问题，这两个函数会使收敛速度变快，效果好。 为什么要使用非线性的激活函数a[2]=W[2](W[1]X+b[1])+b[2]=(W[2]W[1])X+(W[2]b[1]+b[2])=WX+b 我们将激活函数表示为非线性函数 g(x) 如果只是使用线性关系，无论网络有多少层，都只是现行的相加，只是复杂的逻辑回归，没有任何变化。 计算导数和神经网络的梯度下降由于链式法则可以发现，进行反向传播的时候，需要进行计算上一层的激活函数的导数。 梯度下降： Repeat{ output prtedict：y_hat dW[i]=$\frac{dJ}{dW^i}$ Wi=Wi - $\alpha$ dW[i] bi= bi - $\alpha$ db[i]} 反向传播 keepdims是防止产生了shape为(n_h,)这样的数组，而是要产生矩阵。 随机初始化参数如果都是用全0初始化参数，就会由于对称原理得每一层都会得到功能相同的神经元，所以无论训练多久都会一样，所以需要用随机。 W[i] = np.random.randn((2, 2)) * 0.01b[i] = np.zeros((2, 1)) 乘以的0.01是使得W参数变小，因为如果使用sigmoid的时候，会使输入的Z值特别大，使得在sigmoid的梯度特别小，这样会收敛速度会比较慢。 作业课堂小quiz下载或查看 Planar data classification with one hidden layerWelcome to your week 3 programming assignment. It’s time to build your first neural network, which will have a hidden layer. You will see a big difference between this model and the one you implemented using logistic regression. You will learn how to: Implement a 2-class classification neural network with a single hidden layer Use units with a non-linear activation function, such as tanh Compute the cross entropy loss Implement forward and backward propagation 1 - PackagesLet’s first import all the packages that you will need during this assignment. numpy is the fundamental package for scientific computing with Python. sklearn provides simple and efficient tools for data mining and data analysis. matplotlib is a library for plotting graphs in Python. testCases provides some test examples to assess the correctness of your functions planar_utils provide various useful functions used in this assignment 123456789101112# Package importsimport numpy as npimport matplotlib.pyplot as pltfrom testCases_v2 import *import sklearnimport sklearn.datasetsimport sklearn.linear_modelfrom planar_utils import plot_decision_boundary, sigmoid, load_planar_dataset, load_extra_datasets%matplotlib inlinenp.random.seed(1) # set a seed so that the results are consistent 2 - DatasetFirst, let’s get the dataset you will work on. The following code will load a “flower” 2-class dataset into variables X and Y. 1X, Y = load_planar_dataset() Visualize the dataset using matplotlib. The data looks like a “flower” with some red (label y=0) and some blue (y=1) points. Your goal is to build a model to fit this data. 12# Visualize the data:plt.scatter(X[0, :], X[1, :], c=Y, s=40, cmap=plt.cm.Spectral); You have: - a numpy-array (matrix) X that contains your features (x1, x2) - a numpy-array (vector) Y that contains your labels (red:0, blue:1). Lets first get a better sense of what our data is like. Exercise: How many training examples do you have? In addition, what is the shape of the variables X and Y? Hint: How do you get the shape of a numpy array? (help) 123456789### START CODE HERE ### (≈ 3 lines of code)shape_X = X.shapeshape_Y = Y.shapem = X.shape[1] # training set size### END CODE HERE ###print ('The shape of X is: ' + str(shape_X))print ('The shape of Y is: ' + str(shape_Y))print ('I have m = %d training examples!' % (m)) The shape of X is: (2, 400) The shape of Y is: (1, 400) I have m = 400 training examples! Expected Output: **shape of X** (2, 400) **shape of Y** (1, 400) **m** 400 3 - Simple Logistic RegressionBefore building a full neural network, lets first see how logistic regression performs on this problem. You can use sklearn’s built-in functions to do that. Run the code below to train a logistic regression classifier on the dataset. 123# Train the logistic regression classifierclf = sklearn.linear_model.LogisticRegressionCV();clf.fit(X.T, Y.T); /opt/conda/lib/python3.5/site-packages/sklearn/utils/validation.py:515: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel(). y = column_or_1d(y, warn=True) You can now plot the decision boundary of these models. Run the code below. 12345678# Plot the decision boundary for logistic regressionplot_decision_boundary(lambda x: clf.predict(x), X, Y)plt.title("Logistic Regression")# Print accuracyLR_predictions = clf.predict(X.T)print ('Accuracy of logistic regression: %d ' % float((np.dot(Y,LR_predictions) + np.dot(1-Y,1-LR_predictions))/float(Y.size)*100) + '% ' + "(percentage of correctly labelled datapoints)") Accuracy of logistic regression: 47 % (percentage of correctly labelled datapoints) Expected Output: **Accuracy** 47% Interpretation: The dataset is not linearly separable, so logistic regression doesn’t perform well. Hopefully a neural network will do better. Let’s try this now! 4 - Neural Network modelLogistic regression did not work well on the “flower dataset”. You are going to train a Neural Network with a single hidden layer. Here is our model: Mathematically: For one example $x^{(i)}$: z^{[1] (i)} = W^{[1]} x^{(i)} + b^{[1]}\tag{1}a^{[1] (i)} = \tanh(z^{[1] (i)})\tag{2}z^{[2] (i)} = W^{[2]} a^{[1] (i)} + b^{[2]}\tag{3}\hat{y}^{(i)} = a^{[2] (i)} = \sigma(z^{ [2] (i)})\tag{4}y^{(i)}_{prediction} = \begin{cases} 1 & \mbox{if } a^{[2](i)} > 0.5 \\ 0 & \mbox{otherwise } \end{cases}\tag{5}Given the predictions on all the examples, you can also compute the cost $J$ as follows: J = - \frac{1}{m} \sum\limits_{i = 0}^{m} \large\left(\small y^{(i)}\log\left(a^{[2] (i)}\right) + (1-y^{(i)})\log\left(1- a^{[2] (i)}\right) \large \right) \small \tag{6}Reminder: The general methodology to build a Neural Network is to: 1. Define the neural network structure ( # of input units, # of hidden units, etc). 2. Initialize the model&#39;s parameters 3. Loop: - Implement forward propagation - Compute loss - Implement backward propagation to get the gradients - Update parameters (gradient descent) You often build helper functions to compute steps 1-3 and then merge them into one function we call nn_model(). Once you’ve built nn_model() and learnt the right parameters, you can make predictions on new data. 4.1 - Defining the neural network structureExercise: Define three variables: - n_x: the size of the input layer - n_h: the size of the hidden layer (set this to 4) - n_y: the size of the output layer Hint: Use shapes of X and Y to find n_x and n_y. Also, hard code the hidden layer size to be 4. 12345678910111213141516171819# GRADED FUNCTION: layer_sizesdef layer_sizes(X, Y): """ Arguments: X -- input dataset of shape (input size, number of examples) Y -- labels of shape (output size, number of examples) Returns: n_x -- the size of the input layer n_h -- the size of the hidden layer n_y -- the size of the output layer """ ### START CODE HERE ### (≈ 3 lines of code) n_x = X.shape[0] # size of input layer n_h = 4 n_y = Y.shape[0] # size of output layer ### END CODE HERE ### return (n_x, n_h, n_y) 12345X_assess, Y_assess = layer_sizes_test_case()(n_x, n_h, n_y) = layer_sizes(X_assess, Y_assess)print("The size of the input layer is: n_x = " + str(n_x))print("The size of the hidden layer is: n_h = " + str(n_h))print("The size of the output layer is: n_y = " + str(n_y)) The size of the input layer is: n_x = 5 The size of the hidden layer is: n_h = 4 The size of the output layer is: n_y = 2 Expected Output (these are not the sizes you will use for your network, they are just used to assess the function you’ve just coded). **n_x** 5 **n_h** 4 **n_y** 2 4.2 - Initialize the model’s parametersExercise: Implement the function initialize_parameters(). Instructions: Make sure your parameters’ sizes are right. Refer to the neural network figure above if needed. You will initialize the weights matrices with random values. Use: np.random.randn(a,b) * 0.01 to randomly initialize a matrix of shape (a,b). You will initialize the bias vectors as zeros. Use: np.zeros((a,b)) to initialize a matrix of shape (a,b) with zeros. 123456789101112131415161718192021222324252627282930313233343536# GRADED FUNCTION: initialize_parametersdef initialize_parameters(n_x, n_h, n_y): """ Argument: n_x -- size of the input layer n_h -- size of the hidden layer n_y -- size of the output layer Returns: params -- python dictionary containing your parameters: W1 -- weight matrix of shape (n_h, n_x) b1 -- bias vector of shape (n_h, 1) W2 -- weight matrix of shape (n_y, n_h) b2 -- bias vector of shape (n_y, 1) """ np.random.seed(2) # we set up a seed so that your output matches ours although the initialization is random. ### START CODE HERE ### (≈ 4 lines of code) W1 = np.random.randn(n_h, n_x) * 0.01 b1 = np.zeros((n_h, 1)) W2 = np.random.randn(n_y, n_h) * 0.01 b2 = np.zeros((n_y, 1)) ### END CODE HERE ### assert (W1.shape == (n_h, n_x)) assert (b1.shape == (n_h, 1)) assert (W2.shape == (n_y, n_h)) assert (b2.shape == (n_y, 1)) parameters = &#123;"W1": W1, "b1": b1, "W2": W2, "b2": b2&#125; return parameters 1234567n_x, n_h, n_y = initialize_parameters_test_case()parameters = initialize_parameters(n_x, n_h, n_y)print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) W1 = [[-0.00416758 -0.00056267] [-0.02136196 0.01640271] [-0.01793436 -0.00841747] [ 0.00502881 -0.01245288]] b1 = [[ 0.] [ 0.] [ 0.] [ 0.]] W2 = [[-0.01057952 -0.00909008 0.00551454 0.02292208]] b2 = [[ 0.]] Expected Output: * *W1** [[-0.00416758 -0.00056267] [-0.02136196 0.01640271] [-0.01793436 -0.00841747] [ 0.00502881 -0.01245288]] **b1** [[ 0.] [ 0.] [ 0.] [ 0.]] **W2** [[-0.01057952 -0.00909008 0.00551454 0.02292208]] **b2** [[ 0.]] 4.3 - The LoopQuestion: Implement forward_propagation(). Instructions: Look above at the mathematical representation of your classifier. You can use the function sigmoid(). It is built-in (imported) in the notebook. You can use the function np.tanh(). It is part of the numpy library. The steps you have to implement are: Retrieve each parameter from the dictionary “parameters” (which is the output of initialize_parameters()) by using parameters[&quot;..&quot;]. Implement Forward Propagation. Compute $Z^{[1]}, A^{[1]}, Z^{[2]}$ and $A^{[2]}$ (the vector of all your predictions on all the examples in the training set). Values needed in the backpropagation are stored in “cache“. The cache will be given as an input to the backpropagation function. 123456789101112131415161718192021222324252627282930313233343536# GRADED FUNCTION: forward_propagationdef forward_propagation(X, parameters): """ Argument: X -- input data of size (n_x, m) parameters -- python dictionary containing your parameters (output of initialization function) Returns: A2 -- The sigmoid output of the second activation cache -- a dictionary containing "Z1", "A1", "Z2" and "A2" """ # Retrieve each parameter from the dictionary "parameters" ### START CODE HERE ### (≈ 4 lines of code) W1 = parameters['W1'] b1 = parameters['b1'] W2 = parameters['W2'] b2 = parameters['b2'] ### END CODE HERE ### # Implement Forward Propagation to calculate A2 (probabilities) ### START CODE HERE ### (≈ 4 lines of code) Z1 = np.dot(W1, X) + b1 A1 = np.tanh(Z1) Z2 = np.dot(W2, A1) + b2 A2 = 1.0 / (1.0 + np.exp(-Z2)) ### END CODE HERE ### assert(A2.shape == (1, X.shape[1])) cache = &#123;"Z1": Z1, "A1": A1, "Z2": Z2, "A2": A2&#125; return A2, cache 12345X_assess, parameters = forward_propagation_test_case()A2, cache = forward_propagation(X_assess, parameters)# Note: we use the mean here just to make sure that your output matches ours. print(np.mean(cache['Z1']) ,np.mean(cache['A1']),np.mean(cache['Z2']),np.mean(cache['A2'])) 0.262818640198 0.091999045227 -1.30766601287 0.212877681719 Expected Output: 0.262818640198 0.091999045227 -1.30766601287 0.212877681719 Now that you have computed $A^{[2]}$ (in the Python variable “A2“), which contains $a^{2}$ for every example, you can compute the cost function as follows: J = - \frac{1}{m} \sum\limits_{i = 0}^{m} \large{(} \small y^{(i)}\log\left(a^{[2] (i)}\right) + (1-y^{(i)})\log\left(1- a^{[2] (i)}\right) \large{)} \small\tag{13}Exercise: Implement compute_cost() to compute the value of the cost $J$. Instructions: There are many ways to implement the cross-entropy loss. To help you, we give you how we would have implemented$- \sum\limits_{i=0}^{m} y^{(i)}\log(a^{2})$:12logprobs = np.multiply(np.log(A2),Y)cost = - np.sum(logprobs) # no need to use a for loop! (you can use either np.multiply() and then np.sum() or directly np.dot()). 1234567891011121314151617181920212223242526272829303132# GRADED FUNCTION: compute_costdef compute_cost(A2, Y, parameters): """ Computes the cross-entropy cost given in equation (13) Arguments: A2 -- The sigmoid output of the second activation, of shape (1, number of examples) Y -- "true" labels vector of shape (1, number of examples) parameters -- python dictionary containing your parameters W1, b1, W2 and b2 Returns: cost -- cross-entropy cost given equation (13) """ m = Y.shape[1] # number of example # Compute the cross-entropy cost ### START CODE HERE ### (≈ 2 lines of code) logprobs = np.multiply(np.log(A2), Y) # 此方法不行，因为生成的类型是numpy.ndarray cost = -(float(np.dot(np.log(A2), Y.T)) + np.dot(np.log(1.0 - A2), (1 - Y.T))) / m # 此方法做法是做内积，所以生成的是np.float64 cost = - np.sum(np.multiply(np.log(A2), Y) + np.multiply(np.log(1. - A2), 1. - Y)) / m ### END CODE HERE ### cost = np.squeeze(cost) # makes sure cost is the dimension we expect. # E.g., turns [[17]] into 17 assert(isinstance(cost, float)) return cost 123A2, Y_assess, parameters = compute_cost_test_case()print("cost = " + str(compute_cost(A2, Y_assess, parameters))) cost = 0.693058761039 Expected Output: **cost** 0.693058761... Using the cache computed during forward propagation, you can now implement backward propagation. Question: Implement the function backward_propagation(). Instructions:Backpropagation is usually the hardest (most mathematical) part in deep learning. To help you, here again is the slide from the lecture on backpropagation. You’ll want to use the six equations on the right of this slide, since you are building a vectorized implementation. Tips: To compute dZ1 you’ll need to compute $g^{[1]’}(Z^{[1]})$. Since $g^{[1]}(.)$ is the tanh activation function, if $a = g^{[1]}(z)$ then $g^{[1]’}(z) = 1-a^2$. So you can compute$g^{[1]’}(Z^{[1]})$ using (1 - np.power(A1, 2)). 123456789101112131415161718192021222324252627282930313233343536373839404142434445# GRADED FUNCTION: backward_propagationdef backward_propagation(parameters, cache, X, Y): """ Implement the backward propagation using the instructions above. Arguments: parameters -- python dictionary containing our parameters cache -- a dictionary containing "Z1", "A1", "Z2" and "A2". X -- input data of shape (2, number of examples) Y -- "true" labels vector of shape (1, number of examples) Returns: grads -- python dictionary containing your gradients with respect to different parameters """ m = X.shape[1] # First, retrieve W1 and W2 from the dictionary "parameters". ### START CODE HERE ### (≈ 2 lines of code) W1 = parameters['W1'] W2 = parameters['W2'] ### END CODE HERE ### # Retrieve also A1 and A2 from dictionary "cache". ### START CODE HERE ### (≈ 2 lines of code) A1 = cache['A1'] A2 = cache['A2'] ### END CODE HERE ### # Backward propagation: calculate dW1, db1, dW2, db2. ### START CODE HERE ### (≈ 6 lines of code, corresponding to 6 equations on slide above) dZ2 = A2 - Y dW2 = np.dot(dZ2, A1.T) / m db2 = np.sum(dZ2, axis = 1, keepdims = True) / m dZ1 = np.dot(W2.T, dZ2) * (1 - np.power(A1, 2)) dW1 = np.dot(dZ1, X.T) / m db1 = np.sum(dZ1, axis = 1, keepdims = True) / m ### END CODE HERE ### grads = &#123;"dW1": dW1, "db1": db1, "dW2": dW2, "db2": db2&#125; return grads 1234567parameters, cache, X_assess, Y_assess = backward_propagation_test_case()grads = backward_propagation(parameters, cache, X_assess, Y_assess)print ("dW1 = "+ str(grads["dW1"]))print ("db1 = "+ str(grads["db1"]))print ("dW2 = "+ str(grads["dW2"]))print ("db2 = "+ str(grads["db2"])) dW1 = [[ 0.00301023 -0.00747267] [ 0.00257968 -0.00641288] [-0.00156892 0.003893 ] [-0.00652037 0.01618243]] db1 = [[ 0.00176201] [ 0.00150995] [-0.00091736] [-0.00381422]] dW2 = [[ 0.00078841 0.01765429 -0.00084166 -0.01022527]] db2 = [[-0.16655712]] Expected output: **dW1** [[ 0.00301023 -0.00747267] [ 0.00257968 -0.00641288] [-0.00156892 0.003893 ] [-0.00652037 0.01618243]] **db1** [[ 0.00176201] [ 0.00150995] [-0.00091736] [-0.00381422]] **dW2** [[ 0.00078841 0.01765429 -0.00084166 -0.01022527]] **db2** [[-0.16655712]] Question: Implement the update rule. Use gradient descent. You have to use (dW1, db1, dW2, db2) in order to update (W1, b1, W2, b2). General gradient descent rule: $ \theta = \theta - \alpha \frac{\partial J }{ \partial \theta }$ where $\alpha$ is the learning rate and $\theta$ represents a parameter. Illustration: The gradient descent algorithm with a good learning rate (converging) and a bad learning rate (diverging). Images courtesy of Adam Harley. 12345678910111213141516171819202122232425262728293031323334353637383940414243# GRADED FUNCTION: update_parametersdef update_parameters(parameters, grads, learning_rate = 1.2): """ Updates parameters using the gradient descent update rule given above Arguments: parameters -- python dictionary containing your parameters grads -- python dictionary containing your gradients Returns: parameters -- python dictionary containing your updated parameters """ # Retrieve each parameter from the dictionary "parameters" ### START CODE HERE ### (≈ 4 lines of code) W1 = parameters['W1'] b1 = parameters['b1'] W2 = parameters['W2'] b2 = parameters['b2'] ### END CODE HERE ### # Retrieve each gradient from the dictionary "grads" ### START CODE HERE ### (≈ 4 lines of code) dW1 = grads['dW1'] db1 = grads['db1'] dW2 = grads['dW2'] db2 = grads['db2'] ## END CODE HERE ### # Update rule for each parameter ### START CODE HERE ### (≈ 4 lines of code) W1 = W1 - learning_rate * dW1 b1 = b1 - learning_rate * db1 W2 = W2 - learning_rate * dW2 b2 = b2 - learning_rate * db2 ### END CODE HERE ### parameters = &#123;"W1": W1, "b1": b1, "W2": W2, "b2": b2&#125; return parameters 1234567parameters, grads = update_parameters_test_case()parameters = update_parameters(parameters, grads)print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) W1 = [[-0.00643025 0.01936718] [-0.02410458 0.03978052] [-0.01653973 -0.02096177] [ 0.01046864 -0.05990141]] b1 = [[ -1.02420756e-06] [ 1.27373948e-05] [ 8.32996807e-07] [ -3.20136836e-06]] W2 = [[-0.01041081 -0.04463285 0.01758031 0.04747113]] b2 = [[ 0.00010457]] Expected Output: **W1** [[-0.00643025 0.01936718] [-0.02410458 0.03978052] [-0.01653973 -0.02096177] [ 0.01046864 -0.05990141]] **b1** [[ -1.02420756e-06] [ 1.27373948e-05] [ 8.32996807e-07] [ -3.20136836e-06]] **W2** [[-0.01041081 -0.04463285 0.01758031 0.04747113]] **b2** [[ 0.00010457]] 4.4 - Integrate parts 4.1, 4.2 and 4.3 in nn_model()Question: Build your neural network model in nn_model(). Instructions: The neural network model has to use the previous functions in the right order. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# GRADED FUNCTION: nn_modeldef nn_model(X, Y, n_h, num_iterations = 10000, print_cost=False): """ Arguments: X -- dataset of shape (2, number of examples) Y -- labels of shape (1, number of examples) n_h -- size of the hidden layer num_iterations -- Number of iterations in gradient descent loop print_cost -- if True, print the cost every 1000 iterations Returns: parameters -- parameters learnt by the model. They can then be used to predict. """ np.random.seed(3) n_x = layer_sizes(X, Y)[0] n_y = layer_sizes(X, Y)[2] # Initialize parameters, then retrieve W1, b1, W2, b2. Inputs: "n_x, n_h, n_y". Outputs = "W1, b1, W2, b2, parameters". ### START CODE HERE ### (≈ 5 lines of code) parameters = initialize_parameters(n_x, n_h, n_y) W1 = parameters['W1'] b1 = parameters['b1'] W2 = parameters['W2'] b2 = parameters['b2'] ### END CODE HERE ### # Loop (gradient descent) for i in range(0, num_iterations): ### START CODE HERE ### (≈ 4 lines of code) # Forward propagation. Inputs: "X, parameters". Outputs: "A2, cache". A2, cache = forward_propagation(X, parameters) # Cost function. Inputs: "A2, Y, parameters". Outputs: "cost". cost = compute_cost(A2, Y, parameters) # Backpropagation. Inputs: "parameters, cache, X, Y". Outputs: "grads". grads = backward_propagation(parameters, cache, X, Y) # Gradient descent parameter update. Inputs: "parameters, grads". Outputs: "parameters". parameters = update_parameters(parameters, grads) ### END CODE HERE ### # Print the cost every 1000 iterations if print_cost and i % 1000 == 0: print ("Cost after iteration %i: %f" %(i, cost)) return parameters 123456X_assess, Y_assess = nn_model_test_case()parameters = nn_model(X_assess, Y_assess, 4, num_iterations=10000, print_cost=True)print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) Cost after iteration 0: 0.692739 Cost after iteration 1000: 0.000218 Cost after iteration 2000: 0.000107 Cost after iteration 3000: 0.000071 Cost after iteration 4000: 0.000053 Cost after iteration 5000: 0.000042 Cost after iteration 6000: 0.000035 Cost after iteration 7000: 0.000030 Cost after iteration 8000: 0.000026 Cost after iteration 9000: 0.000023 W1 = [[-0.65848169 1.21866811] [-0.76204273 1.39377573] [ 0.5792005 -1.10397703] [ 0.76773391 -1.41477129]] b1 = [[ 0.287592 ] [ 0.3511264 ] [-0.2431246 ] [-0.35772805]] W2 = [[-2.45566237 -3.27042274 2.00784958 3.36773273]] b2 = [[ 0.20459656]] Expected Output: **cost after iteration 0** 0.692739 $\vdots$ $\vdots$ **W1** [[-0.65848169 1.21866811] [-0.76204273 1.39377573] [ 0.5792005 -1.10397703] [ 0.76773391 -1.41477129]] **b1** [[ 0.287592 ] [ 0.3511264 ] [-0.2431246 ] [-0.35772805]] **W2** [[-2.45566237 -3.27042274 2.00784958 3.36773273]] **b2** [[ 0.20459656]] 4.5 PredictionsQuestion: Use your model to predict by building predict().Use forward propagation to predict results. Reminder: predictions = $y_{prediction} = \mathbb 1 \textfalse = \begin{cases} 1 &amp; \text{if}\ activation &gt; 0.5 \ 0 &amp; \text{otherwise} \end{cases}$ As an example, if you would like to set the entries of a matrix X to 0 and 1 based on a threshold you would do: 12345678910111213141516171819202122232425```python# GRADED FUNCTION: predictdef predict(parameters, X): &quot;&quot;&quot; Using the learned parameters, predicts a class for each example in X Arguments: parameters -- python dictionary containing your parameters X -- input data of size (n_x, m) Returns predictions -- vector of predictions of our model (red: 0 / blue: 1) &quot;&quot;&quot; # Computes probabilities using forward propagation, and classifies to 0/1 using 0.5 as the threshold. ### START CODE HERE ### (≈ 2 lines of code) A2, cache = forward_propagation(X, parameters) predictions = list(map(lambda x : 0 if x &lt; 0.5 else 1, A2[0])) predictions = np.array([predictions]) ### END CODE HERE ### return predictions 1234parameters, X_assess = predict_test_case()predictions = predict(parameters, X_assess)print("predictions mean = " + str(np.mean(predictions))) predictions mean = 0.666666666667 Expected Output: **predictions mean** 0.666666666667 It is time to run the model and see how it performs on a planar dataset. Run the following code to test your model with a single hidden layer of $n_h$ hidden units. 123456# Build a model with a n_h-dimensional hidden layerparameters = nn_model(X, Y, n_h = 4, num_iterations = 10000, print_cost=True)# Plot the decision boundaryplot_decision_boundary(lambda x: predict(parameters, x.T), X, Y)plt.title("Decision Boundary for hidden layer size " + str(4)) Cost after iteration 0: 0.693048 Cost after iteration 1000: 0.288083 Cost after iteration 2000: 0.254385 Cost after iteration 3000: 0.233864 Cost after iteration 4000: 0.226792 Cost after iteration 5000: 0.222644 Cost after iteration 6000: 0.219731 Cost after iteration 7000: 0.217504 Cost after iteration 8000: 0.219471 Cost after iteration 9000: 0.218612 &lt;matplotlib.text.Text at 0x7f0bbeb25898&gt; Expected Output: **Cost after iteration 9000** 0.218607 123# Print accuracypredictions = predict(parameters, X)print ('Accuracy: %d' % float((np.dot(Y,predictions.T) + np.dot(1-Y,1-predictions.T))/float(Y.size)*100) + '%') Accuracy: 90% Expected Output: **Accuracy** 90% Accuracy is really high compared to Logistic Regression. The model has learnt the leaf patterns of the flower! Neural networks are able to learn even highly non-linear decision boundaries, unlike logistic regression. Now, let’s try out several hidden layer sizes. 4.6 - Tuning hidden layer size (optional/ungraded exercise)Run the following code. It may take 1-2 minutes. You will observe different behaviors of the model for various hidden layer sizes. 123456789101112# This may take about 2 minutes to runplt.figure(figsize=(16, 32))hidden_layer_sizes = [1, 2, 3, 4, 5, 20, 50]for i, n_h in enumerate(hidden_layer_sizes): plt.subplot(5, 2, i+1) plt.title('Hidden Layer of size %d' % n_h) parameters = nn_model(X, Y, n_h, num_iterations = 5000) plot_decision_boundary(lambda x: predict(parameters, x.T), X, Y) predictions = predict(parameters, X) accuracy = float((np.dot(Y,predictions.T) + np.dot(1-Y,1-predictions.T))/float(Y.size)*100) print ("Accuracy for &#123;&#125; hidden units: &#123;&#125; %".format(n_h, accuracy)) Accuracy for 1 hidden units: 67.5 % Accuracy for 2 hidden units: 67.25 % Accuracy for 3 hidden units: 90.75 % Accuracy for 4 hidden units: 90.5 % Accuracy for 5 hidden units: 91.25 % Accuracy for 20 hidden units: 90.0 % Accuracy for 50 hidden units: 90.25 % Interpretation: The larger models (with more hidden units) are able to fit the training set better, until eventually the largest models overfit the data. The best hidden layer size seems to be around n_h = 5. Indeed, a value around here seems to fits the data well without also incurring noticable overfitting. You will also learn later about regularization, which lets you use very large models (such as n_h = 50) without much overfitting. Optional questions: Note: Remember to submit the assignment but clicking the blue “Submit Assignment” button at the upper-right. Some optional/ungraded questions that you can explore if you wish: What happens when you change the tanh activation for a sigmoid activation or a ReLU activation? Play with the learning_rate. What happens? What if we change the dataset? (See part 5 below!) You’ve learnt to: Build a complete neural network with a hidden layer Make a good use of a non-linear unit Implemented forward propagation and backpropagation, and trained a neural network See the impact of varying the hidden layer size, including overfitting. Nice work! 5) Performance on other datasetsIf you want, you can rerun the whole notebook (minus the dataset part) for each of the following datasets. 123456789101112131415161718192021# Datasetsnoisy_circles, noisy_moons, blobs, gaussian_quantiles, no_structure = load_extra_datasets()datasets = &#123;"noisy_circles": noisy_circles, "noisy_moons": noisy_moons, "blobs": blobs, "gaussian_quantiles": gaussian_quantiles&#125;### START CODE HERE ### (choose your dataset)dataset = "noisy_moons"### END CODE HERE ###X, Y = datasets[dataset]X, Y = X.T, Y.reshape(1, Y.shape[0])# make blobs binaryif dataset == "blobs": Y = Y%2# Visualize the dataplt.scatter(X[0, :], X[1, :], c=Y, s=40, cmap=plt.cm.Spectral); Congrats on finishing this Programming Assignment! Reference: http://scs.ryerson.ca/~aharley/neural-networks/ http://cs231n.github.io/neural-networks-case-study/]]></content>
      <tags>
        <tag>Deeplearning.ai</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客（hexo next）日志及校外ipv6 bt访问工具]]></title>
    <url>%2F2018%2F04%2F27%2Fblog-build-and-ipv6-tools%2F</url>
    <content type="text"><![CDATA[博客就是记录最近的工作，所以就把这个博客的搭建过程以及校外访问bt小工具的日志作为个人博客的第一篇。 博客搭建过程调研直接看步骤 我在知乎上翻阅了大部分关于博客工具的回答，基本了解个人博客一般采用脚本语言搭建Web（比如Django等）和静态网页工具两种。由于不想增加额外的运维成本，基本定位到静态网页工具上。由于不想在前端模板方面投入太多精力，所以基本去找有比较稳定的主题的工具。参考准备自己建一个个人博客，有什么好的框架推荐？ - 知乎和一些其他的文章，基本把调研内容锁定在jekyll和hexo两种工具上。 Jekyll是基于Ruby脚本实现的博客生成工具，是经常与Github Pages配合使用的工具。目前比较常用的主题是huxpro，我之前的同事王喆的博客也是基于这个主题构建的。但是，经过试验发现，主题代码已经更新较多，相关文档却没有对应更新，一些设置找不到对应文档只能去查看源码，所以测试了Hexo之后选取了Hexo。但是，毕竟Jekyll是Github配套工具，相关的主题也比较完整，所以想要自己折腾的可以多尝试尝试。 Hexo是基于Node.js脚本实现的博客生成类工具，如果你之前做过有关node的工作，相对接触Hexo也比较简单。Hexo比较流行的主题是Next，功能没有那么丰富，所以配置相对简单而且全面，文档十分详细，运维成本低。而且Hexo的官网还有对应的youtube视频可以看，懒得看的可以对着视频做也不会出错。 详细教程可以在Hexo官网查看，以下给出简单步骤。 步骤安装Node.js，windows的可以下载，其余同学可以用Node Version Manager安装1234# 安装nvm$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash# 安装Node.js$ nvm install stable 安装git可以参考 git 准备工作如果想要查看详细的说明可以查看 next 安装Hexo1$ npm install -g hexo-cli 博客初始化123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 下载主题12$ cd &lt;folder&gt;$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题，编辑_config.yml，找到theme字段，改为next 1theme: next 验证主题 hexo s —debug，显示以下内容，访问http://localhost:4000如果发现未生效，清除Hexo静态文件hexo clean再执行，以后的步骤任意改动类似。 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 配置选择设计效果Scheme，修改themes\next_config.yml，我采用的主题版本实现了四种效果，选取了Gemini。12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 设置中文_config.yml 1language: zh-Hans 设置菜单themes\next_config.yml，Next使用的是Font Awesome，如果你想要的菜单图标没有显示，可以在网站上寻找理想的图标并在 ||后修改。如果想要icon生效，可以将menu_icons的enable设置为true 123456789menu: home: / || home about: /About/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 设置头像themes\next_config.yml，可以选取互联网地址或者本地地址1avatar: http://www.wuzequn.com/images/touxiang.png 设置代码高亮themes\next_config.yml，next使用的是Tomorrow Theme，可以在链接中查看高亮效果。12345# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night 设置侧边栏社交链接themes\next_config.yml，图标的设置和菜单类似。1234567891011# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: #GitHub: https://github.com/yourname || github 邮件: mailto:wuzqbupt@gmail.com || envelope 知乎: https://www.zhihu.com/people/wu-ze-qun || globe 微博: https://weibo.com/u/1922768971 || weibo 领英: https://www.linkedin.com/in/zequn-wu-038a5b133/ || linkedin 网页访问量统计themes\next_config.yml，代码是基于不蒜子统计实现的。1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer: 本地搜索 安装hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 配置_config.yml，增加以下内容： 12345search: path: search.xml field: post format: html limit: 10000 配置themes\next_config.yml，启用本地搜索功能 12345search: path: search.xml field: post format: html limit: 10000 其他类似于昵称和站点描述等信息可以在_config.yml里修改。 内容编辑Hexo的内容都可以用Markdown，具体的格式可以参考教程 about页面首先生成about页面，首先在站点的根目录下执行以下命令：1$ hexo new page About 然后会在source目录下生成一个About文件夹，然后编辑source/About/index.md介绍你自己。 tags页面首先生成about页面，首先在站点的根目录下执行以下命令：1$ hexo new page tags 然后会在source目录下生成一个tags文件夹，然后编辑source/tags/index.md，修改为:123456---title: tagsdate: 20xx-xx-xx xx:xx:xxtype: &quot;tags&quot;comments: false--- categories页面首先生成categories页面，首先在站点的根目录下执行以下命令：1$ hexo new page categories 然后会在source目录下生成一个categories文件夹，然后编辑source/categories/index.md，修改为:123456---title: categoriesdate: 20xx-xx-xx xx:xx:xxtype: &quot;categories&quot;comments: false--- 内容操作hexo有三种内容类型，分别文page，post，draft。可以用以下内容新建：1$ hexo new [page|post|code] &lt;file-name&gt; page就是基础页面，你可以在http;//127.0.0.1/后添加页面名称访问到对应文件夹下内容。 post新建到source目录下，名称就是文件名称。 如果不想发布未编辑完成的草稿，可以新建draft，待编辑完成，发布草稿。1$ hexo publish &lt;draft-name&gt; 发布网站Hexo是用脚本将Markdown文件生成静态html页面的工具，用一下命令生成一个public静态文件夹。1$ hexo generate 同时，Hexo也提供了一个服务器用于显示内容。ye也可以加-p选项配置http端口，默认为40001$ hexo server 如果发现你的修改没有生效，可以执行以下命令清楚数据文件和public文件夹，之后再重新生成。1$ hexo clean 另外，hexo也提供了将静态文件夹部署的功能，我使用了码市作为git仓库网站，具体配置git方法可以参考，本地需要配置_config.yml并安装hexo-deployer-git，更多部署方式可以参考123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://&lt;git-address&gt; branch: &lt;branch-name&gt; 执行以下命令，就可以将public中的静态文件上传到git仓库。1$ hexo deploy 如果你采用Github.io作为展示方案，参考教程，执行完部署步骤，就可以将静态文件部署到Github.io上。 其他修改操作 hexo插入本地图片资源 插入公式：在博客的添加mathjax: true 常用的Markdown数学公式 Markdown插入Jupyter Notebook vpsvps购买由于之后还需要搭建科学上网小工具和ipv6工具，所以在选取vps运营商的时候看重有ipv6出口，所以根据同学建议选择了搬瓦工OpenVZ的云主机。 之后又调研了vps运营商，发现还有AplhaRacks的7美元方案，对于不注重运行速度的童鞋可以采用这个方案。 同时推荐直呼过瘾，查询性价比比较高的方案，但是要注意如果要搭建ipv6小工具，需要注意vps中有ipv6通道。 博客配置环境：CentOS 7 64 bit 博客采用的是Nginx作为Web服务器，安装Nginx：12$ sudo yum install epel-release$ sudo yum install nginx 从git拉取代码并授权123$ git clone https://&lt;your-repo-address&gt;$ cd &lt;git-dir&gt;$ sudo chmod -R 777 . 配置Nginx，将Nginx访问的根目录配置为本地仓库的根目录。修改/etc/nginx/nginx.conf中的内容。12345678910111213141516171819202122server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; # root /usr/share/nginx/html; root &lt;your-repo-local-path&gt;; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; index index.html; autoindex on; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; https配置CentOS可以参考DigitalOcean的解决方案。 但是，配置了HTTPS之后，如果不购买CA证书，Chrome就会在网站显示Not Secure。如果觉得不需要购买，可以取消HTTPS。 12345678# 失效SSL$ mv /etc/nginx/conf.d/ssl.conf /etc/nginx/conf.d/ssl.conf.bak # 失效redirect$ mv /etc/nginx/default.d/ssl-redirect.conf /etc/nginx/default.d/ssl-redirect.conf.bak# 检测配置文件格式$ nginx -t# 是配置生效$ nginx -s reload 此时，访问就会恢复HTTP。如果发现未生效，清除Chrome缓存数据。 2018-09-24 更新可以使用免费CA证书，我使用的是Let’s Encrypt，步骤如下: 123456789101112131415161718192021222324252627282930# 准备工作 python环境# 检查系统是否安装git,如果已经自带有git会出现git版本号，没有则需要我们自己安装git --version # git 安装yum install git# 检查Python的版本是否在2.7以上python -v //2.6版本# 安装python所需的包yum install zlib-develyum install bzip2-develyum install openssl-develyum install ncurses-develyum install sqlite-devel# 获取letsencryptgit clone https://github.com/letsencrypt/letsencrypt# 进入letsencrypt目录cd letsencrypt# 生成证书 -nginx为例./certbot --nginx certonly# 然后输入你的邮箱和所要添加https的域名# 生成秘钥完毕 上文DigitalOcean的解决方案中提到的nginx配置文件的秘钥路径：123#打开linux配置文件，找到HTTPS 443端口配置的server ssl_certificate /etc/letsencrypt/live/域名/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/域名/privkey.pem; 修改http配置，将http转成https服务：12345server &#123; listen 80; server_name 域名; return 301 https://域名$request_uri; &#125; 此时，CA证书90天会过期，过期所以需要续签：1./letsencrypt-auto renew --force-renewal 最后你可以通过以下网址检测https服务1https://www.ssllabs.com/ssltest/analyze.html?d=域名 域名注册域名注册商很多，国内需要实名注册，要求的内容较多且周期比较长。国外的注册商通常自己提供DNS服务器，对速度有一定的影响。 如果不是米商，个人博客通常还是选取性价比高的注册商。域名的购买需要注意两个要点： 注册价格，可以使用比价网站。 注意续租价格，一般.com的网站每年价格相同。 注册成功后将云主机ip绑定，绑定DNS可以参考百度经验。 校外访问bt ipv6小工具服务器端上网工具其实就是将本地无法访问的请求发送给可以访问的服务器，服务器取回数据后再转发给客户端。如上文，服务器采用的是搬瓦工的VPS，所以首先要在控制面板上开启ipv6地址。以root安装ss服务。123wget --no-check-certificate -O shadowsocks-go.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.shchmod +x shadowsocks-go.sh./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log 安装中会选择转发的端口和密码。安装完成后，会提示：12345678Congratulations, Shadowsocks-go server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_methodWelcome to visit:https://teddysun.com/392.htmlEnjoy it! 如果安装成功，ss服务会开机自动启动。 如果想卸载，可以执行：1./shadowsocks-go.sh uninstall 如果想要为多用户并行服务，可配置多转发端口，编辑/etc/shadowsocks/config.json:123456789101112&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password0&quot;, &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; &#125;, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;timeout&quot;:600&#125; 配置成功之后重启服务1234/etc/init.d/shadowsocks start/etc/init.d/shadowsocks stop/etc/init.d/shadowsocks restart/etc/init.d/shadowsocks status 2019-04-28更新另外，因为OVZ更新了，所以如果你使用的是KVM架构，也可以参考搬瓦工这篇文章用渠道技术搞定IPV6 客户端下载客户端，然后根据服务器的配置，编辑端口和密码。同时，shadowsocks客户端可以设置PAC规则，节省转发流量，也可以在PAC文件中增加转发网址。设置好后可以访问ipv6和科学上网，可以北邮人bt测试。 设置utorrent 打开设置 -&gt; 连接 代理服务选择socks5，代理127.0.0.1，端口1080，勾选通过代理服务器解析主机名和 对于点对点连接使用代理服务器 如果设置的系统代理方式为PAC代理，需要在PAC文件中加入.byr,cn。 其余工具安装 因为关于环境的安装都属于服务器运维相关的工作，所以将链接放到下面，以备以后使用 docker-ce因为使用的是搬瓦工，如果直接使用yum的docker版本会出现engine安装问题，所以使用搬瓦工官方的处理方法 ngrok内网穿透工具当服务处于内网过程中，客户端无法直接访问接口，这时候需要使用NAT转换代理，除了使用Nginx做代理，还可以使用Ngrok]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
</search>
