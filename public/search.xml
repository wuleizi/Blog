<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【面经】HULU部分编程算法题]]></title>
    <url>%2F2019%2F04%2F21%2Finterview-coding-HULU%2F</url>
    <content type="text"><![CDATA[本文收集网络上面试部分编程面经以供复习 Alien Language(待付费) 验证地址Leetcode 2691234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_set&gt;#include &lt;unordered_map&gt;using namespace std;string helper(vector&lt;string&gt;&amp; nums) &#123; int n = nums.size(); unordered_map&lt;char, unordered_set&lt;char&gt;&gt; adj; unordered_map&lt;char, int&gt; cnt; unordered_set&lt;char&gt; s; for (int i = 0; i &lt; n - 1; i++) &#123; int n1 = nums[i].size(), n2 = nums[i + 1].size(); for (int j = 0; j &lt; n1 &amp;&amp; j &lt; n2; j++) &#123; if (nums[i][j] != nums[i + 1][j]) &#123; adj[nums[i][j]].insert(nums[i + 1][j]); cnt[nums[i + 1][j]] ++; break; &#125; &#125; &#125; for (auto i : nums) &#123; for (auto j : i) &#123; s.insert(j); &#125; &#125; string cur; for (auto i : s) &#123; if (cnt.find(i) == cnt.end()) cur.push_back(i); &#125; string ret; while (true) &#123; string next; for (auto i : cur) &#123; ret.push_back(i); for (auto j : adj[i]) &#123; cnt[j]--; if (!cnt[j]) next.push_back(j); &#125; &#125; if (next.empty()) break; else cur = next; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;string&gt; nums; for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; nums.push_back(s); &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; Days of Our Lives 验证地址geeksforgeeks12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;long long&gt; helper(long long n, long long k) &#123; long long ans = n / 7; vector&lt;long long&gt; ret(7, ans); int c = n % 7; for (int i = 0; i &lt; c; i++) &#123; ret[(k - 1 + i) % 7] ++; &#125; return ret;&#125;int main() &#123; //code int t; cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) &#123; long long n, k; cin &gt;&gt; n &gt;&gt; k; auto ans = helper(n, k); for (int j = 0; j &lt; 6; j++) &#123; cout &lt;&lt; ans[j] &lt;&lt; " "; &#125; cout &lt;&lt; ans[6] &lt;&lt; endl; &#125; return 0;&#125; Connect Nodes at Same Level 验证地址geeksforgeeks1234567891011121314151617181920void connect(Node *p)&#123; // Your Code Here if (!p) return; Node* pre = p; pre-&gt;nextRight = NULL; while (true) &#123; while (pre &amp;&amp; !pre-&gt;left &amp;&amp; !pre-&gt;right) pre = pre-&gt;nextRight; if (!pre) return; auto temp = pre-&gt;left ? pre-&gt;left : pre-&gt;right; auto cur = temp; while (pre) &#123; if (pre-&gt;left) cur-&gt;nextRight = pre-&gt;left, cur = cur-&gt;nextRight; if (pre-&gt;right) cur-&gt;nextRight = pre-&gt;right, cur = cur-&gt;nextRight; pre = pre-&gt;nextRight; &#125; cur-&gt;nextRight = NULL; pre = temp; &#125;&#125; Maximum difference between node and its ancestor 验证地址geeksforgeeks 1234567891011121314151617int helper(Node* root, int&amp; ret) &#123; if (!root) return INT_MAX; int ans = INT_MAX; if (root-&gt;left) ans = min(ans, helper(root-&gt;left, ret)); if (root-&gt;right) ans = min(ans, helper(root-&gt;right, ret)); if (ans == INT_MAX) return root-&gt;data; ret = max(ret, root-&gt;data - ans); return min(root-&gt;data, ans);&#125;int maxDiff(Node* root)&#123; // Your code here if (!root) return INT_MIN; int ret = INT_MIN; helper(root, ret); return ret;&#125; Vertical Order Traversal of a Binary Tree 验证地址Leetcode 987 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool static cmp(const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b) &#123; return a.first == b.first ? a.second &lt; b.second : a.first &lt; b.first; &#125; vector&lt;vector&lt;int&gt;&gt; verticalTraversal(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (!root) return ret; vector&lt;pair&lt;TreeNode*, pair&lt;int, int&gt;&gt;&gt; cur; cur.push_back(&#123;root, &#123;0, 0&#125;&#125;); map&lt;int, vector&lt;pair&lt;int, int&gt;&gt;&gt; m; while (true) &#123; vector&lt;pair&lt;TreeNode*, pair&lt;int, int&gt;&gt;&gt; next; for (auto i : cur) &#123; m[i.second.first].push_back(&#123;i.second.second, i.first-&gt;val&#125;); if (i.first-&gt;left) next.push_back(&#123;i.first-&gt;left, &#123;i.second.first - 1, i.second.second + 1&#125;&#125;); if (i.first-&gt;right) next.push_back(&#123;i.first-&gt;right, &#123;i.second.first + 1, i.second.second + 1&#125;&#125;); &#125; if (next.empty()) break; cur = next; &#125; for (auto i : m) &#123; sort(i.second.begin(), i.second.end(), cmp); vector&lt;int&gt; temp; for (auto j : i.second) &#123; temp.push_back(j.second); &#125; ret.push_back(temp); &#125; return ret; &#125;&#125;; Top View of Binary Tree 验证地址geeksforgeeks 123456789101112131415161718192021222324252627void topView(struct Node *root)&#123; // Your code here unordered_map&lt;int, int&gt; m; if (!root) return; vector&lt;pair&lt;Node*, int&gt;&gt; cur; cur.push_back(&#123;root, 0&#125;); while (true) &#123; vector&lt;pair&lt;Node*, int&gt;&gt; next; for (auto i : cur) &#123; if (m.find(i.second) == m.end()) &#123; cout &lt;&lt; i.first-&gt;data &lt;&lt; " "; m[i.second] = i.first-&gt;data; &#125; if (i.first-&gt;left) &#123; next.push_back(&#123;i.first-&gt;left, i.second - 1&#125;); &#125; if (i.first-&gt;right) &#123; next.push_back(&#123;i.first-&gt;right, i.second + 1&#125;); &#125; &#125; if (next.empty()) break; cur = next; &#125; &#125; Smallest window in a string containing all the characters of another string 验证地址geeksforgeeks 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;climits&gt;using namespace std;string helper(string s, string p) &#123; unordered_map&lt;char, int&gt; m; for (auto i : p) m[i] ++; int ans = m.size(); int n= s.size(); int i = 0, j = 0; int len = INT_MAX; string ret = "-1"; while (i &lt;= j &amp;&amp; j &lt;= n) &#123; if (j &lt; n &amp;&amp; ans &gt; 0) &#123; if (m.find(s[j]) != m.end()) &#123; m[s[j]] --; if (!m[s[j]]) ans --; &#125; j++; &#125; else &#123; if (m.find(s[i]) != m.end()) &#123; if (!m[s[i]]) ans ++; m[s[i]] ++; &#125; i++; &#125; if (!ans) &#123; if (j - i &lt; len) &#123; len = j - i; ret = s.substr(i, len); &#125; &#125; &#125; return ret;&#125;int main() &#123; //code int t; cin &gt;&gt; t; for (auto i = 0; i &lt; t; i++) &#123; string s, p; cin &gt;&gt; s &gt;&gt; p; cout &lt;&lt; helper(s, p) &lt;&lt; endl; &#125; return 0;&#125; Simplify the directory path (Unix like) 题目参考自geeksforgeeks1234567891011121314151617181920212223242526272829&quot;/a/./&quot; --&gt; means stay at the current directory &apos;a&apos;&quot;/a/b/..&quot; --&gt; means jump to the parent directory from &apos;b&apos; to &apos;a&apos;&quot;////&quot; --&gt; consecutive multiple &apos;/&apos; are a valid path, they are equivalent to single &quot;/&quot;.Input : /home/Output : /homeInput : /a/./b/../../c/Output : /cInput : /a/..Output : /Input : /a/../Ouput : /Input : /../../../../../aOuput : /aInput : /a/./b/./c/./d/Ouput : /a/b/c/dInput : /a/../.././../../.Ouput : /Input : /a//b//c//////dOuput : /a/b/c/d 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 栈版本#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;using namespace std;string helper(string s) &#123; if (s.empty()) return "/"; if (s.back() != '/') s.push_back('/'); stack&lt;string&gt; st; string ans; for (auto i : s) &#123; if (i == '/') &#123; if (ans == "" || ans == ".") &#123; ans = ""; &#125; else if (ans == "..") &#123; if (!st.empty()) st.pop(); ans = ""; &#125; else &#123; st.push(ans); ans = ""; &#125; &#125; else &#123; ans.push_back(i); &#125; &#125; string ret; while (!st.empty()) &#123; ret = "/" + st.top() + ret; st.pop(); &#125; return ret.empty() ? "/" : ret;&#125;int main() &#123; while (true) &#123; string s; cin &gt;&gt; s; cout &lt;&lt; helper(s) &lt;&lt; endl; &#125; return 0;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 原地压缩版#include &lt;iostream&gt;using namespace std;int helper(string&amp; s) &#123; int n = s.size(); int index = 0; string ans; for (int i = 0; i &lt;= n; i++) &#123; if (i == n || s[i] == '/') &#123; if (ans == ".") &#123; while (index &gt; 0 &amp;&amp; s[index - 1] != '/') index--; index --; &#125; if (ans == "..") &#123; while (index &gt; 0 &amp;&amp; s[index - 1] != '/') index--; if (index) index --; while (index &gt; 0 &amp;&amp; s[index - 1] != '/') index--; if (index) index --; &#125; ans = ""; &#125; else &#123; s[index++] = '/'; while (i &lt; n &amp;&amp; s[i] != '/') &#123; ans.push_back(s[i]); s[index ++] = s[i++]; &#125; i --; &#125; &#125; if (!index) &#123; s = "/"; return 1; &#125; return index;&#125;int main() &#123; while (true) &#123; string s; cin &gt;&gt; s; int len = helper(s); cout &lt;&lt; s.substr(0, len) &lt;&lt; endl; &#125; return 0;&#125; 全排列打印数组的全排列123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;void dfs(string s, int index, vector&lt;string&gt;&amp; ret) &#123; int n = s.size(); if (index == n - 1) &#123; ret.push_back(s); return; &#125; for (int i = index; i &lt; n; i++) &#123; if (index != i &amp;&amp; s[i] == s[index]) continue; swap(s[index], s[i]); dfs(s, index + 1, ret); &#125;&#125;vector&lt;string&gt; helper(string s) &#123; vector&lt;string&gt; ret; if (s.empty()) return ret; sort(s.begin(), s.end()); dfs(s, 0, ret); return ret;&#125;int main() &#123; string s; cin &gt;&gt; s; for (auto i : helper(s)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 打印n个字符串的全排列第K个值（全排列个数不会溢出情况）1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;string helper(int n, int k) &#123; vector&lt;long long&gt; fac(n, 1); vector&lt;int&gt; nums(n, 0); for (int i = 1; i &lt; n; i++) &#123; fac[i] = fac[i - 1] * i; &#125; for (int i = 0; i &lt; n; i++) &#123; nums[i] = i + 1; &#125; string ret; for (int i = 0; i &lt; n; i++) &#123; int index = (k - 1) / fac[n - i - 1]; ret += to_string(nums[index]); nums.erase(nums.begin() + index); k -= index * fac[n - i - 1]; &#125; return ret;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; cout &lt;&lt; helper(n, k) &lt;&lt; endl; return 0;&#125; 打印n个字符串的全排列第K个值（全排列个数会溢出情况） Leetcode 31参考全排列的算法，也可以参考next permutation 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;void next_permutation(string&amp; s) &#123; int n = s.size(); int i = n - 2; while (i &gt;= 0 &amp;&amp; s[i] &gt;= s[i + 1]) i--; if (i &gt;= 0) &#123; int j = n - 1; while (s[j] &lt;= s[i]) j --; swap(s[j], s[i]); &#125; reverse(s.begin() + i + 1, s.end()); // 如果reverse放在外面，则会无限循环，当整体已经处于降序的情况下，reverse会变成升序，此时就会变成全排列的第一个&#125;string helper(int n, int k) &#123; string ret; for (int i = 1; i &lt;= n; i++) &#123; ret = ret + to_string(i);; &#125; for (int i = 0; i &lt; k - 1; i++) &#123; next_permutation(ret); &#125; return ret;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; cout &lt;&lt; helper(n, k) &lt;&lt; endl; return 0;&#125; ransom note 验证地址Leetcode 383 1234567891011class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; unordered_map&lt;char, int&gt; m; for (auto i : magazine) m[i]++; for (auto i : ransomNote) &#123; if (-- m[i] &lt; 0) return false; &#125; return true; &#125;&#125;; logger rate limiter(待付费) 验证地址Leetcode 359 1234567891011121314class Logger &#123;private: unordered_map&lt;string, int&gt; m;public: Logger() &#123;&#125; bool shouldPrintMessage(int timestamp, string message) &#123; bool ret = true; if (m.find(message) != m.end() &amp;&amp; m[message] &gt;= timestamp - 10) &#123; ret = false; &#125; m[message] = timestamp; return ret; &#125;&#125;; Snakes and Ladders 验证地址Leetcode 909123456789101112131415161718192021222324252627class Solution &#123;public: int snakesAndLadders(vector&lt;vector&lt;int&gt;&gt;&amp; board) &#123; unordered_set&lt;int&gt; m; int ret = 0, n = board.size(); unordered_set&lt;int&gt; cur(&#123;1&#125;); while (true) &#123; unordered_set&lt;int&gt; next; for (auto i : cur) &#123; m.insert(i); if (i == n * n) return ret; for (int j = 1; j &lt;= 6; j++) &#123; int index = j + i; if (index &gt; n * n) continue; int a = (index - 1) / n, b = (index - 1) % n; int temp = board[n - a - 1][a % 2 ? n - 1 - b : b]; if (temp &gt; 0) index = temp; if (m.find(index) == m.end()) next.insert(index); &#125; &#125; if (next.empty()) break; cur = next; ret ++; &#125; return -1; &#125;&#125;; Spirally traversing a matrix 验证地址geeksforgeeks123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; if (nums.empty() || nums[0].empty()) return; int m = nums.size(), n = nums[0].size(); int a[4] = &#123;0, 1, 0, -1&#125;, b[4] = &#123;1, 0, -1, 0&#125;; int i = 0, j = 0; int cnt = 0; int dir = 0; while (cnt &lt; m * n) &#123; cout &lt;&lt; nums[i][j] &lt;&lt; " "; nums[i][j] = -1; cnt ++; i += a[dir]; j += b[dir]; if (i &lt; m &amp;&amp; i &gt;= 0 &amp;&amp; j &lt; n &amp;&amp; j &gt;= 0 &amp;&amp; nums[i][j] &gt;= 0); else &#123; i -= a[dir]; j -= b[dir]; dir = (dir + 1) % 4; i += a[dir]; j += b[dir]; &#125; &#125; cout &lt;&lt; endl;&#125;int main() &#123; int t; cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; nums(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; helper(nums); &#125; return 0;&#125; Encode and Decode TinyURL 验证地址Leetcode 535 1234567891011121314151617181920212223242526272829303132333435363738394041// 思路：// 0-9a-zA-Z一共是62个字母，所以全局有一个cnt表示已经有多少个网址，// 然后将这个cnt变成62进制数，每一位对应到62个字母中的其中一个，就是编码过程，然后存下来// 因为每一个网址都是唯一的自增id，所以肯定能保证在O(1)时间里面生成唯一短网址// 解码过程就是将提取下来的数class Solution &#123;private: unordered_map&lt;string, string&gt; m; long long cnt; unordered_map&lt;char, int&gt; dict;public: Solution(): cnt(0) &#123; int index = 0; for (char i = '0'; i &lt;= '9'; i++) dict[i] = index++; for (char i = 'a'; i &lt;= 'z'; i++) dict[i] = index++; for (char i = 'A'; i &lt;= 'Z'; i++) dict[i] = index++; &#125; // Encodes a URL to a shortened URL. string encode(string longUrl) &#123; cnt ++; long long ans = cnt; string ret; while (ans) &#123; ret.push_back(dict[ans % 62]); ans /= 62; &#125; m[ret] = longUrl; return ret; &#125; // Decodes a shortened URL to its original URL. string decode(string shortUrl) &#123; if (m.find(shortUrl) == m.end()) return ""; else return m[shortUrl]; &#125;&#125;;// Your Solution object will be instantiated and called as such:// Solution solution;// solution.decode(solution.encode(url)); XML转化成Tree/JSON12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Node &#123;public: string key; string val; vector&lt;Node*&gt; child; Node(string x): key(x), val("") &#123;&#125;&#125;;Node* convert(string s, int&amp; index) &#123; string key; int n = s.size(); // if (index &gt;= n || s[index] != '&lt;') throw "Format Error"; while (index &lt; n &amp;&amp; s[index] != '&lt;') index ++; index ++; while (index &lt; n &amp;&amp; s[index] != '&gt;') key.push_back(s[index ++]); index ++; Node* ret = new Node(key); cout &lt;&lt; key &lt;&lt; endl; string val; while (index &lt; n - 1 &amp;&amp; !(s[index] == '&lt;' &amp;&amp; s[index + 1] == '/')) &#123; while (index &lt; n &amp;&amp; s[index] == ' ') index ++; if (s[index] == '&lt;') &#123; index --; ret-&gt;child.push_back(convert(s, index)); &#125; else &#123; val.push_back(s[index ++]); &#125; &#125; cout &lt;&lt; val &lt;&lt; endl; while (index &lt; n &amp;&amp; s[index] != '&gt;') index ++; index ++; if (ret-&gt;child.empty()) ret-&gt;val = val; return ret;&#125;string dfs(Node* root) &#123; if (!root) return ""; string ret = "&#123;"; ret += " " + root-&gt;key + ": "; if (root-&gt;child.empty()) ret += "\"" + root-&gt;val + "\""; else &#123; for (auto i : root-&gt;child) &#123; ret += dfs(i) + ", "; &#125; ret.pop_back(); ret.pop_back(); &#125; ret += " &#125;"; return ret;&#125;string helper(string s) &#123; int n = s.size(); int index = 0; while (index &lt; n &amp;&amp; s[index] == ' ') index++; if (index == n) return ""; Node* root = convert(s, index); return dfs(root);&#125;int main() &#123; string s = "&lt;note&gt;&lt;plus&gt; &lt;to&gt;George&lt;/to&gt;&lt;/plus&gt; &lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt;"; cout &lt;&lt; helper(s) &lt;&lt; endl;; return 0;&#125; bitcoin trading1234567Question:You know the daily prices of Bitcoin (BTC), and you traveled back to 1 year ago. The BTC exchange was highly regulated and you can only do one of (a) BUY, (b) HOLD, and (c) SELL, per day. You can trade one BTC per day.You can not sell BTC that you don&apos;t own - no shorts or derivatives.You have unlimited cashMaximize your profit for this year 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;utility&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums) &#123; stack&lt;pair&lt;int, int&gt;&gt; s; for (auto i : nums) &#123; if (s.empty()) s.push(&#123;i, i&#125;); else if (s.top().second &gt; i) s.push(&#123;i, i&#125;); else &#123; int x = s.top().first; while (!s.empty() &amp;&amp; s.top().second &gt;= x) s.pop(); s.push(&#123;x, i&#125;); &#125; &#125; int ret = 0; while (!s.empty()) &#123; ret += s.top().second - s.top().first; s.pop(); &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; letter association(reduced hangman)123456789Problem StatementGiven a lexicon of words, determine the most commonly associated letters.For example given abc, bcd, cde we should end up with:a:b,c (each with a value of 1)b:c (value of 2)c:b,d (each with value of 2)d:c (value of 2)e:c,d (each with a value of 1) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 用词向量表示频率#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;void helper(vector&lt;string&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;vector&lt;bool&gt;&gt; m(26, vector&lt;bool&gt;(n, false)); for (int i = 0; i &lt; n; i++) &#123; for (auto j : nums[i]) &#123; m[j - 'a'][i] = m[j - 'a'][i] || true; &#125; &#125; for (auto i = 0; i &lt; 26; i++) &#123; vector&lt;int&gt; cur; int max = 0; for (int j = 0; j &lt; 26; j++) &#123; if (j == i) continue; int ans = 0; for (int k = 0; k &lt; n; k++) &#123; ans += (int)(m[i][k] &amp; m[j][k]); &#125; if (ans == max) cur.push_back(j); else if (ans &gt; max) &#123; max = ans; cur = &#123;j&#125;; &#125; &#125; if (!max) continue; cout &lt;&lt; (char)('a' + i) &lt;&lt; ":"; for (auto j : cur) &#123; cout &lt;&lt; (char)(j + 'a') &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;string&gt; nums; for (auto i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; nums.push_back(s); &#125; helper(nums); return 0;&#125; random select from hash table12345ProblemDesign a hash table which allows random select, put, delete, get, and contain in most efficient way&quot; (which is all operations in O(1)).Use CaseThis is used when we need to add unique elements to the hash map, but then allow randomly picking an element to dispatch. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 加一个反向索引#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;utility&gt;#include &lt;cstdlib&gt;#include &lt;time.h&gt;#include &lt;cstring&gt;using namespace std;class MyTable &#123;private: unordered_map&lt;int, string&gt; id2key; unordered_map&lt;string, pair&lt;int, string&gt;&gt; nums; int cnt;public: MyTable(): cnt(0) &#123;&#125; string rand_select() &#123; if (!cnt) throw "Empty!"; srand(time(NULL)); int index = rand() % cnt; return nums[id2key[index]].second; &#125; void put(string key, string val) &#123; if (nums.find(key) == nums.end()) &#123; id2key[cnt] = key; nums[key] = &#123;cnt, val&#125;; cnt ++; &#125; else &#123; nums[key] = &#123;nums[key].first, val&#125;; &#125; &#125; string get(string key) &#123; if (nums.find(key) == nums.end()) throw "Not exisit"; return nums[key].second; &#125; void Delete(string key) &#123; cout &lt;&lt; "delete: " &lt;&lt; key &lt;&lt; endl; if (nums.find(key) == nums.end() || nums.empty()) throw "Not exisit"; int index = nums[key].first; nums.erase(key); key = id2key[cnt - 1]; nums[key] = &#123;index, nums[key].second&#125;; id2key[index] = key; cnt --; &#125; int size() &#123; return cnt; &#125;&#125;;int main() &#123; auto inst = new MyTable(); for (int i = 0; i &lt; 6; i++) &#123; inst-&gt;put(to_string(i), to_string(i + 1)); &#125; for (auto i = 0; i &lt; 7; i++) &#123; cout &lt;&lt; inst-&gt;rand_select() &lt;&lt; endl; system("pause"); inst-&gt;Delete(to_string(i)); &#125; return 0;&#125;` UTF-8 Validation 验证地址Leetcode 393 12345678910111213141516171819class Solution &#123;public: bool validUtf8(vector&lt;int&gt;&amp; data) &#123; int cnt = 0; for (auto i : data) &#123; if (!cnt) &#123; if ((i &gt;&gt; 5) == 0b110) cnt = 1; else if ((i &gt;&gt; 4) == 0b1110) cnt = 2; else if ((i &gt;&gt; 3) == 0b11110) cnt = 3; else if (i &gt;&gt; 7) return false; &#125; else &#123; if ((i &gt;&gt; 6) != 0b10) return false; cnt --; &#125; &#125; return cnt == 0; &#125;&#125;; lower/upper bound12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int lower_bound(vector&lt;int&gt;&amp; nums, int c) &#123; int n = nums.size(); int left = 0, right = n - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; c) left = mid + 1; else right = mid; &#125; return left;&#125;int upper_bound(vector&lt;int&gt;&amp; nums, int c) &#123; int n = nums.size(); int left = 0, right = n - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt;= c) left = mid + 1; else right = mid; &#125; return left;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; int t; cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) &#123; int c; cin &gt;&gt; c; cout &lt;&lt; lower_bound(nums, c) &lt;&lt; endl; cout &lt;&lt; upper_bound(nums, c)&lt;&lt; endl; &#125; return 0;&#125; 多路归并数组归并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;using namespace std;void heapfy(vector&lt;pair&lt;int, int&gt;&gt;&amp; ans, vector&lt;vector&lt;int&gt;&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; nums[ans[left].first][ans[left].second] &lt; nums[ans[smallest].first][ans[smallest].second]) smallest = left; if (right &lt; max &amp;&amp; nums[ans[right].first][ans[right].second] &lt; nums[ans[smallest].first][ans[smallest].second]) smallest = right; if (smallest != index) &#123; swap(ans[smallest], ans[index]); heapfy(ans, nums, smallest, max); &#125;&#125;vector&lt;int&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; vector&lt;int&gt; ret; vector&lt;pair&lt;int, int&gt;&gt; ans; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; if (!nums[i].empty()) ans.push_back(&#123;i, 0&#125;); &#125; for (int i = 0; i &lt; ans.size(); i++) heapfy(ans, nums, i, ans.size()); while (!ans.empty()) &#123; auto cur = ans[0]; ret.push_back(nums[cur.first][cur.second]); if (cur.second + 1 &lt; nums[cur.first].size()) ans[0] = &#123;cur.first, cur.second + 1&#125;; else &#123; ans[0] = ans.back(); ans.pop_back(); &#125; if (!ans.empty()) heapfy(ans, nums, 0, ans.size()); &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; nums; for (int i = 0; i &lt; n; i++) &#123; int t; cin &gt;&gt; t; vector&lt;int&gt; temp(t, 0); for (int j = 0; j &lt; t; j++) &#123; cin &gt;&gt; temp[j]; &#125; nums.push_back(temp); &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct ListNode &#123; int val; ListNode* next; ListNode(int x): val(x), next(NULL) &#123;&#125;&#125;;void heapfy(vector&lt;ListNode*&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; nums[left]-&gt;val &lt; nums[smallest]-&gt;val) smallest = left; if (right &lt; max &amp;&amp; nums[right]-&gt;val &lt; nums[smallest]-&gt;val) smallest = right; if (smallest != index) &#123; swap(nums[smallest], nums[index]); heapfy(nums, smallest, max); &#125;&#125;ListNode* helper(vector&lt;ListNode*&gt;&amp; nums) &#123; ListNode* ret = new ListNode(-1); auto cur = ret; for (int i = 0; i &lt; nums.size() / 2; i ++) heapfy(nums, i, nums.size()); while (!nums.empty()) &#123; cur-&gt;next = nums[0]; cur = cur-&gt;next; if (cur-&gt;next) &#123; nums[0] = cur-&gt;next; &#125; else &#123; nums[0] = nums.back(); nums.pop_back(); &#125; heapfy(nums, 0, nums.size()); &#125; cur-&gt;next = NULL; return ret-&gt;next;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;ListNode*&gt; nums; for (auto i = 0; i &lt; n; i++) &#123; auto ret = new ListNode(-1); auto cur = ret; int t; cin &gt;&gt; t; for (int j = 0; j &lt; t; j++) &#123; int c; cin &gt;&gt; c; cur-&gt;next = new ListNode(c); cur = cur-&gt;next; &#125; nums.push_back(ret-&gt;next); &#125; auto cur = helper(nums); while (cur) &#123; cout &lt;&lt; cur-&gt;val &lt;&lt; endl; cur = cur-&gt;next; &#125; return 0;&#125; Find Peak Element Leetcode 1621234567891011121314class Solution &#123;public: int findPeakElement(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return -1; int n = nums.size(); int left = 0, right = n - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; nums[mid + 1]) left = mid + 1; else right = mid; &#125; return left; &#125;&#125;; 差值的绝对值第K大题目：一个数组，任意两个数存在差值，求差值绝对值第K大是多少 Leetcode 7191234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int search(vector&lt;int&gt;&amp; nums, int target) &#123; // 双指针，判断有序数组差值大于target的个数 int n = nums.size(); int left = 0, right = 0; int cnt = 0; while (left &lt;= right) &#123; while (right &lt; n &amp;&amp; nums[right] - nums[left] &lt;= target) right ++; if (right &lt; n) cnt += n - right; // right之后的和left相减都大于target left ++; &#125; return cnt;&#125;int helper(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int left = 0, right = nums.back() - nums[0]; while (left &lt; right) &#123; int mid = left + (right - left) / 2; int cnt = search(nums, mid); cout &lt;&lt; mid &lt;&lt; " " &lt;&lt; cnt &lt;&lt; endl; if (cnt &gt;= k) left = mid + 1; else right = mid; &#125; return left;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums, k) &lt;&lt; endl; return 0;&#125; 字典序第K大(*) Leetcode 440 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int findKthNumber(int n, int k) &#123; int result = 1; for(--k; k &gt; 0; ) &#123; // calculate #|&#123;result, result*, result**, result***, ...&#125;| int count = 0; for (long long first = static_cast&lt;long long&gt;(result), last = first + 1; first &lt;= n; // the interval is not empty first *= 10, last *= 10) // increase a digit &#123; // valid interval = [first, last) union [first, n] count += static_cast&lt;int&gt;((min(n + 1LL, last) - first)); // add the length of interval &#125; if (k &gt;= count) &#123; // skip &#123;result, result*, result**, result***, ...&#125; // increase the current prefix ++result; k -= count; &#125; else &#123; // not able to skip all of &#123;result, result*, result**, result***, ...&#125; // search more detailedly result *= 10; --k; &#125; &#125; return result; &#125;&#125;; Kth Smallest Number in Multiplication Table(*) Leetcode 668 1234567891011121314151617class Solution &#123;public: int findKthNumber(int m, int n, int k) &#123; int lo = 1, hi = m*n;//[lo, hi) while(lo &lt; hi) &#123; int mid = lo + (hi - lo) / 2; int count = 0, j = m; for(int i = 1; i &lt;= n; i++) &#123; while(j &gt;=1 &amp;&amp; i*j &gt; mid) j--; count += (j); &#125; if(count &lt; k) lo = mid + 1; else hi = mid; &#125; return lo; &#125;&#125;; 将0移到最前面[1,2,3,0,0,9]这样的数组，把0移到最前面，此题类似于剑指offer偶数在奇数之前。三种解法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; helper1(vector&lt;int&gt; nums) &#123; // 保证相对顺序且空间O(1) int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; for (int j = n - 1; j &gt; i; j--) &#123; if (nums[j] == 0 &amp;&amp; nums[j - 1] != 0) &#123; swap(nums[j - 1], nums[j]); &#125; &#125; &#125; return nums;&#125;vector&lt;int&gt; helper2(vector&lt;int&gt; nums) &#123; // 不要求相对顺序时间O(n) int n = nums.size(); int left = 0, right = n - 1; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; !nums[left]) left ++; while (left &lt; right &amp;&amp; nums[right]) right --; if (left &lt; right) &#123; swap(nums[left], nums[right]); left ++, right --; &#125; &#125; return nums;&#125;vector&lt;int&gt; helper3(vector&lt;int&gt; nums) &#123; // 保证相对顺序时间O(n) int cnt = 0, n = nums.size(); for (auto i : nums) &#123; if (!i) cnt ++; &#125; vector&lt;int&gt; ret(n, 0); int l = 0, r = 0; for (auto i : nums) &#123; if (i) ret[cnt + r] = i, r ++; else ret[l] = i, l ++; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper1(nums)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (auto i : helper2(nums)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (auto i : helper3(nums)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; Sliding Window Maximum Leetcode 239 123456789101112131415class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; vector&lt;int&gt; ret; deque&lt;int&gt; q; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; while (!q.empty() &amp;&amp; nums[q.back()] &lt;= nums[i]) q.pop_back(); q.push_back(i); while (!q.empty() &amp;&amp; q.front() &lt;= i - k) q.pop_front(); if (i &gt;= k - 1) ret.push_back(nums[q.front()]); &#125; return ret; &#125;&#125;; 质数异或组合给一个不重复正数集合，如果一个子数组按位异或得到的结果是质数，那么就满足条件，求满足条件的子数组个数。例如[2, 4, 7]，符合条件的有[2] [7] [2,7] [4,7],然后数的范围是小于5000，然后数组长度范围是小于5000。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;unordered_set&gt;#include &lt;unordered_map&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; fac(5000, true); fac[1] = false; for (int i = 2; i &lt;= 5000; i++) &#123; if (!fac[i]) continue; for (int j = 2; j * i &lt;= 5000; j++) &#123; fac[i * j] = false; &#125; &#125; unordered_map&lt;int, vector&lt;unordered_set&lt;int&gt;&gt;&gt; dp; for (auto i : nums) &#123; dp[i] = &#123;&#123;i&#125;&#125;; &#125; for (int i = 2; i &lt;= 5000; i++) &#123; for (int j : nums) &#123; // 判重复 if ((j ^ i) &lt; j &amp;&amp; dp.find(i ^ j) != dp.end()) &#123; auto temp = dp[i ^ j]; for (auto k : temp) &#123; if (k.find(j) != k.end()) continue; k.insert(j); dp[i].push_back(k); &#125; &#125; &#125; &#125; int ret = 0; for (auto i : dp) &#123; if (!fac[i.first]) continue; cout &lt;&lt; i.first &lt;&lt; ":" &lt;&lt; endl; for (auto j : i.second) &#123; for (auto k : j) &#123; cout &lt;&lt; k &lt;&lt; " "; &#125; ret ++; cout &lt;&lt; endl; &#125; &#125; cout &lt;&lt; endl; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125;/*32 4 932 4 743 2 4 9*/ 包含所有字符的最短子串给定一个字符串，求它的最短子串，使得原字符串中所有出现过的字符都在这个子串中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;climits&gt;#include &lt;math.h&gt;using namespace std;string helper(string s, string p) &#123; unordered_map&lt;char, int&gt; m; for (auto i : p) m[i] ++; int ans = m.size(); string ret; int n = s.size(); int len = INT_MAX; int l = 0, r = 0; while (l &lt;= r &amp;&amp; r &lt;= n) &#123; if (r &lt; n &amp;&amp; ans) &#123; auto c = s[r ++]; if (m.find(c) != m.end()) &#123; m[c] --; if (!m[c]) ans --; &#125; &#125; else &#123; auto c = s[l ++]; if (m.find(c) != m.end()) &#123; m[c] ++; if (m[c] == 1) ans ++; &#125; &#125; if (!ans) &#123; if (r - l &lt; len) &#123; len = r - l; ret = s.substr(l, len); &#125; &#125; &#125; return ret;&#125;int main() &#123; string s, p; cin &gt;&gt; s &gt;&gt; p; cout &lt;&lt; helper(s, p) &lt;&lt; endl; return 0;&#125; Rotated Sorted Array求旋转了多少位12345678910111213141516171819202122232425262728#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt;= 1) return n; int l = 0, r = n - 1; while (l &lt; r) &#123; int mid = l + (r - l) / 2; if (nums[mid] == nums[r]) r --; else if (nums[mid] &lt; nums[mid + 1]) r = mid; else l = mid + 1; &#125; return l;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; merge intervals Leetcode 56 12345678910111213141516class Solution &#123;public: bool static cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] == b[0] ? a[1] &lt; b[1] : a[0] &lt; b[0]; &#125; vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) &#123; vector&lt;vector&lt;int&gt;&gt; ret; sort(intervals.begin(), intervals.end(), cmp); for (auto i : intervals) &#123; if (ret.empty()) ret.push_back(i); else if (ret.back()[1] &gt;= i[0]) ret.back()[1] = max(ret.back()[1], i[1]); else ret.push_back(i); &#125; return ret; &#125;&#125;; 折线图的在Y轴上覆盖最多的区间一个折线图，例如[1,2,1,2,1,2,3],求左闭右开覆盖最多的区间是多少，例如此例子就是[1, 2)。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 此例子类似于会议室那道题，求在会议室中最多的人数是多少// 但是不同于会议室那道题，这道题是求区间，所以不能用前缀和#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;climits&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;int&gt;&amp; nums) &#123; int start = INT_MAX; int end = INT_MIN; for (int i : nums) &#123; start = min(start, i); end = max(end, i); &#125; int len = end - start + 1; vector&lt;int&gt; ans(len, 0); for (int i = 0; i &lt; nums.size() - 1; i++) &#123; if (nums[i] &lt; nums[i + 1]) &#123; ans[nums[i] - start] ++; ans[nums[i + 1] - start] --; &#125; else &#123; ans[nums[i] - start] --; ans[nums[i + 1] - start] ++; &#125; &#125; int cnt = 0; int mx = INT_MIN; vector&lt;int&gt; ret(2, start); vector&lt;int&gt; cur(2, start); for (int i = 0; i &lt; len; i++) &#123; cnt += ans[i]; if (!cnt) &#123; cnt = 0; cur = &#123;i + 1 + start, i + 1 + start&#125;; &#125; else &#123; // 此部分是用于将右侧开空间或延伸，如果小于0就不会进入与mx的比较 if (ans[i] &lt;= 0) &#123; cur[1] = i + 1 + start; &#125; else &#123; cur = &#123;i + start, i + start + 1&#125;; &#125; // 必须要有等于，否则无法向后延伸，比如[1,3,1,3,1,4]就会返回[1,2) if (cnt &gt;= mx) &#123; mx = cnt; ret = cur; &#125; &#125; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 如果是两边都是闭区间，则需要将右边界+1，此时可能会选择点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;climits&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;int&gt;&amp; nums) &#123; int start = INT_MAX; int end = INT_MIN; for (int i : nums) &#123; start = min(start, i); end = max(end, i); &#125; int len = end - start + 1; vector&lt;int&gt; ans(len + 1, 0); for (int i = 0; i &lt; nums.size() - 1; i++) &#123; if (nums[i] &lt; nums[i + 1]) &#123; ans[nums[i] - start] ++; ans[nums[i + 1] - start + 1] --; &#125; else &#123; ans[nums[i] - start + 1] --; ans[nums[i + 1] - start] ++; &#125; &#125; int cnt = 0; int mx = INT_MIN; vector&lt;int&gt; ret(2, start); vector&lt;int&gt; cur(2, start); for (int i = 0; i &lt; len; i++) &#123; cnt += ans[i]; if (!cnt) &#123; cnt = 0; cur = &#123;i + 1 + start, i + 1 + start&#125;; &#125; else &#123; if (ans[i] &gt; 0) &#123; cur = &#123;i + start, i + start&#125;; &#125; else &#123; cur[1] = i + start; &#125; if (cnt &gt;= mx) &#123; mx = cnt; ret = cur; &#125; &#125; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125;/*71 3 1 3 1 3 47 3 1 3 1 3 1 4*/ HDU 5776 sum HDU 5576给定n个整数，是否存在一个子数组（下标连续）的和对m取模等于0 思路：假设sum[i]表示前i个数的前缀和，如果存在sum[i]%m==sum[j]%m，那么（sum[j]-sum[i]）%m==0。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;using namespace std;bool helper(vector&lt;int&gt;&amp; nums, int m) &#123; int n = nums.size(); unordered_map&lt;int, int&gt; hash; int ans = 0; for (auto i : nums) &#123; ans += i; if (hash.find(ans % m) != hash.end()) &#123; cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; hash[ans % m] &lt;&lt; endl; return true; &#125; hash[ans % m] = i; &#125; return false;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums, m) &lt;&lt; endl; return 0;&#125; 矩阵填数 hihocoder 1480复习完钩子定理和卡特兰数更新。。。]]></content>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【面经】微软部分编程算法题]]></title>
    <url>%2F2019%2F04%2F13%2Finterview-coding-microsoft%2F</url>
    <content type="text"><![CDATA[本文收集2018-2019年实验室实习面试部分编程面经以供复习另外微软特别喜欢考剑指offer 股票题目1-5Best Time to Buy and Sell Stock 验证地址为Leetcode 121 1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int ret = 0; int n = prices.size(); int low = prices[0]; for (int i = 1; i &lt; n; i++) &#123; low = min(low, prices[i]); ret = max(ret, prices[i] - low); &#125; return ret; &#125;&#125;; Best Time to Buy and Sell Stock II 验证地址为Leetcode 122 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); int ret = 0; for (int i = 1; i &lt; n; i++) &#123; if (prices[i] &gt; prices[i - 1]) &#123; ret += prices[i] - prices[i - 1]; &#125; &#125; return ret; &#125;&#125;; Best Time to Buy and Sell Stock III 验证地址Leetcode 123 123456789101112131415161718192021222324// 正常解法，先从左往右扫一遍，算出到i为止一次交易收益最大值// 然后从右往左扫，算出第二次交易与第一次交易加和最大值class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); vector&lt;int&gt; dp(n, 0); int buy = INT_MAX; int sell = 0; // 第一次交易的最大值 for (int i = 0; i &lt; n; i++) &#123; sell = max(sell, prices[i] - buy); buy = min(buy, prices[i]); dp[i] = sell; &#125; int ret = 0; sell = 0; for (int i = n - 1; i &gt;= 0; i--) &#123; ret = max(ret, dp[i] + (sell - prices[i])); sell = max(sell, prices[i]); &#125; return ret; &#125;&#125;; 12345678910111213141516171819// 自动机做法，每次遇到一个价格，先更新最终售出收益，然后按影响逐步更新其余三个值class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); int buy1 = INT_MIN, buy2 = INT_MIN; int sell1 = 0, sell2 = 0; for (auto i : prices) &#123; sell2 = max(sell2, buy2 + i); buy2 = max(buy2, sell1 - i); // 这里不好理解的是这一点，为什么取buy的最大值， // 通过表达式其实就能看出来，因为sell2是通过buy2+i更新的， // 所以这里保证局部最大就能保证加上去之后也是局部最大 sell1 = max(sell1, i + buy1); buy1 = max(buy1, -i); &#125; return sell2; &#125;&#125;; Best Time to Buy and Sell Stock IV 验证地址Leetcode 188 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: int maxProfit(int k, vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); vector&lt;int&gt; dp(n, 0); if (k &gt;= n / 2) &#123; int ret = 0; for (int i = 1; i &lt; n; i++) &#123; if (prices[i] &gt; prices[i - 1]) ret += prices[i] - prices[i - 1]; &#125; return ret; &#125; for (int i = 1; i &lt;= k; i++) &#123; int buy = dp[0] - prices[0]; for (int j = 1; j &lt; n; j++) &#123; int pre_sell = dp[j]; dp[j] = max(dp[j - 1], buy + prices[j]); buy = max(buy, pre_sell - prices[j]); &#125; // 或者二维数组 /* int buy = dp[i - 1][0] - prices[0]; for (int j = 1; j &lt; n; j++) &#123; dp[i][j] = max(dp[i][j - 1], buy + prices[j]); buy = max(buy, dp[i - 1][j] - prices[j]); &#125; */ &#125; return dp[n - 1]; &#125;&#125;; Best Time to Buy and Sell Stock with Cooldown 验证地址Leetcode 309 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int sell(0), buy(INT_MIN), pre_sell(0); for (auto i : prices) &#123; int pre_buy = buy; buy = max(pre_sell - i, buy); pre_sell = sell; sell = max(sell, pre_buy + i); &#125; return sell; &#125;&#125;; 12345678910111213141516// 方法二，便于理解，因为pre_sell必须要在sell之前的那一天class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int n = prices.size(); if (n &lt;= 1) return 0; int sell = 0, buy = INT_MIN, pre_sell = 0; for (int i = 0; i &lt; n; i++) &#123; int temp = pre_sell; pre_sell = sell; sell = max(sell, buy + prices[i]); buy = max(buy, temp - prices[i]); &#125; return sell; &#125;&#125;; Best Time to Buy and Sell Stock with Transaction Fee 验证地址Leetcode 714 1234567891011121314class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices, int fee) &#123; int n = prices.size(); if (n &lt;= 1) return 0; int sell = 0, buy = INT_MIN; for (auto i : prices) &#123; int pre_sell = sell; sell = max(sell, buy + i); buy = max(pre_sell - i - fee, buy); &#125; return sell; &#125;&#125;; Open the Lock 验证地址Leetcode 752123456789101112131415161718192021222324252627// 加速方法是从两端出发，可以将速度加快一倍，也会使一端无法继续循环提前完成class Solution &#123;public: int openLock(vector&lt;string&gt;&amp; deadends, string target) &#123; set&lt;string&gt; dead(deadends.begin(), deadends.end()); if (dead.count("0000")) return -1; if (target == "0000") return 0; set&lt;string&gt; v; queue&lt;string&gt; q; q.push("0000"); for (int d = 1; !q.empty(); d++) &#123; for (int n = q.size(); n &gt; 0; n--) &#123; string cur = q.front(); q.pop(); for (int i = 0; i &lt; 4; i++) &#123; for (int dif = 1; dif &lt;= 9; dif += 8) &#123; string s = cur; s[i] = (s[i] - '0' + dif) % 10 + '0'; if (s == target) return d; if (!dead.count(s) &amp;&amp; !v.count(s)) q.push(s); v.insert(s); &#125; &#125; &#125; &#125; return -1; &#125;&#125;; Bomb Enemy 验证地址Leetocde 361 由于是收费的，所以看题可以在题干 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// 方法是先横着扫一遍，把线段中的敌人数标出来，然后再竖着扫，和横着的加起来，就是一颗炸弹能炸的人数#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;int helper(vector&lt;string&gt;&amp; nums) &#123; if (nums.empty() || nums[0].empty()) return 0; int m = nums.size(), n = nums[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; int ans = 0; for (int j = 0; j &lt;= n; j++) &#123; if (j == n || nums[i][j] == 'W') &#123; for (int k = j - 1; k &gt;= 0 &amp;&amp; nums[i][k] != 'W'; k--) &#123; dp[i][k] = ans; &#125; ans = 0; &#125; else if (nums[i][j] == 'E') &#123; ans ++; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; int ans = 0; for (int j = 0; j &lt;= m; j++) &#123; if (j == m || nums[j][i] == 'W') &#123; for (int k = j - 1; k &gt;= 0 &amp;&amp; nums[k][i] != 'W'; k--) &#123; dp[k][i] += ans; &#125; ans = 0; &#125; else if (nums[j][i] == 'E') &#123; ans ++; &#125; &#125; &#125; int ret = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (nums[i][j] == 'E') ret = max(ret, dp[i][j] - 1); else ret = max(ret, dp[i][j]); &#125; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;string&gt; nums; for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; nums.push_back(s); &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125;/*5 0E00EEW0E0EE0E0E00W00E0E0*/ Fence Repair 验证地址POJ 32531234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*这道题的答案可以分解为，每次切一次，被包含在其中的每一个片都要被加到结果中一次也就是说 8 5 8三个数第一次切参与了8 + 5 + 8， 被分成了13和8第二次切13，其中8和5参与其中所以结果可以写成板子的长度乘以参与个数的和即 5 * 2 + 8 * 2 + 8 * 1所以这满足哈夫曼树，哈夫曼树的特点是最优化二叉树，即权值乘以层数的加和最小构建的思路可以参考 https://blog.csdn.net/dongfei2033/article/details/80657360*/#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;stdio.h&gt;using namespace std;int main() &#123; int n; while (~scanf("%d", &amp;n)) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for (int i = 0; i &lt; n; i++) &#123; int t; scanf("%d", &amp;t); q.push(t); &#125; long long sum = 0; if (q.size() == 1) &#123; int a = q.top(); sum += a; q.pop(); &#125; while (q.size() &gt; 1) &#123; int a = q.top(); q.pop(); int b = q.top(); q.pop(); sum += a + b; q.push(a + b); &#125; printf("%lld\n", sum); &#125; return 0;&#125; 背包01背包有N件物品和一个容量为V的背包。第i建物品的费用是c[i],价值是w[i]。求解将哪些物品装入背包可使价值总和最大(不过这里表示的是正好被填满V)1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;climits&gt;using namespace std;int helper(vector&lt;int&gt;&amp; w, vector&lt;int&gt;&amp; c, int v) &#123; if (w.empty()) return 0; int n = w.size(); vector&lt;int&gt; dp(v + 1, INT_MIN); // INT_MIN是正好装满 // 0是装不满也可以 dp[0] = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = v; j &gt;= c[i]; j--) &#123; dp[j] = max(dp[j], dp[j - c[i]] + w[i]); &#125; &#125; return dp[v];&#125;int main() &#123; int n, v; cin &gt;&gt; n &gt;&gt; v; vector&lt;int&gt; w(n, 0); vector&lt;int&gt; c(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; c[i] &gt;&gt; w[i]; &#125; cout &lt;&lt; helper(w, c, v) &lt;&lt; endl; return 0;&#125; 完全背包有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价格是w[i].求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;climits&gt;using namespace std;int helper(vector&lt;int&gt;&amp; w, vector&lt;int&gt;&amp; c, int v) &#123; if (w.empty() || !v) return 0; int n = w.size(); vector&lt;int&gt; dp(v + 1, INT_MIN); // INT_MIN是正好装满 // 0是装不满也可以 dp[0] = 0; for (int i = 0; i &lt; n; i++) &#123; for (int j = c[i]; j &lt;= v; j++) &#123; dp[j] = max(dp[j], dp[j - c[i]] + w[i]); &#125; &#125; return dp[v];&#125;int main() &#123; int n, v; cin &gt;&gt; n &gt;&gt; v; vector&lt;int&gt; w(n, 0); vector&lt;int&gt; c(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; c[i] &gt;&gt; w[i]; &#125; cout &lt;&lt; helper(w, c, v) &lt;&lt; endl; return 0;&#125; 多重背包有N种物品和一个容量为V的背包。第i种物品最多有n[i]件，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大 考虑成每个物品做k次01背包，但是有一点是每次的下限需要比上次提高一个c[i] 1234567891011121314151617181920212223242526272829303132333435363738394041// 此方法和背包九讲实现不同，但是原理相同，用了一维dp#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;math.h&gt;using namespace std;int helper(vector&lt;int&gt;&amp; w, vector&lt;int&gt;&amp; c, vector&lt;int&gt;&amp; k, int v) &#123; if (w.empty() || !v) return 0; int n = w.size(); vector&lt;int&gt; dp(v + 1, INT_MIN); dp[0] = 0; for (int i = 0; i &lt; n; i++) &#123; for (int x = 1; x &lt;= k[i]; x ++) &#123; for (int j = v; j &gt;= x * c[i]; j--) &#123; // 这里下限为x*c[i]为了保证一定能包含最少x个c[i] dp[j] = max(dp[j], dp[j - c[i]] + w[i]); if (j == v) cout &lt;&lt; dp[j] &lt;&lt; ":" &lt;&lt; i &lt;&lt; " " &lt;&lt; x &lt;&lt; endl; &#125; &#125; &#125; return dp[v]; &#125;int main() &#123; int n, v; cin &gt;&gt; n &gt;&gt; v; vector&lt;int&gt; w(n, 0); vector&lt;int&gt; c(n, 0); vector&lt;int&gt; k(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; c[i] &gt;&gt; w[i] &gt;&gt; k[i]; &#125; cout &lt;&lt; helper(w, c, k, v) &lt;&lt; endl; return 0;&#125; 背包九讲其他题参考背包九讲 迷宫穿梭左上到右下，0为空，1为墙，找出任意一条路径1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 找出一条路径用dfs，比较好写// 找出最短距离用bfs，如果存在一般用时间比较少#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;unordered_set&gt;#include &lt;utility&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; dfs(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int x, int y, unordered_set&lt;string&gt;&amp; hash) &#123; string temp = to_string(x) + "-" + to_string(y); if (hash.find(temp) != hash.end()) return vector&lt;pair&lt;int, int&gt;&gt;(); hash.insert(temp); int m = nums.size(), n = nums[0].size(); if (x == m - 1 &amp;&amp; y == n - 1) return vector&lt;pair&lt;int, int&gt;&gt;(&#123;&#123;x, y&#125;&#125;); int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; for (int i = 0; i &lt; 4; i ++) &#123; int X = a[i] + x, Y = b[i] + y; if (X &lt; m &amp;&amp; X &gt;= 0 &amp;&amp; Y &lt; n &amp;&amp; Y &gt;= 0 &amp;&amp; !nums[X][Y]) &#123; auto ret = dfs(nums, X, Y, hash); if (!ret.empty()) &#123; ret.push_back(&#123;x, y&#125;); return ret; &#125; &#125; &#125; return vector&lt;pair&lt;int, int&gt;&gt;();&#125; vector&lt;pair&lt;int, int&gt;&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; if (nums.empty() || nums[0].empty()) return vector&lt;pair&lt;int, int&gt;&gt;(); int m = nums.size(), n = nums[0].size(); unordered_set&lt;string&gt; hash; return dfs(nums, 0, 0, hash);&#125;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; nums(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i.first &lt;&lt; " " &lt;&lt; i.second &lt;&lt; endl; &#125; return 0;&#125; Excel Sheet Column Number 验证地址Leetcode 171 1234567891011class Solution &#123;public: int titleToNumber(string s) &#123; int ret = 0; for (auto i : s) &#123; int index = i - 'A' + 1; ret = ret * 26 + index; &#125; return ret; &#125;&#125;; Reverse Linked List II 验证地址Leetcode 9212345678910111213141516171819202122232425class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (!head) return NULL; auto ret = new ListNode(-1); ret-&gt;next = head; auto cur = ret; for (int i = 0; i &lt; m - 1; i++) &#123; cur = cur-&gt;next; &#125; if (!cur-&gt;next) return ret-&gt;next; auto tail = cur-&gt;next; head = cur; cur = cur-&gt;next; for (int i = m; i &lt;= n; i++) &#123; auto temp = cur-&gt;next; cur-&gt;next = head-&gt;next; head-&gt;next = cur; cur = temp; &#125; tail-&gt;next = cur; return ret-&gt;next; &#125;&#125;; 去除重复元素一个数组，比如[1,2,1,1,2,3,4],剔除重复的，然后还有个要求就是交换的操作要是原址的，就是比如前面的传入数组也要返回这个数组，[1,2,3,4,x,x,x,x]后面是什么不重要，前面一定要是和去重前一致。 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_set&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums) &#123; int index = 0; unordered_set&lt;int&gt; m; for (auto i : nums) &#123; if (m.find(i) != m.end()) continue; m.insert(i); nums[index++] = i; &#125; return index;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; n = helper(nums); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; nums[i] &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;;&#125; 平方和a^2+b^2=c，abc为正整数，给一个c问是否存在值ab使等式成立，O(c)解法1234567891011121314151617181920212223242526272829// dp思路#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;bool helper(int n) &#123; if (n &lt;= 1) return false; unordered_map&lt;int, int&gt; m; for (int i = 1; i &lt; n; i++) &#123; int ans = i * i; if (ans &gt;= n) continue; m[ans] = i; int delt = n - ans; if (m.find(delt) != m.end()) &#123; cout &lt;&lt; i &lt;&lt; " " &lt;&lt; m[delt] &lt;&lt; endl; return true; &#125; &#125; return false;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; helper(n) &lt;&lt; endl; return 0;&#125; Search in Rotated Sorted Array 验证地址Leetcode 33 12345678910111213141516171819202122class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if (!n) return -1; int left = 0, right = n - 1; while (left &lt;= right) &#123; int mid= left + (right - left) / 2; if (nums[mid] == target) return mid; if (nums[mid] == nums[right]) right --; else if (nums[mid] &gt; nums[right]) &#123; if (nums[mid] &gt; target &amp;&amp; nums[left] &lt;= target) right = mid - 1; else left = mid + 1; &#125; else &#123; if (nums[right] &gt;= target &amp;&amp; nums[mid] &lt; target) left = mid + 1; else right = mid - 1; &#125; &#125; return -1; &#125;&#125;; Binary Tree Right Side View 验证地址Leetcode 199 12345678910111213141516// 利用先序遍历，且先遍历右节点class Solution &#123;public: void helper(TreeNode* root, int level, vector&lt;int&gt;&amp; ret) &#123; if (!root) return; if (ret.size() &lt; level) ret.push_back(root-&gt;val); helper(root-&gt;right, level + 1, ret); helper(root-&gt;left, level + 1, ret); &#125; vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; ret; helper(root, 1, ret); return ret; &#125;&#125;; 最小编辑距离1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;climits&gt;using namespace std;int helper(string a, string b) &#123; int m = a.size(), n = b.size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, INT_MAX)); for (int i = 0; i &lt;= m; i++) dp[i][0] = i; for (int i = 0; i &lt;= n; i++) dp[0][i] = i; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1); dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + (a[i - 1] != b[j - 1])); &#125; &#125; return dp[m][n];&#125;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; helper(a, b) &lt;&lt; endl; return 0;&#125; 24点四个数，输出加减乘除括号组合起来等于24的所有表达式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;unordered_set&gt;#include &lt;unordered_map&gt;#include &lt;cstring&gt;using namespace std;unordered_map&lt;int, vector&lt;string&gt;&gt; dfs(vector&lt;int&gt; nums, int index) &#123; int n = nums.size(); unordered_map&lt;int, vector&lt;string&gt;&gt; ret; if (index == n - 1) &#123; ret[nums[index]].push_back(to_string(nums[index])); return ret; &#125; for (int i = index; i &lt; n; i++) &#123; if (i != index &amp;&amp; nums[index] == nums[i]) continue; swap(nums[i], nums[index]); int a = nums[index]; for (auto j : dfs(nums, index + 1)) &#123; int b = j.first; for (auto k : j.second) &#123; ret[a + b].push_back("(" + to_string(a) + "+" + k + ")"); ret[a - b].push_back("(" + to_string(a) + "-" + k + ")"); ret[a * b].push_back("(" + to_string(a) + "*" + k + ")"); if (b) ret[a / b].push_back("(" + to_string(a) + "/" + k + ")"); &#125; &#125; &#125; return ret;&#125;unordered_set&lt;string&gt; helper(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); unordered_set&lt;string&gt; ret; for (auto i : dfs(nums, 0)) &#123; if (i.first == 24) &#123; for (auto j : i.second) &#123; ret.insert(j); &#125; &#125; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; n以内素数个数 验证地址Leetcode 204 1234567891011121314151617181920class Solution &#123;public: int countPrimes(int n) &#123; vector&lt;bool&gt; dp(n + 1, true); int limit = sqrt(n); dp[0] = false; for (int i = 2; i &lt;= limit; i++) &#123; if (dp[i - 1]) &#123; for (int j = 2; j * i &lt;= n; j++) &#123; dp[j * i - 1] = false; &#125; &#125; &#125; int ret = 0; for (int i = 0; i &lt; n - 1; i++) &#123; ret += dp[i]; &#125; return ret; &#125;&#125;; Gas Station 验证地址Leetcode 134 12345678910111213141516class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int ans = 0; int index = 0; int g = 0, c = 0; int n = gas.size(); for (int i = 0; i &lt; n; i++) &#123; ans += gas[i] - cost[i]; g += gas[i]; c += cost[i]; if (ans &lt; 0) ans = 0, index = i + 1; &#125; return g &gt;= c ? index : -1; &#125;&#125;; 最长递增子序列 O(nlogn)版本(*) 参考资料12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;algorithm&gt;const int MAXN=200001;int a[MAXN];int d[MAXN];int main()&#123; int n; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]); d[1]=a[1]; int len=1; for(int i=2;i&lt;=n;i++) &#123; if(a[i]&gt;d[len]) d[++len]=a[i]; else &#123; int j=std::lower_bound(d+1,d+len+1,a[i])-d; d[j]=a[i]; &#125; &#125; printf("%d\n",len); return 0;&#125; Word Break II 验证地址Leetcode 140 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;string&gt; helper(string s, unordered_set&lt;string&gt;&amp; m, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; hash) &#123; if (hash.find(s) != hash.end()) return hash[s]; vector&lt;string&gt; ret; if (m.find(s) != m.end()) ret.push_back(s); int n = s.size(); for (int i = 1; i &lt; n; i++) &#123; string pre = s.substr(0, i); if (m.find(pre) == m.end()) continue; for (auto j : helper(s.substr(i), m, hash)) &#123; ret.push_back(pre + " " + j); &#125; &#125; hash[s] = ret; return ret; &#125; vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; m; unordered_map&lt;string, vector&lt;string&gt;&gt; hash; for (auto i : wordDict) m.insert(i); return helper(s, m, hash); &#125;&#125;; 判断单链表是否有环，将环的入口返回 验证地址牛客网123456789101112131415161718192021class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* head) &#123; if (!head || !head-&gt;next) return NULL; auto fast = head, slow = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; if (fast == slow) &#123; fast = head; while (fast != slow) &#123; fast = fast-&gt;next; slow = slow-&gt;next; &#125; return fast; &#125; &#125; return NULL; &#125;&#125;; 复杂链表复制 验证地址牛客网 12345678910111213141516171819202122232425262728293031class Solution &#123;public: RandomListNode* Clone(RandomListNode* head) &#123; if (!head) return head; RandomListNode* ret = new RandomListNode(-1); ret-&gt;next = head; auto cur = ret-&gt;next; while (cur) &#123; auto temp = cur-&gt;next; cur-&gt;next = new RandomListNode(cur-&gt;label); cur-&gt;next-&gt;random = cur-&gt;random; cur-&gt;next-&gt;next = temp; cur = temp; &#125; cur = ret-&gt;next; while (cur) &#123; if (cur-&gt;random) cur-&gt;next-&gt;random = cur-&gt;random-&gt;next; cur = cur-&gt;next-&gt;next; &#125; head = ret-&gt;next; cur = ret; while (head) &#123; cur-&gt;next = head-&gt;next; head-&gt;next = head-&gt;next-&gt;next; head = cur-&gt;next-&gt;next; cur = cur-&gt;next; &#125; return ret-&gt;next; &#125;&#125;; 概率类相关题目水塘抽样思路：总是选择第一个，然后以1/2的概率选择第二个，然后以1/3选择第三个…所以第i个被选择的概率是[1/i]*[i/(i+1)]…[n-1/(n)]=1/n，所以是等概率的。 12345678910// rand():[0, 正无穷]int helper(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return -1; int ret = -1; for (int i = 0; i &lt; n; i++) &#123; int index = rand() % (i + 1); if (!index) ret = nums[i]; &#125; return ret;&#125; 从n个数里面等概率选出m个原题目的场景大体是这样的：服务器每天会收到数以亿计的请求，但是目前服务器端不希望保存所有的请求，只想随机保存这些请求中的m个。试设计一种算法，能够使服务器实时保存m个请求，并使这些请求是从所有请求中的大致等概率被选中的结果。注意：不到一天的结束，是不能提前知道当天所有请求数n是多少的。 思路：先选取前m个数字，那么当n&lt;=m的时候，就是100%会被选中，当选择第n个数的时候，选取的标准是，以m/n的概率选择这个数，然后随机替换已经保存的m个数中的其中一个。以下是证明。 12345当选择第m+1的时候(1)第m+1个数字被选取的概率是m/(m+1)(2)前m个数字被选择的情况是最后一个没被选择或该数字没有被替换，则概率为m/(m+1) * (m-1)/m + (1 – m/(m+1)) * 1 = m/(m+1)前n个满足条件，数学归纳法，当选择第n+1个数的时候，当然该数被选取的概率为m/(1+n)，之前被选择的数，首先他在之前被选择的概率为m/n，他能被保留的情况为后一个没被选择或被选择了但是自己没有被替换，所以概率为[m/(N+1) * (m-1)/m + (1-m/(N+1))]* m/N = m/(N+1) 代码：1234567891011121314151617// rand(): [0, 1]// nums.size() &gt;&gt; mvector&lt;int&gt; helper(vector&lt;int&gt;&amp; nums, int m) &#123; vector&lt;int&gt; ret; int n = nums.size(); for (int i = 0; i &lt; m; i++) &#123; ret.push_back(nums[i]); &#125; for (int i = m; i &lt; n; i++) &#123; double percent = (double)m / (i + 1); if (rand() &lt;= percent) &#123; int index = m * rand(); ret[index] = nums[i]; &#125; &#125; return ret;&#125; 随机数发生器（*） 本节参考了一道概率题 用50%拼p：p为20%，30%这种粒度，思路是构造0-9的随机数，50%产生0和1，那就产生4个数，共代表16个数，如果是10-15就舍去，重新生成，如果是小于p*10就生成0，否则生成1 用p拼50%：这种比较好处理，因为p(1-p)和(1-p)p的概率相同，所以用01和10代表50%，其余舍去 其余概率题可以参考资料1和资料2 汉诺塔1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int start, int end, int blank, int cnt) &#123; if (cnt == 1) &#123; nums[end].push_back(nums[start].back()); nums[start].pop_back(); for (auto i : nums) &#123; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; else &#123; helper(nums, start, blank, end, cnt - 1); helper(nums, start, end, end, 1); helper(nums, blank, end, start, cnt - 1); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; nums(3); for (int i = n; i &gt;= 1; i--) nums[0].push_back(i); helper(nums, 0, 2, 1, n); return 0;&#125;]]></content>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线段树算法实践]]></title>
    <url>%2F2019%2F04%2F10%2Fpractice-in-segment-tree%2F</url>
    <content type="text"><![CDATA[本文参考了岩之痕的线段树从零开始和线段树详解，原理可以在原文细看，本文主要是对线段树的几个例题进行实现，以备复习 为什么要用线段树有这样一个场景，给定一个数组，让求任意区间的累加和。 一般有两种算法 将这个区间上的所有数累加，然后返回 先求前n项的前缀和，然后将这期间差相减 但是，如果对其中任意一个数据进行操作，就会对累加和的时间复杂度有影响，第一种只需要修改一个元素，第二种却需要将其后的所有前缀和都进行修改。所以第一种查询费时间修改不费时间，第二种查询不费时间修改费时间。线段树就是为了适应修改和统计操作而设计的。 线段树的原理线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4*n),然后，将每个区间[L,R]都分解为少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。 具体可以参考线段树详解 线段树例子由此看出，用线段树统计的东西，必须符合区间加法，否则，不可能通过分成的子区间来得到[L,R]的统计结果。 符合区间加法的例子： 数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和 最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD ); 最大值——总最大值=max(左区间最大值，右区间最大值) 不符合区间加法的例子： 众数——只知道左右区间的众数，没法求总区间的众数 01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零 线段树的递归模版（区间和模版）定义123// 注意！线段树开始是从1开始的，不是0，否则会导致root&lt;&lt;1不是左节点vector&lt;int&gt; sum(n &lt;&lt; 2, 0); // 统计量vector&lt;int&gt; add(n &lt;&lt; 2, 0); // 惰性标记 建树123456789101112131415void PushUp(int root, vector&lt;int&gt;&amp; sum) &#123; // 向上更新 sum[rt] = sum[root &lt;&lt; 1] + sum[root &lt;&lt; 1 | 1]; // 左右值相加&#125;void build(int l, int r, int root, vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; sum) &#123; if (l == r) &#123; sum[root] = nums[l - 1]; // 更新叶子结点 return; &#125; int mid = l + (r - l) / 2; build(l, m, root &lt;&lt; 1, nums, sum); // 更新左右子树 build(m + 1, r, root &lt;&lt; 1 | 1, nums, sum); PushUp(root, sum); // 更新统计信息&#125; 点修改nums[index] += c12345678910void Update(int index, int c, int l, int r, int root, vector&lt;int&gt;&amp; sum) &#123; if (l == r) &#123; sum[root] += c; return; &#125; int mid = l + (r - l) / 2; if (index &lt; mid) Update(index, c, l, mid - 1, sum); else Update(index, c, mid, r, sum); PushUp(root, sum);&#125; 区间修改nums[left, right] += c1234567891011121314151617181920212223242526// 下推时必须将统计值更新，子树更新时必须将父节点也上推更新，保证数据一致性void PushDown(int root, int l_cnt, int r_cnt, vector&lt;int&gt;&amp; sum, vector,int&gt;&amp; add) &#123; // 下推标记 add[root &lt;&lt; 1] += add[root]; add[root &lt;&lt; 1 | 1] += add[root]; // 下推统计值 sum[root &lt;&lt; 1] += add[root] * l_cnt; sum[root &lt;&lt; 1 | 1] += add[root] * r_cnt; // 清除标记 add[root] = 0; &#125;void Update(int left, int right, int c, int l, int r, int root, vector&lt;int&gt;&amp; sum, vector&lt;int&gt;&amp; add) &#123; if (left &lt;= l &amp;&amp; r &lt;= right) &#123; sum[root] += c * (r - l + 1); // 更新统计信息 add[root] += c; // 更新惰性标记 return; &#125; int m = l + (r - l) / 2; PushDown(root, m - l + 1, r - m, sum, add); // 在更新新标记的时候将旧标记下推, 分别表示左右子树的更新个数 if (left &lt;= m) Update(left, right, c, l, m, root &lt;&lt; 1, sum, add); if (m &lt; right) Update(left, right, c, m + 1, r, root &lt;&lt; 1 | 1, sum, add); PushUp(root, sum); // 因为只下推了就标记，所以需要更新本节点的统计值&#125; 查询区间1234567891011121314int Query(int left, int right, int l, int r, int root, vector&lt;int&gt;&amp; sum, vector&lt;int&gt;&amp; add) &#123; // left, right为要查找的区间，l和r表示此函数所在的查询区间 if (left &lt;= l &amp;&amp; r &lt;= right) &#123; return sum[root]; &#125; int m = l + (r - l) / 2; PushDown(root, m - l + 1, r - m, sum, add); int ret = 0; if (left &lt;= m) ret += Query(left, right, l, m, root &lt;&lt; 1, sum, add); if (m &lt; right) ret += Query(left, right, m + 1, r, root &lt;&lt; 1 | 1, sum, add); return ret;&#125; 非递归原理和实现后期更新… 线段树思路 题目练习区间最大值（头条面试题）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;climits&gt;using namespace std;class segment_tree &#123;private: vector&lt;int&gt; ans; vector&lt;int&gt; add; void PushUp(int root) &#123; ans[root] = max(ans[root &lt;&lt; 1], ans[root &lt;&lt; 1 | 1]); &#125; void PushDown(int root) &#123; if (!add[root]) return; ans[root &lt;&lt; 1] += add[root]; ans[root &lt;&lt; 1 | 1] += add[root]; add[root &lt;&lt; 1] += add[root]; add[root &lt;&lt; 1 | 1] += add[root]; add[root] = 0; &#125; void build(int root, int l, int r, vector&lt;int&gt;&amp; nums) &#123; if (l == r) &#123; ans[root] = nums[l - 1]; return; &#125; int m = l + (r - l) / 2; build(root &lt;&lt; 1, l, m, nums); build(root &lt;&lt; 1 | 1, m + 1, r, nums); PushUp(root); &#125;public: segment_tree(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); ans = vector&lt;int&gt;(n &lt;&lt; 2, INT_MIN); add = vector&lt;int&gt;(n &lt;&lt; 2, 0); build(1, 1, n, nums); &#125; void update(int index, int c, int l, int r, int root) &#123; if (l == r) &#123; ans[root] += c; return; &#125; // 因为query的时候一定会下推，所以此处不需要下推标记 int m = l + (r - l) / 2; if (index &lt;= m) update(index, c, l, m, root &lt;&lt; 1); else update(index, c, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125; void update(int L, int R, int c, int l, int r, int root) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; ans[root] += c; add[root] += c; return; &#125; PushDown(root); int m = l + (r - l) / 2; if (L &lt;= m) update(L, R, c, l, m, root &lt;&lt; 1); if (m &lt; R) update(L, R, c, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125; int query(int L, int R, int l, int r, int root) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return ans[root]; &#125; PushDown(root); int m = l + (r - l) / 2; int ret = INT_MIN; if (L &lt;= m) ret = max(ret, query(L, R, l, m, root &lt;&lt; 1)); if (m &lt; R) ret = max(ret, query(L, R, m + 1, r, root &lt;&lt; 1 | 1)); return ret; &#125;&#125;;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; segment_tree* inst = new segment_tree(nums); int t; cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) &#123; int x, y, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; c; if (x == y) inst-&gt;update(x, c, 1, n, 1); else &#123; inst-&gt;update(x, y, c, 1, n, 1); for (int j = 1; j &lt;= n; j++) cout &lt;&lt; inst-&gt;query(j, j, 1, n, 1) &lt;&lt; " "; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 区间和123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// 2019-04-13#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class segment_tree &#123;private: vector&lt;int&gt; sum; vector&lt;int&gt; add; void PushUp(int root) &#123; sum[root] = sum[root &lt;&lt; 1] + sum[root &lt;&lt; 1 | 1]; &#125; void build(vector&lt;int&gt;&amp; nums, int l, int r, int root) &#123; if (l == r) &#123; sum[root] = nums[l - 1]; return; &#125; int m = l + (r - l) / 2; build(nums, l, m, root &lt;&lt; 1); build(nums, m + 1, r, root &lt;&lt; 1 |1); PushUp(root); &#125; void PushDown(int root, int cnt_l, int cnt_r) &#123; if (add[root]) &#123; sum[root &lt;&lt; 1] += add[root] * cnt_l; sum[root &lt;&lt; 1 | 1] += add[root] * cnt_r; add[root &lt;&lt; 1] += add[root]; add[root &lt;&lt; 1| 1] += add[root]; add[root] = 0; &#125; &#125;public: segment_tree(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); sum = vector&lt;int&gt;(n &lt;&lt; 2, 0); add = vector&lt;int&gt;(n &lt;&lt; 2, 0); build(nums, 1, n, 1); &#125; void Update(int L, int R, int c, int l, int r, int root) &#123; // 更新是加c到L..R cout &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; sum[root] += c * (r - l + 1); add[root] += c; return; &#125; int m = l + (r - l) / 2; PushDown(root, m - l + 1, r - m); if (L &lt;= m) Update(L, R, c, l, m, root &lt;&lt; 1); if (m &lt; R) Update(L, R, c, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125; void Update(int index, int c, int l, int r, int root) &#123; if (l == r) &#123; sum[root] += c; return; &#125; int m = l + (r - l) / 2; if (index &lt;= m) Update(index, c, l, m, root &lt;&lt; 1); else Update(index, c, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125; int query(int L, int R, int l, int r, int root) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return sum[root]; &#125; int ret = 0; int m = l + (r - l) / 2; PushDown(root, m - l + 1, r - m); if (L &lt;= m) ret += query(L, R, l, m, root &lt;&lt; 1); if (m &lt; R) ret += query(L, R, m + 1, r, root &lt;&lt; 1 | 1); return ret; &#125;&#125;;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; auto instance = new segment_tree(nums); int t; cin &gt;&gt; t; for (int i = 0; i &lt; t; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; cout &lt;&lt; instance-&gt;query(j, j, 1, n, 1) &lt;&lt; " "; &#125; cout &lt;&lt; endl; int x, y, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; c; if (x == y) &#123; instance-&gt;Update(x, c, 1, n, 1); &#125; else &#123; instance-&gt;Update(x, y, c, 1, n, 1); &#125; &#125; return 0;&#125; 最大公因数 因为最大公因数对于加减没有惰性标记代表性，所以这里采用乘除作为update的参数 update(L,R, c, l, r, root)代表给L到R的所有数都乘以c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110// 2019-04-13#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;class segment_tree &#123;private: vector&lt;int&gt; ans; vector&lt;int&gt; mul; int GCD(int a, int b) &#123; if (!b) return a; else return GCD(b, a % b); &#125; void PushUp(int root) &#123; ans[root] = GCD(ans[root &lt;&lt; 1], ans[root &lt;&lt; 1 | 1]); &#125; void PushDown(int root) &#123; if (mul[root] != 1) &#123; ans[root &lt;&lt; 1] *= mul[root]; ans[root &lt;&lt; 1 | 1] *= mul[root]; mul[root &lt;&lt; 1] *= mul[root]; mul[root &lt;&lt; 1 | 1] *= mul[root]; mul[root] = 1; &#125; &#125; void build(vector&lt;int&gt;&amp; nums, int l, int r, int root) &#123; if (l == r) &#123; ans[root] = nums[l - 1]; return; &#125; int m = l + (r - l) / 2; if (l &lt;= m) build(nums, l, m, root &lt;&lt; 1); if (m &lt; r) build(nums, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125;public: segment_tree(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // 根据不同问题要注意区间值的初始化问题，因为防止没有叶子导致上推引入异常值 // 因为GCD算法会判断!b，所以将初始值初始化为0可以直接返回a, // 这样上推可以直接调用GCD(ans[root &lt;&lt; 1], ans[root &lt;&lt; 1 | 1]) ans = vector&lt;int&gt;(n &lt;&lt; 2, 0); mul = vector&lt;int&gt;(n &lt;&lt; 2, 1); build(nums, 1, n, 1); &#125; void Update(int L, int R, int c, int l, int r, int root) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; ans[root] *= c; mul[root] *= c; return; &#125; PushDown(root); int m = l + (r - l) / 2; if (L &lt;= m) Update(L, R, c, l, m, root &lt;&lt; 1); if (m &lt; R) Update(L, R, c, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125; void Update(int index, int c, int l, int r, int root) &#123; if (l == r) &#123; ans[root] *= c; return; &#125; int m = l + (r - l) / 2; if (index &lt;= m) Update(index, c, l, m, root &lt;&lt; 1); else Update(index, c, m + 1, r, root &lt;&lt; 1 | 1); PushUp(root); &#125; int Query(int L, int R, int l, int r, int root) &#123; if (L &lt;= l &amp;&amp; r &lt;= R) &#123; return ans[root]; &#125; PushDown(root); int ret = 0; int m = l + (r - l) / 2; if (L &lt;= m) ret = GCD(ret, Query(L, R, l, m, root &lt;&lt; 1)); if (m &lt; R) ret = GCD(ret, Query(L, R, m + 1, r, root &lt;&lt; 1 | 1)); return ret; &#125;&#125;;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; auto instance = new segment_tree(nums); int t; cin &gt;&gt; t; for (auto i = 0; i &lt; t; i++) &#123; int x, y, c; cin &gt;&gt; x &gt;&gt; y &gt;&gt; c; if (x == y) &#123; instance-&gt;Update(x, c, 1, n, 1); &#125; else &#123; instance-&gt;Update(x, y, c, 1, n, 1); &#125; cin &gt;&gt; x &gt;&gt; y; cout &lt;&lt; instance-&gt;Query(x, y, 1, n, 1) &lt;&lt; endl; &#125; return 0;&#125; 字符串哈希待补充。。。 最长连续零待补充。。。 计数排序待补充。。。 扫描线待补充。。。]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【面经】Airbnb部分编程算法题]]></title>
    <url>%2F2019%2F03%2F18%2Finterview-coding-airbnb%2F</url>
    <content type="text"><![CDATA[本文收集网络上部分编程面经以供复习如果想要寻找测试用例可以参考git题库本文参考了参考资料1 数字分组12输入：一个数组，每一位表示角标值所在组号输出：一个数组，同一分组在一起，整个数组保证字典序最小 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0];&#125;vector&lt;int&gt; helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); unordered_map&lt;int, vector&lt;int&gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; m[nums[i]].push_back(i); &#125; vector&lt;vector&lt;int&gt;&gt; ans; for (auto i : m) &#123; ans.push_back(i.second); &#125; sort(ans.begin(), ans.end(), cmp); vector&lt;int&gt; ret; for (auto i : ans) &#123; for (auto j : i) &#123; ret.push_back(j); &#125; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 吃奶酪1234567题目：一个二维的数组，数组中有三个值，0,1,2，分别代表可走，不可走和奶酪，老鼠杰瑞要从左上走到右下，需要吃到所有奶酪，问最短的路径长度。输入：二维数组输出：最短路径长度思路：先用BFS找到所有奶酪和出入口两两之间的最短距离，然后用DFS找起点-奶酪全排列-终点的最短路径长 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;unordered_set&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; dp, int index, vector&lt;int&gt; ans, int&amp; ret) &#123; int n = ans.size(); if (index == n - 1) &#123; int temp = 0; for (int i = 0; i &lt; n - 1; i++) &#123; temp += dp[ans[i]][ans[i + 1]]; &#125; ret = temp &lt; ret ? temp : ret; return; &#125; for (int i = index; i &lt; n - 1; i++) &#123; swap(ans[i], ans[index]); dfs(dp, index + 1, ans, ret); &#125;&#125;int helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int m = nums.size(), n = nums[0].size(); nums[0][0] = 2; nums[m - 1][n - 1] = 2; vector&lt;pair&lt;int, int&gt;&gt; keys; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (nums[i][j] == 2) &#123; keys.push_back(&#123;i, j&#125;); &#125; &#125; &#125; int len = keys.size(); cout &lt;&lt; len &lt;&lt; endl; vector&lt;vector&lt;int&gt;&gt; dp(len, vector&lt;int&gt;(len, 0)); vector&lt;unordered_set&lt;string&gt;&gt; visited(len); int cnt = 0; vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; cur(len); for (int i = 0; i &lt; len; i++) &#123; cur[i].push_back(keys[i]); &#125; while (true) &#123; int mark = 0; vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; next(len); for (int i = 0; i &lt; len; i++) &#123; for (auto j : cur[i]) &#123; if (find(keys.begin(), keys.end(), j) != keys.end()) &#123; int index = (int)(find(keys.begin(), keys.end(), j) - keys.begin()); dp[i][index] = cnt; &#125; visited[i].insert(to_string(j.first) + "-" + to_string(j.second)); int a[4] = &#123;0, 0, 1, -1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; for (int k = 0; k &lt; 4; k++) &#123; int x = j.first + a[k], y = j.second + b[k]; if (x &lt; m &amp;&amp; x &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; (nums[x][y] == 0 || nums[x][y] == 2)) &#123; auto temp = to_string(x) + "-" + to_string(y); if (visited[i].find(temp) == visited[i].end()) &#123; next[i].push_back(&#123;x, y&#125;); mark ++; &#125; &#125; &#125; &#125; &#125; cnt ++; if (mark) cur = next; else break; &#125; for (auto i : dp) &#123; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; int ret = INT_MAX; vector&lt;int&gt; temp; for (auto i = 0; i &lt; len; i++) temp.push_back(i); dfs(dp, 1, temp, ret); return ret;&#125;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; nums(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; 表达式求值12输入：输入合法的表达式字符串，包括括号小数正负四则运算输出：表达式答案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;double getNum(string s, int&amp; index) &#123; int n = s.size(); double ret = 0; int cnt = -1; while (index &lt; n &amp;&amp; (s[index] == '.' || isdigit(s[index]))) &#123; if (s[index] == '.') cnt ++; else &#123; ret = ret * 10 + (s[index] - '0'); if (cnt &gt;= 0) cnt ++; &#125; index ++; &#125; cnt = max(0, cnt); return ret / pow(10, cnt);&#125;double helper(string s, int&amp; index) &#123; double ret = 0.0, cur_ret = 0.0; char op = '+'; int n = s.size(); while (index &lt; n &amp;&amp; s[index] != ')') &#123; if (isdigit(s[index]) || s[index] == '(') &#123; double temp = 0.0; if (isdigit(s[index])) temp = getNum(s, index); else &#123; index ++; temp = helper(s, index); index ++; &#125; switch (op) &#123; case '+' : cur_ret += temp;break; case '-' : cur_ret -= temp;break; case '*' : cur_ret *= temp;break; case '/' : cur_ret /= temp;break; &#125; &#125; else &#123; if (s[index] == '+' || s[index] == '-') &#123; ret += cur_ret; cur_ret = 0.0; &#125; op = s[index++]; &#125; &#125; return ret + cur_ret;&#125;int main() &#123; string s; cin &gt;&gt; s; int index = 0; cout &lt;&lt; helper(s, index) &lt;&lt; endl; return 0;&#125; 跷跷板123题目：给定一组数组（包含0），每一位表示该位置的重量，根据力矩*重量，计算该数组中一共有多少平衡点输入：一维数组输出：平衡点个数 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int ret = 0; for (int i = 0; i &lt;= n; i++) &#123; int l = 0, r = 0; for (int j = 0; j &lt; i; j++) &#123; l += nums[j] * (i - j); &#125; for (int j = 0; j &lt; n; j++) &#123; r += nums[j] * (j - i + 1); &#125; if (l == r) ret ++; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; k拼接12345题目：给定一个数组和一个数组k，从数组中选择最多k个数组，按原顺序组合，求能够组合的最大数字输入：一维数组，k输出：最大数字 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool check(string ans, string ret) &#123; if (ans.size() != ret.size()) return ans.size() &gt; ret.size(); return ans &gt; ret;&#125;void dfs(vector&lt;int&gt;&amp; nums, string ans, int index, int cnt, int k, string&amp; ret) &#123; int n = nums.size(); if (cnt == k) &#123; if (check(ans, ret)) ret = ans; &#125; else if (index &lt; n) &#123; dfs(nums, ans + to_string(nums[index]), index + 1, cnt + 1, k, ret); dfs(nums, ans, index + 1, cnt, k, ret); &#125;&#125;string helper(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); if (k &gt; n) return ""; string ret; dfs(nums, "", 0, 0, k, ret); return ret;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; nums(n, 0); for (auto i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums, k) &lt;&lt; endl; return 0;&#125; K遍历1题目：airbnb是一家与旅游相关的公司，给定一个pair的数组，和一个整型k。pair代表的是两地之间有通路，现在求需要遍历k个城市，最少需要多少次飞行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;unordered_set&gt;using namespace std;int helper(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, int n, int k) &#123; vector&lt;unordered_set&lt;int&gt;&gt; adj(n); vector&lt;int&gt; cnt(n, 0); for (auto i : nums) &#123; adj[i.first].insert(i.second); adj[i.second].insert(i.first); cnt[i.second] ++; cnt[i.first] ++; &#125; vector&lt;int&gt; cur; for (int i = 0; i &lt; n; i++) &#123; if (cnt[i] == 1) cur.push_back(i); &#125; int ans = 0; while (true) &#123; vector&lt;int&gt; next; for (auto i : cur) &#123; for (auto j : adj[i]) &#123; cnt[j] --; if (cnt[j] == 1) next.push_back(j); &#125; &#125; if (next.empty()) break; else cur = next; ans ++; &#125; if (cur.size() == 1) ans *= 2; else ans = ans * 2 + 1; if (ans &gt; k - 1) return ans; return k + (k - ans) * 2;&#125;int main() &#123; int n, t, k; cin &gt;&gt; n &gt;&gt; t &gt;&gt; k; vector&lt;pair&lt;int, int&gt;&gt; nums; for (int i = 0; i &lt; t; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; nums.push_back(&#123;x, y&#125;); &#125; cout &lt;&lt; helper(nums, n, k) &lt;&lt; endl; return 0;&#125; 状态机题目：给定一个状态转移图，和一个目标字符集合 M=| |A |B |C ||—-|:–:|:–:|:–:||A |B,C |C |A ||B |A,C |C |C ||C |A |A |A,B | S={A,B,C} 每两个字符可以转换成一个字符，例如AAB可以转成BC，判断是否能最后转化成目标集合中的字符 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;using namespace std;bool dfs(string cur, string next, unordered_set&lt;char&gt;&amp; target, int index, unordered_map&lt;char, unordered_map&lt;char, string&gt;&gt;&amp; nums) &#123; int n = cur.size(); if (index == n - 1) &#123; if (n == 1) &#123; return target.find(cur[0]) != target.end(); &#125; return dfs(next, "", target, 0, nums); &#125; for (auto i : nums[cur[index]][cur[index + 1]]) &#123; if (dfs(cur, next + i, target, index + 1, nums)) return true; &#125; return false;&#125;bool helper(string s, string t, unordered_map&lt;char, unordered_map&lt;char, string&gt;&gt;&amp; nums) &#123; unordered_set&lt;char&gt; target; for (auto i : t) &#123; target.insert(i); &#125; return dfs(s, "", target, 0, nums);&#125;int main() &#123; int n; cin &gt;&gt; n; unordered_map&lt;char, unordered_map&lt;char, string&gt;&gt; nums; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; string s; cin &gt;&gt; s; nums['a' + i]['a' + j] = s; &#125; &#125; string start, target; cin &gt;&gt; start &gt;&gt; target; cout &lt;&lt; helper(start, target, nums) &lt;&lt; endl; return 0;&#125; ip2cidr1题目：给定一个子网ip起点和连续的个数，判断最少需要多少个子网掩码可以恰好覆盖子网掩码范围，例如127.0.0.0-127.0.0.1需要255.255.255.254/31就可以，但是127.0.0.1-127.0.0.2就需要255.255.255.254/31和255.255.255.252/30 12Input: ip = &quot;255.0.0.7&quot;, n = 10Output: [&quot;255.0.0.7/32&quot;,&quot;255.0.0.8/29&quot;,&quot;255.0.0.16/32&quot;] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;string convert(long long ip, long long diff) &#123; string ret; for (int i = 0; i &lt; 4; i++) &#123; ret = to_string(ip &amp; 255) + "." + ret; ip &gt;&gt;= 8; &#125; ret.pop_back(); int cnt = 0; while (diff) diff /= 2, cnt ++; ret += "/" + to_string(32 - cnt + 1); return ret;&#125;vector&lt;string&gt; helper(string s, int n) &#123; long long ip = 0; long long ans = 0; for (auto i : s) &#123; if (i == '.') &#123; ip &lt;&lt;= 8; ip += ans; ans = 0; &#125; else ans = ans * 10 + (i - '0'); &#125; ip &lt;&lt;= 8; ip += ans; ip += n; vector&lt;string&gt; ret; while (n) &#123; cout &lt;&lt; n &lt;&lt; endl; long long temp = (ip - 1) &amp; ip; long long diff = ip - temp; while (diff &gt; n) diff /= 2; ip -= diff; n -= diff; ret.push_back(convert(ip, diff)); &#125; return ret;&#125;int main() &#123; string s; cin &gt;&gt; s; int n; cin &gt;&gt; n; for (auto i : helper(s, n)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 最大公约数和最小公倍数题目：给定一个数组，求每两个数字中的最大公约数的最大值，如果存在多个最大值，则求出这些最大公约数数字对中的最小公倍数的最小值 思路：求出数组两两数据对的所有公约数，然后根据放到一个数组中，将所有公约数排序，排序最大的就是最大公约数，如果存在多个对有最大公约数，求出这些数据对的最小公倍数（相乘除以最大公约数），然后求出其中的最小值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;#include &lt;climits&gt;using namespace std;bool cmp(const pair&lt;pair&lt;int, int&gt;, int&gt;&amp; a, const pair&lt;pair&lt;int, int&gt;, int&gt;&amp; b) &#123; return a.second &gt; b.second;&#125;int helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;pair&lt;pair&lt;int, int&gt;, int&gt;&gt; ans; for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; for (int k = min(nums[i], nums[j]); k &gt;= 1; k--) &#123; if (nums[i] % k == 0 &amp;&amp; nums[j] % k == 0) &#123; ans.push_back(&#123;&#123;nums[i], nums[j]&#125;, k&#125;); &#125; &#125; &#125; &#125; sort(ans.begin(), ans.end(), cmp); vector&lt;pair&lt;int, int&gt;&gt; cur; int len = ans.size(); for (int i = 0; i &lt; len &amp;&amp; ans[0].second == ans[i].second; i++) &#123; cur.push_back(ans[i].first); &#125; if (cur.size() == 1) return ans[0].second; int ret = INT_MAX; for (auto i : cur) &#123; ret = min(ret, i.first * i.second / ans[0].second); &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; 挪数字（9张披萨）题目：有一个3*3的矩阵，分别标着0-8，其中0代表空白，相邻的数字可以向其挪动，现给定一个任意的矩阵，求一共需要多少步可以还原该矩阵（顺序为0-8） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;unordered_set&gt;using namespace std;string to_string(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; string ret; for (auto i : nums) &#123; for (auto j : i) &#123; ret += to_string(j) + " "; &#125; &#125; return ret;&#125;bool check(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int index = 0; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j ++) &#123; if (nums[i][j] != (index++)) return false; &#125; &#125; return true;&#125;vector&lt;vector&lt;int&gt;&gt; decode(string s, int&amp; x, int&amp; y) &#123; int ans = 0; int index = 0; vector&lt;vector&lt;int&gt;&gt; ret(3, vector&lt;int&gt;(3, 0)); for (auto i : s) &#123; if (i == ' ') &#123; ret[index / 3][index % 3] = ans; if (ans == 0) &#123; x = index / 3; y = index % 3; &#125; ans = 0; index ++; &#125; else ans = ans * 10 + (i - '0'); &#125; return ret;&#125; int helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int ret = 0; vector&lt;string&gt; cur; unordered_set&lt;string&gt; m; cur.push_back(to_string(nums)); while (true) &#123; vector&lt;string&gt; next; for (auto i : cur) &#123; m.insert(i); int x, y; auto ans = decode(i, x, y); if (check(ans)) return ret; int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; for (int j = 0; j &lt; 4; j++) &#123; int X = x + a[j], Y = y + b[j]; if (X &lt; 3 &amp;&amp; X &gt;= 0 &amp;&amp; Y &lt; 3 &amp;&amp; Y &gt;= 0) &#123; swap(ans[x][y], ans[X][Y]); auto key = to_string(ans); if (m.find(key) == m.end()) next.push_back(key); swap(ans[x][y], ans[X][Y]); &#125; &#125; &#125; if (next.empty()) break; else cur = next; ret ++; &#125; return -1;&#125;int main() &#123; vector&lt;vector&lt;int&gt;&gt; nums(3, vector&lt;int&gt;(3, 0)); for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; 3; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; 分糖果题目：一个二维矩阵，每个位置上表示其权重，现为每个位置上分糖果，每个位置分的糖果不能比相邻的权重大的个数大，求最少糖果总数 思路：建立有向图，大的指向小的，相等互连，DFS搜索每个点，直至不能找到比他更小的或者周围都访问过，该点分1个，上一层分的周围点个数的最大值加一，从而求得最少糖果数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; dp, int i, int j) &#123; if (dp[i][j]) return dp[i][j]; int m = nums.size(), n = nums[0].size(); int ret = 0; int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; for (int k = 0; k &lt; 4; k++) &#123; int x = i + a[k], y = j + b[k]; if (x &lt; m &amp;&amp; x &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; nums[i][j] &gt; nums[x][y]) &#123; ret = max(ret, dfs(nums, dp, x, y)); &#125; &#125; ret++; dp[i][j] = ret; return ret;&#125;int helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int ret = 0; int m = nums.size(), n = nums[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; ret += dfs(nums, dp, i, j); &#125; &#125; return ret;&#125;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; nums(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; Leetcode 2691234567891011121314151617181920There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.For example,Given the following words in dictionary,[ &quot;wrt&quot;, &quot;wrf&quot;, &quot;er&quot;, &quot;ett&quot;, &quot;rftt&quot;]The correct order is: &quot;wertf&quot;.Note: You may assume all letters are in lowercase. If the order is invalid, return an empty string. There may be multiple valid order of letters, return any one of them is fine.Hide Company Tags Google FacebookHide Tags Graph Topological SortHide Similar Problems (M) Course Schedule II 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_set&gt;#include &lt;unordered_map&gt;using namespace std;string helper(vector&lt;string&gt;&amp; nums) &#123; int n = nums.size(); unordered_map&lt;char, unordered_set&lt;char&gt;&gt; adj; unordered_map&lt;char, int&gt; cnt; unordered_set&lt;char&gt; s; for (int i = 0; i &lt; n - 1; i++) &#123; int n1 = nums[i].size(), n2 = nums[i + 1].size(); for (int j = 0; j &lt; n1 &amp;&amp; j &lt; n2; j++) &#123; if (nums[i][j] != nums[i + 1][j]) &#123; adj[nums[i][j]].insert(nums[i + 1][j]); cnt[nums[i + 1][j]] ++; break; &#125; &#125; &#125; for (auto i : nums) &#123; for (auto j : i) &#123; s.insert(j); &#125; &#125; string cur; for (auto i : s) &#123; if (cnt.find(i) == cnt.end()) cur.push_back(i); &#125; string ret; while (true) &#123; string next; for (auto i : cur) &#123; ret.push_back(i); for (auto j : adj[i]) &#123; cnt[j]--; if (!cnt[j]) next.push_back(j); &#125; &#125; if (next.empty()) break; else cur = next; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;string&gt; nums; for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; nums.push_back(s); &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; Leetcode 2071234567891011121314151617181920212223There are a total of n courses you have to take, labeled from 0 to n-1.Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?Example 1:Input: 2, [[1,0]] Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.Example 2:Input: 2, [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.Note:The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.You may assume that there are no duplicate edges in the input prerequisites. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;unordered_set&gt;using namespace std;bool helper(int n, vector&lt;pair&lt;int, int&gt;&gt;&amp; nums) &#123; vector&lt;int&gt; cnt(n, 0); vector&lt;unordered_set&lt;int&gt;&gt; adj(n); for (auto i : nums) &#123; cnt[i.second]++; adj[i.first].insert(i.second); &#125; vector&lt;int&gt; cur; for (int i = 0; i &lt; n; i++) &#123; if (!cnt[i]) cur.push_back(i); &#125; int ret = 0; while (true) &#123; vector&lt;int&gt; next; for (auto i : cur) &#123; ret ++; for (auto j : adj[i]) &#123; cnt[j] --; if (!cnt[j]) next.push_back(j); &#125; &#125; if (next.empty()) break; else cur = next; &#125; return ret == n;&#125;int main() &#123; int n, t; cin &gt;&gt; n &gt;&gt; t; vector&lt;pair&lt;int, int&gt;&gt; nums; for (int i = 0; i &lt; t; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; nums.push_back(&#123;x, y&#125;); &#125; cout &lt;&lt; helper(n, nums) &lt;&lt; endl; return 0;&#125; Leetcode 21012345678910111213141516171819202122232425There are a total of n courses you have to take, labeled from 0 to n-1.Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]Given the total number of courses and a list of prerequisite pairs, return the ordering of courses you should take to finish all courses.There may be multiple correct orders, you just need to return one of them. If it is impossible to finish all courses, return an empty array.Example 1:Input: 2, [[1,0]] Output: [0,1]Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1] .Example 2:Input: 4, [[1,0],[2,0],[3,1],[3,2]]Output: [0,1,2,3] or [0,2,1,3]Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3] .Note:The input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.You may assume that there are no duplicate edges in the input prerequisites. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;unordered_set&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, int n) &#123; vector&lt;int&gt; ret; if (!n) return ret; vector&lt;int&gt; cnt(n, 0); vector&lt;unordered_set&lt;int&gt;&gt; adj(n); for (auto i : nums) &#123; adj[i.second].insert(i.first); cnt[i.first] ++; &#125; vector&lt;int&gt; cur; for (int i = 0; i &lt; n; i++) &#123; if (!cnt[i]) cur.push_back(i); &#125; while (true) &#123; vector&lt;int&gt; next; for (auto i : cur) &#123; ret.push_back(i); for (auto j : adj[i]) &#123; cnt[j] --; if (!cnt[j]) next.push_back(j); &#125; &#125; if (next.empty()) break; else cur = next; &#125; return ret.size() == n ? ret : vector&lt;int&gt;();&#125;int main() &#123; int n, t; cin &gt;&gt; n &gt;&gt; t; vector&lt;pair&lt;int, int&gt;&gt; nums; for (int i = 0; i &lt; t; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; nums.push_back(&#123;x, y&#125;); &#125; for (auto i : helper(nums, n)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; Leetcode 681234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Given an array of words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.You should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces &apos; &apos; when necessary so that each line has exactly maxWidth characters.Extra spaces between words should be distributed as evenly as possible. If the number of spaces on a line do not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.For the last line of text, it should be left justified and no extra space is inserted between words.Note:A word is defined as a character sequence consisting of non-space characters only.Each word&apos;s length is guaranteed to be greater than 0 and not exceed maxWidth.The input array words contains at least one word.Example 1:Input:words = [&quot;This&quot;, &quot;is&quot;, &quot;an&quot;, &quot;example&quot;, &quot;of&quot;, &quot;text&quot;, &quot;justification.&quot;]maxWidth = 16Output:[ &quot;This is an&quot;, &quot;example of text&quot;, &quot;justification. &quot;]Example 2:Input:words = [&quot;What&quot;,&quot;must&quot;,&quot;be&quot;,&quot;acknowledgment&quot;,&quot;shall&quot;,&quot;be&quot;]maxWidth = 16Output:[ &quot;What must be&quot;, &quot;acknowledgment &quot;, &quot;shall be &quot;]Explanation: Note that the last line is &quot;shall be &quot; instead of &quot;shall be&quot;, because the last line must be left-justified instead of fully-justified. Note that the second line is also left-justified becase it contains only one word.Example 3:Input:words = [&quot;Science&quot;,&quot;is&quot;,&quot;what&quot;,&quot;we&quot;,&quot;understand&quot;,&quot;well&quot;,&quot;enough&quot;,&quot;to&quot;,&quot;explain&quot;, &quot;to&quot;,&quot;a&quot;,&quot;computer.&quot;,&quot;Art&quot;,&quot;is&quot;,&quot;everything&quot;,&quot;else&quot;,&quot;we&quot;,&quot;do&quot;]maxWidth = 20Output:[ &quot;Science is what we&quot;, &quot;understand well&quot;, &quot;enough to explain to&quot;, &quot;a computer. Art is&quot;, &quot;everything else we&quot;, &quot;do &quot;] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;string&gt; helper(vector&lt;string&gt;&amp; nums, int w) &#123; int cnt = 0; vector&lt;vector&lt;string&gt;&gt; ans; vector&lt;string&gt; cur; for (auto i : nums) &#123; if (i.size() + 1 + cnt &gt; w + 1) &#123; ans.push_back(cur); cur = vector&lt;string&gt;(&#123;i&#125;); cnt = i.size() + 1; &#125; else &#123; cnt += i.size() + 1; cur.push_back(i); &#125; &#125; ans.push_back(cur); int n = ans.size(); vector&lt;string&gt; ret; for (int i = 0; i &lt; n - 1; i++) &#123; if (ans[i].size() == 1) &#123; while (ans[i][0].size() &lt; w) ans[i][0].push_back(&apos; &apos;); ret.push_back(ans[i][0]); continue; &#125; int temp = 0; for (auto j : ans[i]) &#123; temp += (int)j.size(); &#125; int delta = (w - temp) / (ans[i].size() - 1); int c = (w - temp) % (ans[i].size() - 1); string cur_str; for (int j = 0; j &lt; ans[i].size() - 1; j++) &#123; cur_str += ans[i][j]; for (int k = 0; k &lt; delta; k++) cur_str.push_back(&apos; &apos;); if (c &gt; 0) cur_str.push_back(&apos; &apos;); c--; &#125; cur_str += ans[i].back(); cout &lt;&lt; cur_str &lt;&lt; endl; ret.push_back(cur_str); &#125; string cur_str; for (auto i : ans.back()) &#123; cur_str += i; if (cur_str.size() &lt; w) cur_str.push_back(&apos; &apos;); &#125; while (cur_str.size() &lt; w) cur_str.push_back(&apos; &apos;); ret.push_back(cur_str); return ret;&#125;int main() &#123; int n, w; cin &gt;&gt; n &gt;&gt; w; vector&lt;string&gt; nums; for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; nums.push_back(s); &#125; for (auto i : helper(nums, w)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; Leetcode 336123456789101112Given a list of unique words, find all pairs of distinct indices (i, j) in the given list, so that the concatenation of the two words, i.e. words[i] + words[j] is a palindrome.Example 1:Input: [&quot;abcd&quot;,&quot;dcba&quot;,&quot;lls&quot;,&quot;s&quot;,&quot;sssll&quot;]Output: [[0,1],[1,0],[3,2],[2,4]] Explanation: The palindromes are [&quot;dcbaabcd&quot;,&quot;abcddcba&quot;,&quot;slls&quot;,&quot;llssssll&quot;]Example 2:Input: [&quot;bat&quot;,&quot;tab&quot;,&quot;cat&quot;]Output: [[0,1],[1,0]] Explanation: The palindromes are [&quot;battab&quot;,&quot;tabbat&quot;] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;using namespace std;bool check(string s) &#123; int n = s.size(); for (int i = 0; i &lt; n / 2; i++) &#123; if (s[i] != s[n - i - 1]) return false; &#125; return true;&#125;vector&lt;vector&lt;int&gt;&gt; helper(vector&lt;string&gt;&amp; nums) &#123; int n = nums.size(); unordered_map&lt;string, int&gt; m; for (int i = 0; i &lt; n; i++) &#123; string s = nums[i]; reverse(s.begin(), s.end()); m[s] = i; &#125; vector&lt;vector&lt;int&gt;&gt; ret; if (m.find("") != m.end()) &#123; for (int i = 0; i &lt; n; i++) &#123; if (check(nums[i]) &amp;&amp; m[""] != i) ret.push_back(&#123;m[""], i&#125;); &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; string s = nums[i]; for (int j = 0; j &lt; s.size(); j++) &#123; string left = s.substr(0, j), right = s.substr(j); if (m.find(left) != m.end() &amp;&amp; check(right) &amp;&amp; m[left] != i) ret.push_back(&#123;i, m[left]&#125;); if (m.find(right) != m.end() &amp;&amp; check(left) &amp;&amp; m[right] != i) ret.push_back(&#123;m[right], i&#125;); &#125; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;string&gt; nums; for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; nums.push_back(s); &#125; // vector&lt;string&gt; nums(&#123;"abcd","dcba","lls","s","sssll"&#125;); for (auto i : helper(nums)) &#123; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Leetcode 7912345678910111213141516Given a 2D board and a word, find if the word exists in the grid.The word can be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.Example:board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool dfs(vector&lt;vector&lt;char&gt;&gt;&amp; nums, int i, int j, string s, int index) &#123; int m = nums.size(), n = nums[0].size(); int len = s.size(); if (s[index] != nums[i][j]) return false; if (index == len - 1) return true; char temp = s[index++]; nums[i][j] = '\0'; int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; for (int k = 0; k &lt; 4; k++) &#123; int x = i + a[k], y = j + b[k]; if (x &lt; m &amp;&amp; x &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; dfs(nums, x, y, s, index)) return true; &#125; nums[i][j] = temp; return false;&#125;bool helper(vector&lt;vector&lt;char&gt;&gt;&amp; nums, string s) &#123; if (nums.empty() || nums[0].empty()) return false; int m = nums.size(), n = nums[0].size(); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dfs(nums, i, j, s, 0)) return true; &#125; &#125; return false;&#125;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;char&gt;&gt; nums(m, vector&lt;char&gt;(n, ' ')); for (auto i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; string s; cin &gt;&gt; s; cout &lt;&lt; helper(nums, s) &lt;&lt; endl; return 0;&#125; Leetcode 21212345678910111213141516Given a 2D board and a list of words from the dictionary, find all words in the board.Each word must be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.Example:Input: words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]Output: [&quot;eat&quot;,&quot;oath&quot;] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;unordered_set&gt;using namespace std;struct TrieNode &#123; bool isKey; TrieNode* child[26]; TrieNode(): isKey(false) &#123; memset(child, NULL, sizeof(child)); &#125;&#125;;TrieNode* build(vector&lt;string&gt;&amp; nums) &#123; TrieNode* root = new TrieNode(); for (auto i : nums) &#123; TrieNode* cur = root; for (auto j : i) &#123; if (!cur-&gt;child[j - 'a']) cur-&gt;child[j - 'a'] = new TrieNode(); cur = cur-&gt;child[j - 'a']; &#125; cur-&gt;isKey = true; &#125; return root;&#125;void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; nums, int i, int j, TrieNode* cur, string ans, unordered_set&lt;string&gt;&amp; ret) &#123; int m = nums.size(), n = nums[0].size(); int index = nums[i][j] - 'a'; if (!cur-&gt;child[index]) return; ans.push_back(nums[i][j]); cur = cur-&gt;child[index]; if (cur-&gt;isKey) &#123; ret.insert(ans); &#125; nums[i][j] = '\0'; int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; for (int k = 0; k &lt; 4; k++) &#123; int x = i + a[k], y = j + b[k]; if (x &lt; m &amp;&amp; x &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; nums[x][y] != '\0') &#123; dfs(nums, x, y, cur, ans, ret); &#125; &#125; nums[i][j] = 'a' + index;&#125;vector&lt;string&gt; helper(vector&lt;vector&lt;char&gt;&gt;&amp; nums, vector&lt;string&gt;&amp; target) &#123; if (nums.empty() || nums[0].empty()) return vector&lt;string&gt;(); int m = nums.size(), n = nums[0].size(); unordered_set&lt;string&gt; ans; auto root = build(target); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dfs(nums, i, j, root, "", ans); &#125; &#125; vector&lt;string&gt; ret; for (auto i : ans) ret.push_back(i); return ret;&#125;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;char&gt;&gt; nums(m, vector&lt;char&gt;(n, '0')); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; int t; cin &gt;&gt; t; vector&lt;string&gt; target; for (int i = 0; i &lt; t; i++) &#123; string s; cin &gt;&gt; s; target.push_back(s); &#125; for (auto i : helper(nums, target)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 判断麻将胡牌1存在一个对和四个三连张或者相同三张 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;algorithm&gt;using namespace std;bool dfs(string s, int index, int a, int b, unordered_map&lt;char, int&gt;&amp; m) &#123; if (a == 1 &amp;&amp; b == 4) return true; int n = s.size(); if (index == n) return false; if (!a &amp;&amp; m[s[index]] &gt;= 2) &#123; m[s[index]] -= 2; if (dfs(s, index + 1, a + 1, b, m)) return true; m[s[index]] += 2; &#125; if (b &lt; 4 &amp;&amp; m[s[index]]) &#123; if (m[s[index]] &gt;= 3) &#123; m[s[index]] -= 3; if (dfs(s, index + 1, a, b + 1, m)) return true; m[s[index]] += 3; &#125; if (m[s[index]] &amp;&amp; m[s[index] + 1] &amp;&amp; m[s[index] + 2]) &#123; m[s[index]] --; m[s[index] + 1] --; m[s[index] + 2] --; if (dfs(s, index + 1, a, b + 1, m)) return true; m[s[index]] ++; m[s[index] + 1] ++; m[s[index] + 2] ++; &#125; &#125; if (dfs(s, index + 1, a, b, m)) return true; return false;&#125;bool helper(string s) &#123; if (s.size() != 14) return false; sort(s.begin(), s.end()); unordered_map&lt;char, int&gt; m; for (auto i : s) m[i] ++; return dfs(s, 0, 0, 0, m);&#125;int main() &#123; string s; cin &gt;&gt; s; cout &lt;&lt; helper(s) &lt;&lt; endl; return 0;&#125; 社交网络1234给出社交网络中的关注关系（图的边），信息可以从被关注者流到关注者，挑选最少的人将一个信息传播到所有人那里 思路：先BFS找到从每个节点出发能到达的所有节点，然后dfs找 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;unordered_set&gt;#include &lt;unordered_map&gt;using namespace std;void dfs(unordered_map&lt;int, unordered_set&lt;int&gt;&gt;&amp; visited, vector&lt;int&gt; ans, vector&lt;int&gt;&amp; ret, unordered_set&lt;int&gt; s, int index, vector&lt;int&gt;&amp; key) &#123; int n = visited.size(); if (s.size() == n) &#123; if (ans.size() &lt; ret.size()) ret = ans; return; &#125; if (index == n) return; dfs(visited, ans, ret, s, index + 1, key); ans.push_back(key[index]); for (auto i : visited[key[index]]) &#123; s.insert(i); &#125; dfs(visited, ans, ret, s, index + 1, key);&#125;vector&lt;int&gt; helper(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums) &#123; unordered_map&lt;int, unordered_set&lt;int&gt;&gt; adj; unordered_set&lt;int&gt; s; for (auto i : nums) &#123; adj[i.first].insert(i.second); s.insert(i.first); s.insert(i.second); &#125; unordered_map&lt;int, unordered_set&lt;int&gt;&gt; visited; int len = s.size(); vector&lt;vector&lt;int&gt;&gt; cur; vector&lt;int&gt; index; for (auto i : s) &#123; index.push_back(i); cur.push_back(vector&lt;int&gt;(&#123;i&#125;)); &#125; while (true) &#123; vector&lt;vector&lt;int&gt;&gt; next(len); int check = 0; for (int i = 0; i &lt; len; i++) &#123; for (auto j : cur[i]) &#123; visited[index[i]].insert(j); for (auto k : adj[j]) &#123; if (visited[index[i]].find(k) == visited[index[i]].end()) &#123; next[i].push_back(k); check ++; &#125; &#125; &#125; &#125; if (check) cur = next; else break; &#125; vector&lt;int&gt; ret = index; dfs(visited, vector&lt;int&gt;(), ret, unordered_set&lt;int&gt;(), 0, index); return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; nums; for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; nums.push_back(&#123;x, y&#125;); &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; Preference List每个人都有一个preference的排序，在不违反每个人的preference的情况下得到总体的preference的排序 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; unordered_map&lt;int, unordered_set&lt;int&gt;&gt; adj; unordered_set&lt;int&gt; s; for (auto i : nums) &#123; for (auto j : i) &#123; s.insert(j); &#125; &#125; unordered_map&lt;int, int&gt; cnt; for (auto num : nums) &#123; int len = num.size(); for (int i = 0; i &lt; len - 1; i++) &#123; adj[num[i]].insert(num[i + 1]); cnt[num[i + 1]] ++; &#125; &#125; vector&lt;int&gt; cur; for (auto i : s) &#123; if (cnt.find(i) == cnt.end()) cur.push_back(i); &#125; vector&lt;int&gt; ret; while (true) &#123; vector&lt;int&gt; next; for (auto i : cur) &#123; ret.push_back(i); for (auto j : adj[i]) &#123; cnt[j] --; if (!cnt[j]) next.push_back(j); &#125; &#125; if (next.empty()) break; else cur = next; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; nums(n); for (int i = 0; i &lt; n; i++) &#123; int t; cin &gt;&gt; t; for (int j = 0; j &lt; t; j++) &#123; int x; cin &gt;&gt; x; nums[i].push_back(x); &#125; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; 数字变英语0-100，输出对应的英语 123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;string helper(int n) &#123; if (!n) return "zero"; string a[10] = &#123;"one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten"&#125;; if (n &lt;= 10) return a[n - 1]; string b[9] = &#123;"eleven", "twelven", "thirteen", "forteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"&#125;; if (n &lt; 20) return b[n - 11]; if (n == 100) return "one hundred"; string c[8] = &#123;"twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"&#125;; string ret = c[n / 10 - 2]; if (n % 10) ret += " " + a[n % 10 - 1]; return ret;&#125;int main() &#123; for (int i = 0; i &lt; 100; i ++) &#123; cout &lt;&lt; helper(i) &lt;&lt; endl; &#125; return 0;&#125; round number1234567891011121314151617When you book on airbnb the total price is:Total price = base price + service fee + cleaning fee + …input : array of decimals ~ Xoutput : array of int ~ YBut they need to satisfy the condition:sum(Y) = round(sum(x))minmize (|y1-x1| + |y2-x2| + ... + |yn-xn|)Example1:input = 30.3, 2.4, 3.5output = 30 2 4Example2:input = 30.9, 2.4, 3.9output = 31 2 4 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(const pair&lt;double, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b) &#123; return a.first - (int)a.first &gt; b.first - (int)b.first;&#125;vector&lt;int&gt; helper(vector&lt;double&gt;&amp; nums) &#123; int n = nums.size(); double ans_d = 0.0; int ans_i = 0; vector&lt;int&gt; ret; vector&lt;pair&lt;double, int&gt;&gt; ans; for (int i = 0; i &lt; n; i++) &#123; ret.push_back((int)nums[i]); ans_i += ret.back(); ans_d += nums[i]; ans.push_back(&#123;nums[i], i&#125;); &#125; if (ans_i == (int)(ans_d + 0.5)) return ret; int c = (int)(ans_d + 0.5) - ans_i; sort(ans.begin(), ans.end(), cmp); for (int i = 0; i &lt; n &amp;&amp; c; i++) &#123; ret[ans[i].second] ++; c--; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;double&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 2D itertaor + remove()12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class MyIter &#123;private: vector&lt;vector&lt;int&gt;&gt;::iterator ibegin, iend, icur; vector&lt;int&gt;::iterator jcur;public: MyIter(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; ibegin = nums.begin(); iend = nums.end(); icur = ibegin; if (ibegin != iend) &#123; jcur = ibegin-&gt;begin(); &#125; &#125; bool hasNext() &#123; if (icur == iend) return false; if (jcur != icur-&gt;end()) return true; icur ++; while (icur != iend &amp;&amp; icur-&gt;begin() == icur-&gt;end()) icur++; if (icur == iend) return false; jcur = icur-&gt;begin(); return true; &#125; int next() &#123; if (hasNext()) &#123; int ret = *jcur; jcur ++; return ret; &#125; return -1; &#125; void erase() &#123; if (hasNext()) &#123; icur-&gt;erase(jcur); &#125; &#125;&#125;;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; nums; for (int i = 0; i &lt; n; i++) &#123; int t; cin &gt;&gt; t; vector&lt;int&gt; ans(t, 0); for (int j = 0; j &lt; t; j++) &#123; cin &gt;&gt; ans[j]; &#125; nums.push_back(ans); &#125; auto iter = new MyIter(nums); iter-&gt;erase(); while (iter-&gt;hasNext()) &#123; cout &lt;&lt; iter-&gt;next() &lt;&lt; endl; &#125; return 0;&#125; 分页1234567891011121314151617181920212223242526272829303132333435第一轮实现分页显示。给了以下一些输入数据，要求将以下行分页显示，每页12行，其中每行已经按score排好序，分页显示的时候如果有相同host id的行，则将后面同host id的行移到下一页。[&quot;host_id,listing_id,score,city&quot;,&quot;1,28,300.1,SanFrancisco&quot;,&quot;4,5,209.1,SanFrancisco&quot;,&quot;20,7,208.1,SanFrancisco&quot;,&quot;23,8,207.1,SanFrancisco&quot;,&quot;16,10,206.1,Oakland&quot;,&quot;1,16,205.1,SanFrancisco&quot;,&quot;6,29,204.1,SanFrancisco&quot;,&quot;7,20,203.1,SanFrancisco&quot;,&quot;8,21,202.1,SanFrancisco&quot;,&quot;2,18,201.1,SanFrancisco&quot;,&quot;2,30,200.1,SanFrancisco&quot;,&quot;15,27,109.1,Oakland&quot;,&quot;10,13,108.1,Oakland&quot;,&quot;11,26,107.1,Oakland&quot;,&quot;12,9,106.1,Oakland&quot;,&quot;13,1,105.1,Oakland&quot;,&quot;22,17,104.1,Oakland&quot;,&quot;1,2,103.1,Oakland&quot;,&quot;28,24,102.1,Oakland&quot;,&quot;18,14,11.1,SanJose&quot;,&quot;6,25,10.1,Oakland&quot;,&quot;19,15,9.1,SanJose&quot;,&quot;3,19,8.1,SanJose&quot;,&quot;3,11,7.1,Oakland&quot;,&quot;27,12,6.1,Oakland&quot;,&quot;1,3,5.1,Oakland&quot;,&quot;25,4,4.1,SanJose&quot;,&quot;5,6,3.1,SanJose&quot;,&quot;29,22,2.1,SanJose&quot;,&quot;30,23,1.1,SanJose&quot;] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_set&gt;using namespace std;vector&lt;vector&lt;string&gt;&gt; helper(vector&lt;string&gt;&amp; nums, int n) &#123; vector&lt;vector&lt;string&gt;&gt; ret; while (!nums.empty()) &#123; vector&lt;string&gt; cur; unordered_set&lt;string&gt; m; for (auto i = nums.begin(); i != nums.end() &amp;&amp; (int)cur.size() &lt; n;) &#123; if (m.find(*i) != m.end()) &#123; i ++; continue; &#125; cur.push_back(*i); m.insert(*i); nums.erase(i); &#125; for (auto i = nums.begin(); i != nums.end() &amp;&amp; (int) cur.size() &lt; n;) &#123; cur.push_back(*i); nums.erase(i); &#125; ret.push_back(cur); &#125; return ret;&#125;int main() &#123; vector&lt;string&gt; nums(&#123;"host_id,listing_id,score,city","1,28,300.1,SanFrancisco","4,5,209.1,SanFrancisco","20,7,208.1,SanFrancisco","23,8,207.1,SanFrancisco","16,10,206.1,Oakland","1,16,205.1,SanFrancisco","6,29,204.1,SanFrancisco","7,20,203.1,SanFrancisco","8,21,202.1,SanFrancisco","2,18,201.1,SanFrancisco","2,30,200.1,SanFrancisco","15,27,109.1,Oakland","10,13,108.1,Oakland","11,26,107.1,Oakland","12,9,106.1,Oakland","13,1,105.1,Oakland","22,17,104.1,Oakland","1,2,103.1,Oakland","28,24,102.1,Oakland","18,14,11.1,SanJose","6,25,10.1,Oakland","19,15,9.1,SanJose","3,19,8.1,SanJose","3,11,7.1,Oakland","27,12,6.1,Oakland","1,3,5.1,Oakland","25,4,4.1,SanJose","5,6,3.1,SanJose","29,22,2.1,SanJose","30,23,1.1,SanJose" &#125;); int n; cin &gt;&gt; n; auto ret = helper(nums, n); for (auto i : ret) &#123; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; menu order点菜，菜价格为double 是否可以花完钱 如何花完钱 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;using namespace std;bool helper(vector&lt;double&gt;&amp; nums, double target) &#123; int n = nums.size(); vector&lt;int&gt; ans(n, 0); for (int i = 0; i &lt; n; i++) &#123; ans[i] = round(nums[i] * 100); // 这里必须使用round，因为浮点数乘法后取整是直接截取，在计算当中可能是近似值，所以可能直接截取，导致得不到想要的值 &#125; int m = round(target * 100); vector&lt;bool&gt; dp(m + 1, false); cout &lt;&lt; m &lt;&lt; endl; dp[0] = true; sort(ans.begin(), ans.end()); for (int i = 0; i &lt; n; i++) &#123; for (int j = m; j &gt;= ans[i]; j--) &#123; if (j == m) &#123; cout &lt;&lt; j - ans[i] &lt;&lt; ans[i] &lt;&lt; " " &lt;&lt; dp[j - ans[i]] &lt;&lt; endl; &#125; dp[j] = dp[j] || dp[j - ans[i]]; &#125; &#125; for (int i = 0; i &lt;= m; i++) &#123; if (dp[i]) cout &lt;&lt; i &lt;&lt; endl; &#125; return dp[m];&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;double&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; double target; cin &gt;&gt; target; cout &lt;&lt; helper(nums, target) &lt;&lt; endl; return 0;&#125;/*32.3 0.3 68.6*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;utility&gt;using namespace std;bool cmp(const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b) &#123; return a.first &lt; b.first;&#125;void dfs(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, int index, int ans, int target, vector&lt;int&gt; cur, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; if (ans &gt; target) return; if (target == ans) &#123; ret.push_back(cur); return; &#125; int n = nums.size(); if (index == n) return; dfs(nums, index + 1, ans, target, cur, ret); if (nums[index].first + ans &gt; target) return; cur.push_back(nums[index].second); dfs(nums, index + 1, ans + nums[index].first, target, cur, ret);&#125;vector&lt;vector&lt;int&gt;&gt; helper(vector&lt;double&gt;&amp; nums, double s) &#123; int n = nums.size(); vector&lt;pair&lt;int, int&gt;&gt; ans; int target = s * 100; for (int i = 0; i &lt; n; i++) &#123; ans.push_back(&#123;nums[i] * 100, i&#125;); &#125; sort(ans.begin(), ans.end(), cmp); vector&lt;vector&lt;int&gt;&gt; ret; dfs(ans, 0, 0, target, vector&lt;int&gt;(), ret); return ret; &#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;double&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; double target; cin &gt;&gt; target; for (auto i : helper(nums, target)) &#123; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; Hilbert CurveHilbert Curve参考文献 Hilbert曲线可以无限阶下去，从1阶开始，落在一个矩阵里，让你写个function，三个参数（x,y,阶数），return 这个点（x,y）是在这阶curve里从原点出发的第几步 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;int helper(int x, int y, int iter) &#123; if (iter == 0) return 1; int len = 1 &lt;&lt; (iter - 1); int ans = 1 &lt;&lt; (2 * (iter - 1)); if (x &lt; len &amp;&amp; y &lt; len) &#123; // 第一象限旋转90度 return helper(y, x, iter - 1); &#125; else if (x &lt; len &amp;&amp; y &gt;= len) &#123; // 平移第一象限 return ans + helper(x, y - len, iter - 1); &#125; else if (x &gt;= len &amp;&amp; y &gt;= len) &#123; // 平移第一象限 return 2 * ans + helper(x - len, y - len, iter - 1); &#125; else &#123; // 逆时针旋转90度 return 3 * ans + helper(len - y - 1, len * 2 - x - 1, iter - 1); &#125;&#125;int main() &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; int iter; cin &gt;&gt; iter; cout &lt;&lt; helper(x, y, iter) &lt;&lt; endl; return 0;&#125; Meeting Time一组pair，标明start,end，表示一个员工忙碌的时间段，现在求出至少有k个员工不忙碌的时间段 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;climits&gt;#include &lt;math.h&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; helper(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, int n, int k) &#123; int start = INT_MAX, end = INT_MIN; for (auto i : nums) &#123; start = min(start, i.first); end = max(end, i.second); &#125; int len = end - start + 1; vector&lt;int&gt; cnt(len, 0); for (auto i : nums) &#123; cnt[i.first - start] ++; cnt[i.second - start] --; &#125; vector&lt;pair&lt;int, int&gt;&gt; ret; int limit = 0; int ans = 0; for (int i = 0; i &lt; len; i++) &#123; if (ans + k &lt;= n &amp;&amp; ans + cnt[i] + k &gt; n &amp;&amp; limit != i) &#123; ret.push_back(&#123;limit + start, i + start&#125;); &#125; if (ans + k &gt; n &amp;&amp; ans + cnt[i] + k &lt;= n)&#123; limit = i; &#125; ans += cnt[i]; &#125; if (ans + k &lt; n) &#123; ret.push_back(&#123;limit + start, end&#125;); &#125; return ret;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;pair&lt;int, int&gt;&gt; nums; for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; nums.push_back(&#123;x, y&#125;); &#125; for (auto i : helper(nums, n, k)) &#123; cout &lt;&lt; i.first &lt;&lt; " " &lt;&lt; i.second &lt;&lt; endl; &#125; return 0;&#125; 小于k步的最小距离有权有向图，给定起点和终点，求小于k次的最小距离 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;climits&gt;#include &lt;unordered_set&gt;using namespace std;int helper(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, vector&lt;int&gt;&amp; val, int n, int k, int start, int end) &#123; int len = nums.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, INT_MAX)); vector&lt;unordered_set&lt;int&gt;&gt; adj(n); for (int i = 0; i &lt; len; i++) &#123; dp[nums[i].first][nums[i].second] = val[i]; adj[nums[i].first].insert(nums[i].second); &#125; dp[start][start] = 0; vector&lt;int&gt; cur; cur.push_back(start); for (int i = 0; i &lt; k; i++) &#123; vector&lt;int&gt; next; for (auto a : cur) &#123; for (auto j : adj[a]) &#123; if (dp[a][j] != INT_MAX) dp[start][j] = min(dp[start][j], dp[start][a] + dp[a][j]); next.push_back(j); &#125; &#125; cur = next; &#125; return dp[start][end];&#125;int main() &#123; int n, t, k; cin &gt;&gt; n &gt;&gt; t &gt;&gt; k; vector&lt;pair&lt;int, int&gt;&gt; nums; vector&lt;int&gt; val; for (int i = 0; i &lt; t; i++) &#123; int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; nums.push_back(&#123;x, y&#125;); val.push_back(v); &#125; int s, e; cin &gt;&gt; s &gt;&gt; e; cout &lt;&lt; helper(nums, val, n, k, s, e) &lt;&lt; endl; return 0;&#125; URL Shortener看描述好像是url里的id如果有某些位置大小写换了会导致原来的url decode有问题，需要重写encode方法，回溯改某些位的大小写判断 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;int decode(string s) &#123; if (s == "kljJJ324hijkS_") return 848662; else return -1;&#125;char convert(char c) &#123; if (c &lt;= 'Z' &amp;&amp; c &gt;= 'A') return 'a' + (c - 'A'); else return 'A' + (c - 'a');&#125;int helper(string s, int index) &#123; int n = s.size(); if (index == n) &#123; return decode(s); &#125; if ((s[index] &lt;= 'Z' &amp;&amp; s[index] &gt;= 'A') || (s[index] &lt;= 'z' &amp;&amp; s[index] &gt;= 'a')) &#123; int l = helper(s, index + 1); string temp = s.substr(0, index) + convert(s[index]) + s.substr(index + 1); int r = helper(temp, index + 1); if (l != -1 || r != -1) &#123; return l == -1 ? r : l; &#125; return -1; &#125; return helper(s, index + 1);&#125;int main() &#123; string s = "kljJJ324hijks_"; cout &lt;&lt; helper(s, 0) &lt;&lt; endl; return 0;&#125; wizardsThere are 10 wizards, 0-9, you are given a list that each entry is a list of wizards known by wizard. Define the cost between wizards and wizard as square of different of i and j. To find the min cost between 0 and 9. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;unordered_set&gt;using namespace std;int helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;unordered_set&lt;int&gt;&gt; adj(n); for (int i = 0; i &lt; n; i++) &#123; for (auto j : nums[i]) &#123; adj[i].insert(j); &#125; &#125; unordered_set&lt;int&gt; s; vector&lt;int&gt; dp(n, INT_MAX); for (int i = 0; i &lt; n; i++) &#123; s.insert(i); &#125; dp[0] = 0; while (!s.empty()) &#123; int check = 0; int index = -1, ans = INT_MAX; for (auto i : s) &#123; if (dp[i] &lt; ans) &#123; index = i; ans = dp[i]; &#125; &#125; s.erase(index); for (auto i : adj[index]) &#123; dp[i] = min(dp[i], dp[index] + (int)pow((i - index), 2)); check ++; &#125; if (!check) break; &#125; return dp[n - 1];&#125;int main() &#123; vector&lt;vector&lt;int&gt;&gt; nums( &#123;&#123;1, 5, 9&#125;, &#123;2, 3, 9&#125;, &#123;4&#125;, &#123;&#125;, &#123;&#125;, &#123;9&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&#125; ); cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; water drop1234567891011121314151617181920Input is a array represent how the height of water is at each position, the number of water will be poured, and the pour position. Print the land after all water are poured.Example: input land height int[]&#123;5,4,2,1,3,2,2,1,0,1,4,3&#125; The land is looks ike:+++ +++ + +++++ +++ ++++++++++ +++++++++++++++012345678901water quantity is 8 and pour at position 5. The land becomes:+++ +++www+ +++++w+++www++++++++++w+++++++++++++++012345678901 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;bool check(vector&lt;int&gt;&amp; nums, int index, int&amp; l, int&amp; r) &#123; int n = nums.size(); l = r = index; while (l &gt; 0 &amp;&amp; nums[l - 1] &lt;= nums[l]) l--; while (r &lt; n - 1 &amp;&amp; nums[r + 1] &lt;= nums[r]) r ++; return nums[index] == nums[l] &amp;&amp; nums[index] == nums[r];&#125;void helper(vector&lt;int&gt;&amp; nums, int index, int cap) &#123; int n = nums.size(); while (cap) &#123; int l, r; if (check(nums, index, l, r)) nums[index] ++, cap --; else &#123; if (l &gt;= 0) helper(nums, l, 1), cap --; if (cap &gt; 0 &amp;&amp; r &lt; n) helper(nums, r, 1), cap --; &#125; &#125;&#125;void print(vector&lt;int&gt;&amp; ret, vector&lt;int&gt;&amp; nums) &#123; int n = ret.size(); int m = 0; for (auto i : ret) m = max(m, i); vector&lt;vector&lt;char&gt;&gt; ans(m, vector&lt;char&gt;(n, ' ')); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; nums[i]; j++) &#123; ans[j][i] = '*'; &#125; for (int j = nums[i]; j &lt; ret[i]; j++) &#123; ans[j][i] = '+'; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m / 2; j++) &#123; swap(ans[j][i], ans[m - 1 - j][i]); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (auto j : ans[i]) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;int main() &#123; int index = 5, cap = 8; vector&lt;int&gt; nums(&#123;5,4,2,1,2,3,2,1,0,1,2,4&#125;); vector&lt;int&gt; ret(nums); helper(ret, index, cap); print(ret, nums); return 0;&#125; 从大文件中找中值 二叉树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct TreeNode &#123; int val; int overlap; int cnt; TreeNode* left; TreeNode* right; TreeNode(int x) : val(x), overlap(1), cnt(0), left(NULL), right(NULL) &#123;&#125;&#125;;void buildTree(TreeNode* &amp;cur, int num) &#123; if (!cur) cur = new TreeNode(num); else &#123; if (cur-&gt;val == num) cur-&gt;overlap ++; if (cur-&gt;val &gt; num) &#123; cur-&gt;cnt ++; buildTree(cur-&gt;left, num); &#125; if (cur-&gt;val &lt; num) &#123; buildTree(cur-&gt;right, num); &#125; &#125;&#125;int dfs(TreeNode* root, int index) &#123; if (root-&gt;cnt &gt;= index) return dfs(root-&gt;left, index); if (root-&gt;cnt + root-&gt;overlap &gt;= index) return root-&gt;val; return dfs(root-&gt;right, index - root-&gt;cnt - root-&gt;overlap);&#125;int helper(vector&lt;int&gt;&amp; nums) &#123; TreeNode* root = NULL; for (auto i : nums) &#123; buildTree(root, i); &#125; int n = nums.size(); return (dfs(root, (n + 1) / 2) + dfs(root, (n + 2) / 2)) / 2.0;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; 二分 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums, long long index) &#123; // 偶数会最多遍历文件64次，奇数遍历文件32次 long long left = INT_MIN, right = INT_MAX; int n = nums.size(); while (left &lt;= right) &#123; long long l = 0, r = 0, cnt = 0; long long mid = left + (right - left) / 2; for (auto i : nums) &#123; if (mid &gt; i) l++; else if (mid &lt; i) r++; else cnt ++; &#125; if (l &lt; index &amp;&amp; l + cnt &gt;= index) return mid; else if (l &gt;= index) right = mid - 1; else if (l + cnt &lt; index) left = mid + 1; &#125; return left;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; (helper(nums, (n + 1) / 2) + helper(nums, (n + 2) / 2)) / 2.0 &lt;&lt; endl; return 0;&#125; 字符串乘法包含正负号123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;string helper(string a, string b) &#123; int syn = 1; if (a[0] == '+' || a[0] == '-') &#123; if (a[0] == '-') syn ^= 1; a.erase(a.begin()); &#125; if (b[0] == '+' || b[0] == '-') &#123; if (b[0] == '-') syn ^= 1; b.erase(b.begin()); &#125; string ret((int)a.size() + (int)b.size(), '0'); reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); int len1 = a.size(); int len2 = b.size(); for (int i = 0; i &lt; len1; i++) &#123; int C = 0; int A = a[i] - '0'; for (int j = 0; j &lt; len2; j++) &#123; int B = b[j] - '0'; int temp = (ret[i + j] - '0') + A * B + C; ret[i + j] = '0' + (temp % 10); C = temp / 10; &#125; ret[i + len2] = ret[i + len2] + C; &#125; reverse(ret.begin(), ret.end()); while (!ret.empty() &amp;&amp; ret[0] == '0') ret.erase(ret.begin()); if (ret.empty()) return "0"; if (!syn) ret = "-" + ret; return ret;&#125;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; helper(a, b) &lt;&lt; endl; return 0;&#125; csv parser12345678Input: csvformat John,Smith,john.smith@gmail.com,Los Angeles,1 Jane,Roberts,janer@msn.com,&quot;San Francisco, CA&quot;,0&quot;Alexandra &quot;&quot;Alex&quot;&quot;&quot;,Menendez,alex.menendez@gmail.com,Miami,1 &quot;&quot;&quot;Alexandra Alex&quot;&quot;&quot; Output: escaped stringJohn|Smith|john.smith@gmail.com|Los Angeles|1 Jane|Roberts|janer@msn.com|San Francisco, CA|0Alexandra &quot;Alex&quot;|Menendez|alex.menendez@gmail.com|Miami|1 &quot;Alexandra Alex&quot; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;string helper2(string s, int&amp; index) &#123; string ret; int n = s.size(); while (index &lt; n &amp;&amp; (s[index] != '"' || (index + 1 &lt; n &amp;&amp; s[index + 1] == '"'))) &#123; string ans; while (index &lt; n &amp;&amp; s[index] != '"') ans.push_back(s[index++]); if (index + 1 &lt; n &amp;&amp; s[index + 1] == '"') &#123; index += 2; string temp; temp += '"'; while (index &lt; n &amp;&amp; s[index] != '"') temp.push_back(s[index++]); temp += '"'; index += 2; ans += temp; &#125; ret += ans; &#125; return ret;&#125;string helper1(string s, int&amp; index) &#123; int n = s.size(); string ret; while (index &lt; n &amp;&amp; s[index] != ',') &#123; string ans; while (index &lt; n &amp;&amp; s[index] != '"' &amp;&amp; s[index] != ',') ans.push_back(s[index ++]); if (index &lt; n &amp;&amp; s[index] == '"') &#123; index ++; string temp; temp += helper2(s, index); index ++; ans += temp; &#125; ret += ans; &#125; return ret;&#125;string helper(string s) &#123; int n = s.size(); int index = 0; vector&lt;string&gt; ans; while (index &lt; n) &#123; ans.push_back(helper1(s, index)); index ++; &#125; string ret; int len = ans.size(); for (int i = 0; i &lt; len - 1; i ++) &#123; ret += ans[i] + "|"; &#125; ret += ans.back(); return ret;&#125;int main() &#123; string s = "\"Alexandra \"\"Alex\"\"\",Menendez,alex.menendez@gmail.com,Miami,1 \"\"\"Alexandra Alex\"\"\""; cout &lt;&lt; s &lt;&lt; endl; cout &lt;&lt; helper(s) &lt;&lt; endl; return 0;&#125; boggle game从二维数组里找一条路径，包含字典数中最多的单词数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;string.h&gt;using namespace std;struct TrieNode &#123; bool isKey; TrieNode* child[26]; TrieNode() : isKey(false) &#123; memset(child, NULL, sizeof(child)); &#125;&#125;;TrieNode* buildTrie(vector&lt;string&gt;&amp; words) &#123; TrieNode* root = new TrieNode(); for (auto s : words) &#123; auto cur = root; for (auto i : s) &#123; int index = i - 'a'; if (!cur-&gt;child[index]) cur-&gt;child[index] = new TrieNode(); cur = cur-&gt;child[index]; &#125; cur-&gt;isKey = true; &#125; return root;&#125;void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; nums, int i, int j, TrieNode* cur, TrieNode* root, int cnt, int&amp; ret) &#123; int m = nums.size(), n = nums[0].size(); if (nums[i][j] == '\0') return; int index = nums[i][j] - 'a'; if (!cur-&gt;child[index]) return; cur = cur-&gt;child[index]; nums[i][j] = '\0'; if (cur-&gt;isKey) &#123; ret = max(ret, cnt + 1); &#125; int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; for (int k = 0; k &lt; 4; k++) &#123; int x = i + a[k], y = j + b[k]; if (x &lt; m &amp;&amp; x &gt;= 0 &amp;&amp; y &lt; n &amp;&amp; y &gt;= 0) &#123; dfs(nums, x, y, cur, root, cnt, ret); if (cur-&gt;isKey) &#123; dfs(nums, x, y, root, root, cnt + 1, ret); &#125; &#125; &#125; nums[i][j] = 'a' + index;&#125;int helper(vector&lt;vector&lt;char&gt;&gt;&amp; nums, vector&lt;string&gt;&amp; words) &#123; auto root = buildTrie(words); int m = nums.size(), n = nums[0].size(); int ret = 0; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; dfs(nums, i, j, root, root, 0, ret); &#125; &#125; return ret;&#125;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;char&gt;&gt; nums(m, vector&lt;char&gt;(n, '\0')); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; int t; cin &gt;&gt; t; vector&lt;string&gt; s; for (int i = 0; i &lt; t; i++) &#123; string temp; cin &gt;&gt; temp; s.push_back(temp); &#125; cout &lt;&lt; helper(nums, s) &lt;&lt; endl; return 0;&#125; Collatz Conjecture12345题目是给你公式，比如偶数的话除 2，奇数的话就变成 3*n+1，对于任何一个正数，数学猜想是最终他会变成 1。每变一步步数加 1，给一个上限，让找出范围内最长步数。比如 7，变换到 1 是如下顺序：7-&gt;22-&gt;11-&gt;34-&gt;17-&gt;52-&gt;26-&gt;13-&gt;40-&gt;20-&gt;10-&gt;5-&gt;16-&gt;8-&gt;4-&gt;2-&gt;1, 总共需要 17 步。 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;int helper(int n, unordered_map&lt;int, int&gt;&amp; m) &#123; if (n == 1) return 1; if (m.find(n) != m.end()) return m[n]; if (n &amp; 1) m[n] = 1 + helper(n * 3 + 1, m); else m[n] = 1 + helper(n / 2, m); return m[n];&#125;int main() &#123; int n; cin &gt;&gt; n; unordered_map&lt;int, int&gt; m; cout &lt;&lt; helper(n, m) &lt;&lt; endl; return 0;&#125; Queue - Array Implementation固定长度数组实现队列12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;using namespace std;class MyQueue &#123;private: int nums[10]; int len; int begin;public: MyQueue(): len(0), begin(0) &#123;&#125;; bool empty() &#123; return len == 0; &#125; void push(int val) &#123; if (len != 10) &#123; int index = (begin + len + 10) % 10; nums[index] = val; len++; &#125; else &#123; throw "Error"; &#125; &#125; void pop() &#123; if (!len) throw "Error"; len--; begin = (begin + 1 + 10) % 10; &#125; int front() &#123; if (!len) throw "Error"; else return nums[begin]; &#125; int back() &#123; if (!len) throw "Error"; else return nums[begin + len - 1 + 10] % 10; &#125;&#125;;int main() &#123; auto q = new MyQueue(); q-&gt;push(1); q-&gt;pop(); cout &lt;&lt; q-&gt;empty() &lt;&lt; endl; q-&gt;pop(); return 0;&#125; 文件系统1234567int(fs.create(&apos;/a&apos;, 1)) # Trueprint(fs.get(&apos;/a&apos;)) # 1print(fs.create(&apos;/a/b&apos;, 2)) # Trueprint(fs.create(&apos;/b/c&apos;, 3)) # Falseprint(fs.watch(&apos;/a/b&apos;, callback0))print(fs.watch(&apos;/a&apos;, callback1))print(fs.set(&apos;/a/b&apos;, 10)) # trigger 2 callbacks and True 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 没有实现watch#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;vector&gt;using namespace std;class Node &#123;public: int val; unordered_map&lt;string, Node*&gt; m; Node(int val) : val(val) &#123;&#125;; &#125;;class FileSystem &#123;private: Node* root; vector&lt;string&gt; convert(string s) &#123; vector&lt;string&gt; ret; int n = s.size(); string ans; for (auto i : s) &#123; if (i == '/') &#123; if (ans != "") ret.push_back(ans); ans = ""; &#125; else &#123; ans.push_back(i); &#125; &#125; ret.push_back(ans); return ret; &#125; public: FileSystem() : root(new Node(-1)) &#123;&#125;; int create(string s, int val) &#123; auto nums = convert(s); auto cur = root; int n = nums.size(); for (int i = 0; i &lt; n - 1; i++) &#123; if (cur-&gt;m.find(nums[i]) == cur-&gt;m.end()) return -1; cur = cur-&gt;m[nums[i]]; &#125; cur-&gt;m[nums.back()] = new Node(val); return 1; &#125; int get(string s) &#123; auto nums = convert(s); auto cur = root; int n = nums.size(); for (auto i : nums) &#123; if (cur-&gt;m.find(i) == cur-&gt;m.end()) return -1; cur = cur-&gt;m[i]; &#125; return cur-&gt;val; &#125; &#125;;int main() &#123; FileSystem* t = new FileSystem(); cout &lt;&lt; t-&gt;create("/a", 1) &lt;&lt; endl; cout &lt;&lt; t-&gt;get("/a") &lt;&lt; endl; cout &lt;&lt; t-&gt;create("/a/b", 2) &lt;&lt; endl; cout &lt;&lt; t-&gt;create("/b/b", 3) &lt;&lt; endl; return 0;&#125; 正则表达式1包含+,.,* 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool helper(string s, string p) &#123; int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false)); dp[0][0] = true; for (int i = 1; i &lt;= n; i++) &#123; dp[0][i] = p[i - 1] == '*' ? dp[0][i - 2] : false; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (p[j - 1] == '*') &#123; if (s[i - 1] != p[j - 2] &amp;&amp; p[j - 2] != '.') dp[i][j] = dp[i][j - 2]; else &#123; dp[i][j] = dp[i][j - 2] || dp[i - 1][j - 2] || dp[i - 1][j]; &#125; &#125; else if (p[j - 1] == '+') &#123; if (s[i - 1] == p[j - 2] || p[j - 2] == '.') &#123; dp[i][j] = dp[i - 1][j - 2] || dp[i - 1][j]; &#125; &#125; else &#123; dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '.'); &#125; &#125; &#125; return dp[m][n];&#125;int main() &#123; string s, p; cin &gt;&gt; s &gt;&gt; p; cout &lt;&lt; helper(s, p) &lt;&lt; endl; return 0;&#125; Maximum Number a Night You Can Accommodate1234567891011121314151617181920Leetcode 相似问题: Leetcode 198/213/337 House Robber I/II/IIIProvide a set of positive integers (an array of integers). Each integer represents number of nights user request on Airbnb.com. If you are a host, you need to design and implement an algorithm to find out the maximum number a night you can accommodate. The constrain is that you have to reserve at least one day between each request, so that you have time to clean the room. Given a set of numbers in an array which represent number of consecutive days of AirBnB reservation requested, as a host, pick the sequence which maximizes the number of days of occupancy, at the same time, leaving at least 1 day gap in between bookings for cleaning. Problem reduces to finding max-sum of non-consecutive array elements.// [5, 1, 1, 5] =&gt; 10The above array would represent an example booking period as follows -// Dec 1 – 5// Dec 5 – 6// Dec 6 – 7// Dec 7 - 12The answer would be to pick dec 1-5 (5 days) and then pick dec 7-12 for a total of 10 days of occupancy, at the same time, leaving at least 1 day gap for cleaning between reservations.Similarly,// [3, 6, 4] =&gt; 7// [4, 10, 3, 1, 5] =&gt; 15 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (!n) return 0; int ret = 0; vector&lt;int&gt; dp(n + 1, 0); if (n == 1) return nums[0]; if (n == 2) return max(nums[0], nums[1]); dp[1] = nums[0], dp[2] = nums[1]; for (int i = 2; i &lt;= n; i++) &#123; dp[i] = max(dp[i - 1], dp[i - 2] + nums[i - 1]); ret = max(ret, dp[i]); &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; Find Case Combinations of a String123Find all the combinations of a string in lowercase and uppercase. For example, string &quot;ab&quot; &gt;&gt;&gt; &quot;ab&quot;, &quot;Ab&quot;, &quot;aB&quot;, &quot;AB&quot;. So, you will have 2^n (n = number of chars in the string) output strings. The goal is for you to test each of these strings and see if it matchs a hidden string. 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;char convert(char a) &#123; if (a &lt;= 'Z' &amp;&amp; a &gt;= 'A') &#123; return 'a' + (a - 'A'); &#125; else &#123; return 'A' + (a - 'a'); &#125;&#125;void helper(string s, int index, vector&lt;string&gt;&amp; ret) &#123; int n = s.size(); if (index == n) &#123; ret.push_back(s); return; &#125; helper(s, index + 1, ret); s[index] = convert(s[index]); helper(s, index + 1, ret);&#125;int main() &#123; string s; cin &gt;&gt; s; vector&lt;string&gt; ret; helper(s, 0, ret); for (auto i : ret) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 两两编辑距离Find all words from a dictionary that are k edit distance away. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;climits&gt;#include &lt;math.h&gt;using namespace std;int editDistance(string a, string b) &#123; int m = a.size(), n = b.size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, INT_MAX)); for (int i = 0; i &lt;= m; i++) dp[i][0] = i; for (int i = 0; i &lt;= n; i++) dp[0][i] = i; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; dp[i][j] = min(dp[i - 1][j] + 1, dp[i][j - 1] + 1); dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + (a[i - 1] != b[j - 1])); &#125; &#125; return dp[m][n];&#125;vector&lt;pair&lt;string, string&gt;&gt; helper(vector&lt;string&gt;&amp; nums, int k) &#123; vector&lt;pair&lt;string, string&gt;&gt; ret; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; auto t = editDistance(nums[i], nums[j]); if (t &lt;= k &amp;&amp; !((k - t) &amp; 1)) ret.push_back(&#123;nums[i], nums[j]&#125;); &#125; &#125; return ret;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;string&gt; nums; for (int i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; nums.push_back(s); &#125; for (auto i : helper(nums, k)) &#123; cout &lt;&lt; i.first &lt;&lt; " " &lt;&lt; i.second &lt;&lt; endl; &#125; return 0;&#125;/*35 horse ros hoursehorse ros*/ Finding Ocean12345678910111213141516171819202122232425262728293031/*** Given: An array of strings where L indicates land and W indicates water,* and a coordinate marking a starting point in the middle of the ocean.** Challenge: Find and mark the ocean in the map by changing appropriate Ws to Os.* An ocean coordinate is defined to be the initial coordinate if a W, and* any coordinate directly adjacent to any other ocean coordinate.** void findOcean(String[] map, int row, int column);** String[] map = new String[]&#123;* &quot;WWWLLLW&quot;,* &quot;WWLLLWW&quot;,* &quot;WLLLLWW&quot;* &#125;;* printMap(map);** STDOUT:* WWWLLLW* WWLLLWW* WLLLLWW** findOcean(map, 0, 1);** printMap(map);** STDOUT:* OOOLLLW* OOLLLWW* OLLLLWW*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;vector&gt;using namespace std;vector&lt;string&gt; helper(vector&lt;string&gt;&amp; nums, int x, int y) &#123; int m = nums.size(), n = nums[0].size(); if (x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n); else return nums; vector&lt;pair&lt;int, int&gt;&gt; cur; cur.push_back(&#123;x, y&#125;); int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; while (true) &#123; vector&lt;pair&lt;int, int&gt;&gt; next; for (auto i : cur) &#123; nums[i.first][i.second] = 'O'; for (int j = 0; j &lt; 4; j++) &#123; int X = i.first + a[j], Y = i.second + b[j]; if (X &gt;= 0 &amp;&amp; X &lt; m &amp;&amp; Y &gt;= 0 &amp;&amp; Y &lt; n &amp;&amp; nums[X][Y] == 'W') &#123; next.push_back(&#123;X, Y&#125;); &#125; &#125; &#125; if (next.empty()) break; else cur = next; &#125; return nums; &#125;int main() &#123; // int m; // cin &gt;&gt; m; vector&lt;string&gt; nums(&#123;"WWWLLLW","WWLLLWW","WLLLLWW"&#125;); // for (int i = 0; i &lt; m; i++) &#123; // string temp; // cin &gt;&gt; temp; // nums.push_back(temp); // &#125; int x = 0, y = 1; for (auto i : helper(nums, x, y)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 最大的矩形二维数组中只有0和1，寻找数组中最大的1矩形123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139// stack#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;climits&gt;#include &lt;stack&gt;using namespace std;int helper(vector&lt;vector&lt;char&gt;&gt;&amp; nums) &#123; if (nums.empty() || nums[0].empty()) return 0; int m = nums.size(), n = nums[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; int ans = 0; for (int j = 0; j &lt; n; j++) &#123; if (nums[i][j] == '1') &#123; ans ++; dp[i][j] = ans; &#125; else &#123; ans = 0; &#125; &#125; &#125; int ret = 0; for (int i = 0; i &lt; n; i++) &#123; stack&lt;int&gt; s; for (int j = 0; j &lt; m; j++) &#123; int cnt = 0; while (!s.empty() &amp;&amp; s.top() &gt; dp[j][i]) &#123; cnt ++; ret = max(ret, cnt * s.top()); s.pop(); &#125; while (cnt &gt;= 0) &#123; cnt --; s.push(dp[j][i]); &#125; &#125; int cnt = 0; while (!s.empty()) &#123; cnt ++; ret = max(ret, cnt * s.top()); s.pop(); &#125; &#125; return ret;&#125;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;char&gt;&gt; nums(m, vector&lt;char&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125;/*6 6101101111111011011111010011111110111*/// dp#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;climits&gt;#include &lt;stack&gt;using namespace std;int helper(vector&lt;vector&lt;char&gt;&gt;&amp; nums) &#123; if (nums.empty() || nums[0].empty()) return 0; int m = nums.size(), n = nums[0].size(); int ret = 0; vector&lt;int&gt; height(n, 0), left(n, 0), right(n, n); for (int i = 0; i &lt; m; i++) &#123; int index_l = 0, index_r = n - 1; for (int j = 0; j &lt; n; j++) &#123; if (nums[i][j] == '1') height[j]++; else height[j] = 0; &#125; for (int j = 0; j &lt; n; j++) &#123; if (nums[i][j] == '1') left[j] = max(left[j], index_l); else left[j] = 0, index_l = j + 1; &#125; for (int j = n - 1; j &gt;= 0; j--) &#123; if (nums[i][j] == '1') right[j] = min(right[j], index_r); else right[j] = n, index_r = j - 1; &#125; for (int j = 0; j &lt; n; j++) &#123; ret = max(ret, (right[j] - left[j] + 1) * height[j]); &#125; &#125; return ret;&#125;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;char&gt;&gt; nums(m, vector&lt;char&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125;/*6 6101101111111011011111010011111110111*/ 规律打印123456789101112131415161718192021222324Input:1Output /\ /__\Input:2Output /\ /__\ /\ /\ /__\/__\Input:3Output /\ /__\ /\ /\ /__\/__\ /\ /\ /__\ /__\ /\ /\ /\ /\ /__\/__\/__\/__\ #include &lt;vector&gt; #include &lt;iostream&gt; using namespace std; vector&lt;string&gt; helper(int iter) { if (iter == 1) { return vector&lt;string&gt;({ " /\\ ", "/__\\" }); } vector&lt;string&gt; ans = helper(iter - 1); int m = ans.size(); int n = ans[0].size(); vector&lt;string&gt; ret(m * 2, string(n * 2, ' ')); for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { ret[i][j + n / 2] = ans[i][j]; ret[i + m][j] = ans[i][j]; ret[i + m][j + n] = ans[i][j]; } } return ret; } void print(vector&lt;string&gt; nums) { for (auto i : nums) { cout &lt;&lt; i &lt;&lt; endl; } } int main() { int n; cin &gt;&gt; n; print(helper(n)); return 0; }]]></content>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【面经】今日头条部分编程算法题]]></title>
    <url>%2F2019%2F03%2F14%2Finterview-coding-bytedance%2F</url>
    <content type="text"><![CDATA[本文收集2018年实验室实习面试部分编程面经以供复习 有序链表归并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode* next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;ListNode* helper(ListNode* A, ListNode* B) &#123; ListNode* ret = new ListNode(-1); ListNode* cur = ret; while (A &amp;&amp; B) &#123; if (A-&gt;val &lt; B-&gt;val) &#123; cur-&gt;next = A; A = A-&gt;next; &#125; else &#123; cur-&gt;next = B; B = B-&gt;next; &#125; cur = cur-&gt;next; &#125; while (A) &#123; cur-&gt;next = A; A = A-&gt;next; cur = cur-&gt;next; &#125; while (B) &#123; cur-&gt;next = B; B = B-&gt;next; cur = cur-&gt;next; &#125; return ret-&gt;next;&#125;int main() &#123; int n; cin &gt;&gt; n; auto A = new ListNode(-1); auto cur = A; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; cur-&gt;next = new ListNode(x); cur = cur-&gt;next; &#125; cin &gt;&gt; n; auto B = new ListNode(-1); cur = B; for (int i = 0; i &lt; n; i++) &#123; int y; cin &gt;&gt; y; cur-&gt;next = new ListNode(y); cur = cur-&gt;next; &#125; auto ret = helper(A-&gt;next, B-&gt;next); while (ret) &#123; cout &lt;&lt; ret-&gt;val &lt;&lt; " "; ret = ret-&gt;next; &#125; cout &lt;&lt; endl; return 0;&#125; 反转链表12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode* next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;ListNode* helper(ListNode* root) &#123; ListNode* ret = new ListNode(-1); while (root) &#123; auto temp = root-&gt;next; root-&gt;next = ret-&gt;next; ret-&gt;next = root; root = temp; &#125; return ret-&gt;next;&#125;int main() &#123; int n; cin &gt;&gt; n; ListNode* A = new ListNode(-1); ListNode* cur = A; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; cur-&gt;next = new ListNode(x); cur = cur-&gt;next; &#125; auto ret = helper(A-&gt;next); while (ret) &#123; cout &lt;&lt; ret-&gt;val &lt;&lt; " "; ret = ret-&gt;next; &#125; return 0;&#125; Partion and Reverse List123１-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7空间复杂度Ｏ(1)转换成：1-&gt;7-&gt;2-&gt;6-&gt;3-&gt;5-&gt;4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode* next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;ListNode* helper(ListNode* head) &#123; if (!head || !head-&gt;next) return head; ListNode* fast = head, *slow = head; while (fast &amp;&amp; fast-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; ListNode* head2 = slow-&gt;next; slow-&gt;next = NULL; ListNode* ret = new ListNode(-1); ListNode* cur = ret; while (head2) &#123; auto temp = head2-&gt;next; head2-&gt;next = cur-&gt;next; cur-&gt;next = head2; cur = cur-&gt;next; head2 = temp; &#125; head2 = ret-&gt;next; ret-&gt;next = NULL; cur = ret; while (head) &#123; cur-&gt;next = head; head = head-&gt;next; cur = cur-&gt;next; if (head2) &#123; cur-&gt;next = head2; head2 = head2-&gt;next; cur = cur-&gt;next; &#125; &#125; return ret-&gt;next;&#125;int main() &#123; int n; cin &gt;&gt; n; ListNode* head = new ListNode(-1); auto cur = head; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; cur-&gt;next = new ListNode(x); cur = cur-&gt;next; &#125; auto ret = helper(head-&gt;next); while (ret) &#123; cout &lt;&lt; ret-&gt;val &lt;&lt; " "; ret = ret-&gt;next; &#125; cout &lt;&lt; endl; return 0;&#125; 单链表排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 快排版本#include &lt;iostream&gt;using namespace std;struct ListNode &#123; int val; ListNode* next; ListNode(int x): val(x), next(NULL) &#123;&#125;&#125;;ListNode* helper(ListNode* head) &#123; if (!head || !head-&gt;next) return head; ListNode* A = new ListNode(-1); ListNode* B = new ListNode(-1); ListNode* cur_A = A, *cur_B = B; auto base = head; head = head-&gt;next; while (head) &#123; if (head-&gt;val &lt; base-&gt;val) &#123; cur_A-&gt;next = head; cur_A = head; &#125; else &#123; cur_B-&gt;next = head; cur_B = head; &#125; head = head-&gt;next; &#125; cur_A-&gt;next = NULL; cur_B-&gt;next = NULL; A-&gt;next = helper(A-&gt;next); B-&gt;next = helper(B-&gt;next); cur_A = A; while (cur_A-&gt;next) &#123; cur_A = cur_A-&gt;next; &#125; cur_A-&gt;next = base; base-&gt;next = B-&gt;next; return A-&gt;next;&#125;int main() &#123; int n; cin &gt;&gt; n; ListNode* head = new ListNode(-1); ListNode* cur = head; for (int i = 0; i &lt; n; i++) &#123; int x; cin &gt;&gt; x; cur-&gt;next = new ListNode(x); cur = cur-&gt;next; &#125; auto ret = helper(head-&gt;next); while (ret) &#123; cout &lt;&lt; ret-&gt;val &lt;&lt; " "; ret = ret-&gt;next; &#125; cout &lt;&lt; endl; return 0;&#125; 从一个数组里取m个数，能否和为n1234567891011121314151617181920212223242526272829303132333435// 类似于zeros and ones#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;bool helper(vector&lt;int&gt;&amp; nums, int m, int s) &#123; int n = nums.size(); if (n &lt; m) return false; vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(s + 1, false)); dp[0][0] = true; for (auto num : nums) &#123; for (int i = m; i &gt;= 1; i --) &#123; for (int j = s; j &gt;= num; j--) &#123; dp[i][j] = dp[i][j] || dp[i - 1][j - num]; &#125; &#125; &#125; return dp[m][s];&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; int m, s; cin &gt;&gt; m &gt;&gt; s; cout &lt;&lt; helper(nums, m, s) &lt;&lt; endl; return 0;&#125; 最大子串和求出数组中最大的子串和，并求出子串1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int ans = 0; vector&lt;int&gt; temp; vector&lt;int&gt; cur; int ret = INT_MIN; for (auto i : nums) &#123; ans += i; if (ans &lt; 0) &#123; ans = 0; cur = vector&lt;int&gt;(&#123;&#125;); &#125; else &#123; cur.push_back(i); if (ret &lt; ans) &#123; ret = ans; temp = cur; &#125; &#125; &#125; return temp;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 字符串拼接最大值一堆数字如123，324，56怎么拼接得到的值最大。 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;bool cmp(const int&amp; a, const int&amp; b) &#123; string x = to_string(a); string y = to_string(b); return x + y &gt; y + x;&#125;string helper(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return ""; sort(nums.begin(), nums.end(), cmp); string ret; for (auto i : nums) &#123; ret += to_string(i); &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; 左边最大值找出数组中每个数字左边部分（包括自己）最大的数字，然后返回结果数组 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;math.h&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; ret(n, -1); int limit = INT_MIN; for (int i = 0; i &lt; n; i++) &#123; limit = max(limit, nums[i]); ret[i] = limit; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; Search in Rotated Sorted Array123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); int left = 0, right = n - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; if (nums[mid] == nums[right]) &#123; right --; continue; &#125; if (nums[mid] &gt; nums[right]) &#123; if (nums[mid] &gt; target &amp;&amp; nums[right] &lt; target) &#123; right = mid - 1; &#125; else left = mid + 1; &#125; else &#123; if (nums[mid] &lt; target &amp;&amp; nums[right] &gt; target) &#123; left = mid + 1; &#125; else right = mid - 1; &#125; &#125; return -1;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; int target; cin &gt;&gt; target; cout &lt;&lt; helper(nums, target)&lt;&lt; endl; return 0;&#125; 数组变化一个数组，里面的元素全部初始为0，有以下两种操作： 指定一个元素+1 所有的*2 问到达一个数组目标值得最小操作步数。1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;#include &lt;climits&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums) &#123; int ret = 0; int limit = INT_MAX; for (auto i : nums) &#123; if (!i) continue; else &#123; limit = min(limit, i); ret ++; &#125; &#125; int ans = 1; while (ans * 2 &lt;= limit) ret ++, ans *= 2; for (auto i : nums) &#123; if (i) ret += i - ans; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; 顺时针打印数组1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int m = nums.size(), n = nums[0].size(); int dir = 0; int a[4] = &#123;0, 1, 0, -1&#125;, b[4] = &#123;1, 0, -1, 0&#125;; int x = 0, y = 0; vector&lt;int&gt; ret; while (ret.size() &lt; m * n) &#123; if (nums[x][y] != INT_MAX) &#123; ret.push_back(nums[x][y]); nums[x][y] = INT_MAX; &#125; int X = x + a[dir], Y = y + b[dir]; if (X &lt; m &amp;&amp; X &gt;= 0 &amp;&amp; Y &gt;= 0 &amp;&amp; Y &lt; n &amp;&amp; nums[X][Y] != INT_MAX) &#123; x = X, y = Y; &#125; else dir = (dir + 1) % 4; &#125; return ret;&#125;int main() &#123; int m, n; cin &gt;&gt; m &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; nums(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; K个升序数组归并123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;using namespace std;void heapfy(vector&lt;pair&lt;int, int&gt;&gt;&amp; ans, vector&lt;vector&lt;int&gt;&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; nums[ans[left].first][ans[left].second] &lt; nums[ans[smallest].first][ans[smallest].second]) &#123; smallest = left; &#125; if (right &lt; max &amp;&amp; nums[ans[right].first][ans[right].second] &lt; nums[ans[smallest].first][ans[smallest].second]) &#123; smallest = right; &#125; if (smallest != index) &#123; swap(ans[index], ans[smallest]); heapfy(ans, nums, smallest, max); &#125;&#125;vector&lt;int&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;pair&lt;int, int&gt;&gt; ans; for (int i = 0; i &lt; n; i++) &#123; if (!nums[i].empty()) ans.push_back(&#123;i, 0&#125;); &#125; vector&lt;int&gt; ret; while (!ans.empty()) &#123; ret.push_back(nums[ans[0].first][ans[0].second]); if (ans[0].second + 1 &lt; nums[ans[0].first].size()) &#123; ans[0].second ++; heapfy(ans, nums, 0, ans.size()); &#125; else &#123; ans[0] = ans.back(); ans.pop_back(); heapfy(ans, nums, 0, ans.size()); &#125; &#125; return ret;&#125;int main() &#123; int k; cin &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; nums; for (int i = 0; i &lt; k; i++) &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; ans(n, 0); for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; ans[j]; &#125; nums.push_back(ans); &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; 二叉树的最近公共祖先123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct TreeNode &#123; string val; TreeNode* left; TreeNode* right; TreeNode(string s) : val(s), left(NULL), right(NULL) &#123;&#125;&#125;;TreeNode* build(vector&lt;string&gt;&amp; nums, int&amp; index) &#123; int n = nums.size(); if (index &gt;= n) return NULL; auto val = nums[index++]; if (val == "#") return NULL; auto ret = new TreeNode(val); ret-&gt;left = build(nums, index); ret-&gt;right = build(nums, index); return ret;&#125;string helper1(TreeNode* root, string a, string b, bool&amp; m) &#123; if (!root) return ""; if (root-&gt;val == a || root-&gt;val == b) m = true; bool ml = false, mr = false; string l = helper1(root-&gt;left, a, b, ml); if (ml) &#123; if (m) return root-&gt;val; m = true; string r = helper1(root-&gt;right, a, b, mr); if (mr) return root-&gt;val; else return l; &#125; else &#123; string r = helper1(root-&gt;right, a, b, mr); if (m &amp;&amp; mr) return root-&gt;val; if (mr) &#123; m = mr; return r; &#125; else return ""; &#125;&#125;string helper(vector&lt;string&gt;&amp; nums, string a, string b) &#123; int index = 0; auto root = build(nums, index); bool m = false; return helper1(root, a, b, m);&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;string&gt; nums; for (auto i = 0; i &lt; n; i++) &#123; string s; cin &gt;&gt; s; nums.push_back(s); &#125; string a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; helper(nums, a, b) &lt;&lt; endl; return 0;&#125; 两个升序数组，查合并之后的总的中位数123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;typedef vector&lt;int&gt;::iterator Iter;int helper1(Iter a, int m, Iter b, int n, int k) &#123; if (!n) return a[k - 1]; if (!m) return b[k - 1]; if (k == 1) return min(a[0], b[0]); int l = min(k / 2, m); int r = min(k / 2, n); if (a[l - 1] &lt; b[r - 1]) &#123; return helper1(a + l, m - l, b, n, k - l); &#125; else &#123; return helper1(a, m, b + r, n - r, k - r); &#125;&#125;double helper(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) &#123; int n1 = A.size(); int n2 = B.size(); return ( helper1(A.begin(), n1, B.begin(), n2, (n1 + n2 + 1) / 2) + helper1(A.begin(), n1, B.begin(), n2, (n1 + n2 + 2) / 2) ) / 2.0;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; A(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; A[i]; &#125; vector&lt;int&gt; B(n, 0); cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; B[i]; &#125; cout &lt;&lt; helper(A, B) &lt;&lt; endl; return 0;&#125; LRU12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;list&gt;#include &lt;vector&gt;#include &lt;utility&gt;using namespace std;class LRU &#123;private: unordered_map&lt;int, pair&lt;int, list&lt;int&gt;::iterator&gt;&gt; nums; list&lt;int&gt; d; int cap; void touch(int key) &#123; if (nums.find(key) == nums.end()) return; d.erase(nums[key].second); nums.erase(key); &#125;public: LRU(int capacity): cap(capacity) &#123;&#125;; void add(int key, int val) &#123; touch(key); d.push_front(key); nums[key] = &#123;val, d.begin()&#125;; &#125; int get(int key) &#123; if (nums.find(key) == nums.end()) return -1; int ret = nums[key].first; touch(key); d.push_front(key); nums[key] = &#123;ret, d.begin()&#125;; return ret; &#125;&#125;;int main() &#123; auto cache = new LRU(2); cache-&gt;add(1, 1); cache-&gt;add(2, 2); cout &lt;&lt; cache-&gt;get(1) &lt;&lt; endl; // returns 1 return 0;&#125; 带重复的字符串全排列12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt; nums, int index) &#123; int n = nums.size(); if (n == index) ret.push_back(nums); for (int i = index; i &lt; n; i++) &#123; if (i != index &amp;&amp; nums[i] == nums[index]) continue; swap(nums[index], nums[i]); dfs(ret, nums, index + 1); &#125;&#125;vector&lt;vector&lt;int&gt;&gt; helper(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; sort(nums.begin(), nums.end()); dfs(ret, nums, 0); return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 自然数排列0123456791011121314.. 自然数这样顺次排下去，给一个index，找出对应的数字是什么1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;char helper(int n) &#123; if (!n) return '0'; if (n &lt; 10) return '1' + (n - 1); n -= 9; int cnt = 1; while (n &gt; (pow(10, cnt + 1) - pow(10, cnt)) * (cnt + 1)) &#123; n -= (pow(10, cnt + 1) - pow(10, cnt)) * (cnt + 1); cnt ++; &#125; int ans = pow(10, cnt) + (n - 1) / (cnt + 1); return to_string(ans)[(n - 1) % (cnt + 1)];&#125;int main() &#123; for (int i = 0; i &lt; 200; i++) &#123; cout &lt;&lt; helper(i); &#125; cout &lt;&lt; endl; return 0;&#125; House Robber IIILeetcode 3371234567891011121314class Solution &#123;public: int helper(TreeNode* root, int&amp; l, int&amp; r) &#123; if (!root) return 0; int ll = 0, lr = 0, rl = 0, rr = 0; l = max(0, helper(root-&gt;left, ll, lr)); r = max(0, helper(root-&gt;right, rl, rr)); return max(l + r, root-&gt;val + ll + lr + rl + rr); &#125; int rob(TreeNode* root) &#123; int l, r; return helper(root, l, r); &#125;&#125;; Minimum Window SubstringLeetcode 761234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: string minWindow(string s, string t) &#123; if (t.empty()) return ""; unordered_map&lt;char, int&gt; m; for (auto i : t) &#123; m[i] ++; &#125; int ans = m.size(); int n = s.size(); int l = 0, r = 0; int len = INT_MAX; string ret; while (r &lt;= n &amp;&amp; l &lt;= r) &#123; if (ans &gt; 0 &amp;&amp; r &lt; n) &#123; auto key = s[r++]; if (m.find(key) != m.end()) &#123; m[key] --; if (m[key] == 0) ans--; &#125; &#125; else &#123; auto key = s[l++]; if (m.find(key) != m.end()) &#123; m[key] ++; if (m[key] == 1) ans ++; &#125; &#125; if (!ans &amp;&amp; r - l &lt; len) &#123; len = r - l; ret = s.substr(l, len); &#125; &#125; return ret; &#125;&#125;; 变色龙123456789101112131415161718192021222324Description 在一个美丽的小岛上住着一群变色龙：其中有X只变色龙是红色的，Y只变色龙是绿色的，Z只变色龙是蓝色的。 每个时刻会有两只不同颜色的变色龙相遇，相遇后他们会同时变成第三种颜色。比如，如果一只红色的变色龙和一只蓝色的变色龙相遇了，他们就会同时变成绿色的变色龙，如果一只绿色的变色龙和一只蓝色的变色龙相遇了，他们就会同时变成红色的变色龙，等等。 那么最后是否有可能所有的变色龙都是同一种颜色呢？ Input 输入的第一行包含一个整数T (1 &lt;= T &lt;= 100)，表示接下来一共有T组测试数据。 每组数据占一行，包含三个整数X, Y, Z (1 &lt;= X, Y, Z &lt;= 109)，含义同上。 Output 对于每组测试数据，如果最后有可能所有的变色龙都是同一种颜色，用一行输出“Yes”（不包括引号），否则输出“No”（不包括引号）。 Sample Input41 1 11 2 37 1 23 7 5Sample OutputYesNoYesNoHINT 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;string helper(int x, int y, int z) &#123; if (x == y || y == z) return "YES"; if (abs(x - y) % 3 == 0 || abs(x - z) % 3 == 0 || abs(y - z) % 3 == 0) return "YES"; else return "NO";&#125;int main() &#123; int n; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; int x, y, z; cin &gt;&gt; x &gt;&gt; y &gt;&gt; z; cout &lt;&lt; helper(x, y, z) &lt;&lt; endl; &#125; return 0;&#125; 平方根123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;math.h&gt;#include &lt;climits&gt;using namespace std;int helper1(int n) &#123; int ret = n; while (ret * ret &gt; n) &#123; ret = (ret + n / ret) / 2; &#125; return ret;&#125;int helper2(int n) &#123; int left = 1, right = n; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (mid + 1 &gt; n / (mid + 1) &amp;&amp; mid &lt;= n / mid) return mid; if (mid &lt; n / mid) left = mid + 1; else right = mid - 1; &#125; return -1;&#125;int main() &#123; int n; cin &gt;&gt; n; cout &lt;&lt; helper1(n) &lt;&lt; endl; cout &lt;&lt; helper2(n) &lt;&lt; endl; return 0;&#125; 短网址系统设计一个短网址系统？短网址生成策略？短网址和长网址的映射关系如何表示？存网址的数据库表太大了怎么办？Sharding后如何分别以长网址或短网址为主key搜索？你觉得这个系统追求的是时间效率还是空间节省？那冗余存储的牺牲值不值得？ 1// 代码待补充 大文件判断重复判断两个大文件，4g内存，判断两个文件里想同的url123456/*三种思路供参考：1. 运用bitmap，类似于布隆过滤器2. 运用hash值，类似于布隆过滤器，有可能出现判断不准确的情况3. 分桶成小文件，然后查询过程中扫每个文件*/ 无向图的最小环1234输入：n个点，t条边输出：最短环的路径 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;unordered_set&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, int n) &#123; vector&lt;unordered_set&lt;int&gt;&gt; adj(n); for (auto i : nums) &#123; if (i.first == i.second) continue; adj[i.first].insert(i.second); adj[i.second].insert(i.first); &#125; vector&lt;vector&lt;int&gt;&gt; cur; cur.push_back(&#123;0&#125;); while (true) &#123; vector&lt;vector&lt;int&gt;&gt; next; for (auto i : cur) &#123; for (auto j : adj[i.back()]) &#123; if (i.size() &gt; 2 &amp;&amp; j == 0) &#123; i.push_back(0); return i; &#125; if (find(i.begin(), i.end(), j) == i.end()) &#123; auto temp = i; temp.push_back(j); next.push_back(temp); &#125; &#125; &#125; if (next.empty()) break; cur = next; &#125; return vector&lt;int&gt;();&#125;int main() &#123; int n; cin &gt;&gt; n; int t; cin &gt;&gt; t; vector&lt;pair&lt;int, int&gt;&gt; nums; for (int i = 0; i &lt; t; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; nums.push_back(&#123;x, y&#125;); &#125; for (auto i : helper(nums, n)) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125;/*6 70 11 21 32 32 44 55 0*/]]></content>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 周赛模拟 【2】]]></title>
    <url>%2F2018%2F10%2F25%2FLeetcode-virtual-contest-2%2F</url>
    <content type="text"><![CDATA[Weekly Contest 83 参赛地址 830. Positions of Large Groups [AC] Leetcode 830 In a string S of lowercase letters, these letters form consecutive groups of the same character. For example, a string like S = “abbxxxxzyy” has the groups “a”, “bb”, “xxxx”, “z” and “yy”. Call a group large if it has 3 or more characters. We would like the starting and ending positions of every large group. The final answer should be in lexicographic order. Example 1:123Input: &quot;abbxxxxzzy&quot;Output: [[3,6]]Explanation: &quot;xxxx&quot; is the single large group with starting 3 and ending positions 6. Example 2:123Input: &quot;abc&quot;Output: []Explanation: We have &quot;a&quot;,&quot;b&quot; and &quot;c&quot; but no large group. Example 3:12Input: &quot;abcdddeeeeaabbbcd&quot;Output: [[3,5],[6,9],[12,14]] Note: 1 &lt;= S.length &lt;= 1000 1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; largeGroupPositions(string S) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int n = S.size(); if (!n) return ret; for (int i = 0; i &lt; n; i++) &#123; int cnt = 1; while (i + cnt &lt; n &amp;&amp; S[i] == S[i + cnt]) cnt ++; if (cnt &lt;= 2) continue; vector&lt;int&gt; ans(&#123;i, i + cnt - 1&#125;); ret.push_back(ans); i += cnt - 1; &#125; return ret; &#125;&#125;; 831. Masking Personal Information [AC] Leetcode 831 We are given a personal information string S, which may represent either an email address or a phone number. We would like to mask this personal information according to the following rules: Email address: We define a name to be a string of length ≥ 2 consisting of only lowercase letters a-z or uppercase letters A-Z. An email address starts with a name, followed by the symbol ‘@’, followed by a name, followed by the dot ‘.’ and followed by a name. All email addresses are guaranteed to be valid and in the format of “name1@name2.name3“. To mask an email, all names must be converted to lowercase and all letters between the first and last letter of the first name must be replaced by 5 asterisks ‘*’. Phone number: A phone number is a string consisting of only the digits 0-9 or the characters from the set {‘+’, ‘-‘, ‘(‘, ‘)’, ‘ ‘}. You may assume a phone number contains 10 to 13 digits. The last 10 digits make up the local number, while the digits before those make up the country code. Note that the country code is optional. We want to expose only the last 4 digits and mask all other digits. The local number should be formatted and masked as “--1111”, where 1 represents the exposed digits. To mask a phone number with country code like “+111 111 111 1111”, we write it in the form “+--*-1111”. The ‘+’ sign and the first ‘-‘ sign before the local number should only exist if there is a country code. For example, a 12 digit phone number mask should start with “+-“. Note that extraneous characters like “(“, “)”, “ “, as well as extra dashes or plus signs not part of the above formatting scheme should be removed. Return the correct “mask” of the information provided. Example 1:12345Input: &quot;LeetCode@LeetCode.com&quot;Output: &quot;l*****e@leetcode.com&quot;Explanation: All names are converted to lowercase, and the letters between the first and last letter of the first name is replaced by 5 asterisks. Therefore, &quot;leetcode&quot; -&gt; &quot;l*****e&quot;. Example 2:1234Input: &quot;AB@qq.com&quot;Output: &quot;a*****b@qq.com&quot;Explanation: There must be 5 asterisks between the first and last letter of the first name &quot;ab&quot;. Therefore, &quot;ab&quot; -&gt; &quot;a*****b&quot;. Example 3:123Input: &quot;1(234)567-890&quot;Output: &quot;***-***-7890&quot;Explanation: 10 digits in the phone number, which means all digits make up the local number. Example 4:123Input: &quot;86-(10)12345678&quot;Output: &quot;+**-***-***-5678&quot;Explanation: 12 digits, 2 digits for country code and 10 digits for local number. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: bool helper(string s, int&amp; cnt) &#123; bool ret = false; for (auto i : s) &#123; if (i == '@') ret = true; if (i &gt;= '0' &amp;&amp; i &lt;= '9') cnt ++; &#125; return ret; &#125; string maskPII(string S) &#123; int cnt = 0; if (!helper(S, cnt)) &#123; string ret; string ans; int index = S.size() - 1; int c = 0; while (c &lt; 4) &#123; if (S[index] &lt;= '9' &amp;&amp; S[index] &gt;= '0') &#123; ans = S[index] + ans; c ++; &#125; index --; &#125; if (cnt &gt; 10) &#123; ret = "+"; for (int i = 0; i &lt; cnt - 10; i++) ret += "*"; ret += "-***-***-"; &#125; else ret = "***-***-"; ret += ans; return ret; &#125; else &#123; for (auto &amp;i : S) &#123; if (i &gt;= 'A' &amp;&amp; i &lt;= 'Z') i = 'a' + (i - 'A'); &#125; string ret; ret.push_back(S[0]); ret += "*****"; int index = 1; while (S[index + 1] != '@') index ++; while (index &lt; S.size()) ret += S[index ++]; return ret; &#125; &#125;&#125;; 829. Consecutive Numbers Sum [AC] Leetcode 829 Given a positive integer N, how many ways can we write it as a sum of consecutive positive integers? Example 1:123Input: 5Output: 2Explanation: 5 = 5 = 2 + 3 Example 2:123Input: 9Output: 3Explanation: 9 = 9 = 4 + 5 = 2 + 3 + 4 Example 3:123Input: 15Output: 4Explanation: 15 = 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5 12345678910class Solution &#123;public: int consecutiveNumbersSum(int N) &#123; int ret = 1; for (int i = 2; 2 * N - i * (i - 1) &gt; 0; i++) &#123; if ((2 * N - i * (i - 1)) % (2 * i) == 0) ret ++; &#125; return ret; &#125;&#125;; 828. Unique Letter String [Unsolved] Leetcode 828 A character is unique in string S if it occurs exactly once in it. For example, in string S = “LETTER”, the only unique characters are “L” and “R”. Let’s define UNIQ(S) as the number of unique characters in string S. For example, UNIQ(“LETTER”) = 2. Given a string S with only uppercases, calculate the sum of UNIQ(substring) over all non-empty substrings of S. If there are two or more equal substrings at different positions in S, we consider them different. Since the answer can be very large, return the answer modulo 10 ^ 9 + 7. Example 1:12345Input: &quot;ABC&quot;Output: 10Explanation: All possible substrings are: &quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;AB&quot;,&quot;BC&quot; and &quot;ABC&quot;.Evey substring is composed with only unique letters.Sum of lengths of all substring is 1 + 1 + 1 + 2 + 2 + 3 = 10 Example 2:123Input: &quot;ABA&quot;Output: 8Explanation: The same as example 1, except uni(&quot;ABA&quot;) = 1. 123456789101112131415class Solution &#123;public: int uniqueLetterString(string S) &#123; long long ret = 0; int n = S.size(); for (int i = 0; i &lt; n; i++) &#123; int l = i - 1, r = i + 1; while (l &gt;= 0 &amp;&amp; S[l] != S[i]) l--; while (r &lt; n &amp;&amp; S[r] != S[i]) r ++; ret += (long long)(r - i) * (i - l); // 相乘表示从l-&gt;i和i-&gt;r所有子串的组合 &#125; return ret % 1000000007; &#125;&#125;; Weekly Contest 82824. Goat Latin [AC] Leetcode 824A sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel (a, e, i, o, or u), append “ma” to the end of the word.For example, the word ‘apple’ becomes ‘applema’. If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add “ma”.For example, the word “goat” becomes “oatgma”. Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1.For example, the first word gets “a” added to the end, the second word gets “aa” added to the end and so on.Return the final sentence representing the conversion from S to Goat Latin. Example 1:12Input: &quot;I speak Goat Latin&quot;Output: &quot;Imaa peaksmaaa oatGmaaaa atinLmaaaaa&quot; Example 2:12Input: &quot;The quick brown fox jumped over the lazy dog&quot;Output: &quot;heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa&quot; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: bool helper(char c) &#123; if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') return true; else return false; &#125; string toGoatLatin(string S) &#123; string ret; string ans; int cnt = 1; for (auto i : S) &#123; if (i != ' ') &#123; ans.push_back(i); &#125; else &#123; if (ans.empty()) ans += " "; else &#123; if (helper(ans[0])) &#123; ans += "ma"; &#125; else &#123; char t = ans[0]; ans.erase(ans.begin()); ans.push_back(t); ans += "ma"; &#125; for (int i = 0; i &lt; cnt; i++) &#123; ans += "a"; &#125; cnt ++; &#125; ret += " " + ans; ans = ""; &#125; &#125; if (helper(ans[0])) &#123; ans += "ma"; &#125; else &#123; char t = ans[0]; ans.erase(ans.begin()); ans.push_back(t); ans += "ma"; &#125; for (int i = 0; i &lt; cnt; i++) &#123; ans += "a"; &#125; ret += " " + ans; ans = ""; ret.erase(ret.begin()); return ret; &#125;&#125;; 825. Friends Of Appropriate Ages [AC] Leetcode 825 Some people will make friend requests. The list of their ages is given and ages[i] is the age of the ith person. Person A will NOT friend request person B (B != A) if any of the following conditions are true: age[B] &lt;= 0.5 * age[A] + 7age[B] &gt; age[A]age[B] &gt; 100 &amp;&amp; age[A] &lt; 100Otherwise, A will friend request B. Note that if A requests B, B does not necessarily request A. Also, people will not friend request themselves. How many total friend requests are made? Example 1:123Input: [16,16]Output: 2Explanation: 2 people friend request each other. Example 2:123Input: [16,17,18]Output: 2Explanation: Friend requests are made 17 -&gt; 16, 18 -&gt; 17. Example 3:123Input: [20,30,100,110,120]Output: Explanation: Friend requests are made 110 -&gt; 100, 120 -&gt; 110, 120 -&gt; 100. 12345678910111213141516171819202122class Solution &#123;public: bool helper(int a, int b) &#123; if ((2 * b &lt;= a + 14) || b &gt; a || (b &gt; 100 &amp;&amp; a &lt; 100)) return false; else return true; &#125; int numFriendRequests(vector&lt;int&gt;&amp; ages) &#123; int ret = 0; int n = ages.size(); sort(ages.begin(), ages.end()); for (int i = 0; i &lt; n; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (helper(ages[j], ages[i])) &#123; cout &lt;&lt; ages[j] &lt;&lt; ages[i] &lt;&lt; endl; ret ++; &#125; &#125; &#125; if (ret &amp;&amp; n == 2) return 2; return ret; &#125;&#125;; 826. Most Profit Assigning Work [AC] Leetcode 826 We have jobs: difficulty[i] is the difficulty of the ith job, and profit[i] is the profit of the ith job. Now we have some workers. worker[i] is the ability of the ith worker, which means that this worker can only complete a job with difficulty at most worker[i]. Every worker can be assigned at most one job, but one job can be completed multiple times. For example, if 3 people attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, his profit is $0. What is the most profit we can make? Example 1:123Input: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]Output: 100 Explanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get profit of [20,20,30,30] seperately. 1234567891011121314151617181920212223class Solution &#123;public: int maxProfitAssignment(vector&lt;int&gt;&amp; difficulty, vector&lt;int&gt;&amp; profit, vector&lt;int&gt;&amp; worker) &#123; int n = worker.size(), m = profit.size(); vector&lt;pair&lt;int, int&gt;&gt; nums; if (!n || !m) return 0; for (int i = 0; i &lt; m; i++) &#123; nums.push_back(make_pair(difficulty[i], profit[i])); &#125; sort(nums.begin(), nums.end()); int ret = 0; for (int i = 0; i &lt; n; i++) &#123; int ans = 0; for (int j = 0; j &lt; m; j++) &#123; if (worker[i] &lt; nums[j].first) break; ans = max(ans, nums[j].second); &#125; ret += ans; &#125; return ret; &#125;&#125;; 827. Making A Large Island [Unsolved] Leetcode 827 In a 2D grid of 0s and 1s, we change at most one 0 to a 1. After, what is the size of the largest island? (An island is a 4-directionally connected group of 1s). Example 1: Input: [[1, 0], [0, 1]]Output: 3Explanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.Example 2: Input: [[1, 1], [1, 0]]Output: 4Explanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.Example 3: Input: [[1, 1], [1, 1]]Output: 4Explanation: Can’t change any 0 to 1, only one island with area = 4. 本来思路是并查集加BFS，但是由于并查集写的代码太长导致时间不够用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Solution &#123;public: int N; int largestIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; N = grid.size(); //DFS every island and give it an index of island int index = 2, res = 0; unordered_map &lt;int, int&gt;area; for (int x = 0; x &lt; N; ++x) &#123; for (int y = 0; y &lt; N; ++y) &#123; if (grid[x][y] == 1) &#123; area[index] = dfs(grid, x, y, index); res = max(res, area[index++]); &#125; &#125; &#125; //traverse every 0 cell and count biggest island it can conntect for (int x = 0; x &lt; N; ++x) for (int y = 0; y &lt; N; ++y) if (grid[x][y] == 0) &#123; unordered_set&lt;int&gt; seen = &#123;&#125;; int cur = 1; for (auto p : move(x, y)) &#123; index = grid[p.first][p.second]; if (index &gt; 1 &amp;&amp; seen.count(index) == 0) &#123; seen.insert(index); cur += area[index]; &#125; &#125; res = max(res, cur); &#125; return res; &#125; vector&lt;pair&lt;int, int&gt;&gt; move(int x, int y) &#123; vector&lt;pair&lt;int, int&gt;&gt; res; for (auto p : vector&lt;vector&lt;int&gt;&gt; &#123;&#123;1, 0&#125;, &#123;-1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;) &#123; if (valid(x + p[0], y + p[1])) res.push_back(make_pair(x + p[0], y + p[1])); &#125; return res; &#125; int valid(int x, int y) &#123; return 0 &lt;= x &amp;&amp; x &lt; N &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; N; &#125; int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int index) &#123; int area = 0; grid[x][y] = index; for (auto p : move(x, y)) if (grid[p.first][p.second] == 1) area += dfs(grid, p.first, p.second, index); return area + 1; &#125;&#125;; Weekly Contest 81821. Shortest Distance to a Character [AC] Leetcode 821Given a string S and a character C, return an array of integers representing the shortest distance from the character C in the string. Example 1:12Input: S = &quot;loveleetcode&quot;, C = &apos;e&apos;Output: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; shortestToChar(string S, char C) &#123; int n = S.size(); vector&lt;int&gt; res(n, n); int pos = -n; for (int i = 0; i &lt; n; ++i) &#123; if (S[i] == C) pos = i; res[i] = min(res[i], abs(i - pos)); &#125; for (int i = n - 1; i &gt;= 0; --i) &#123; if (S[i] == C) pos = i; res[i] = min(res[i], abs(i - pos)); &#125; return res; &#125;&#125;; 822. 822. Card Flipping Game [AC] Leetcode 821 On a table are N cards, with a positive integer printed on the front and back of each card (possibly different). We flip any number of cards, and after we choose one card. If the number X on the back of the chosen card is not on the front of any card, then this number X is good. What is the smallest number that is good? If no number is good, output 0. Here, fronts[i] and backs[i] represent the number on the front and back of card i. A flip swaps the front and back numbers, so the value on the front is now on the back and vice versa. Example:1234Input: fronts = [1,2,4,4,7], backs = [1,3,4,1,3]Output: 2Explanation: If we flip the second card, the fronts are [1,3,4,4,7] and the backs are [1,2,4,1,3].We choose the second card, which has number 2 on the back, and it isn&apos;t on the front of any card, so 2 is good. 123456789101112131415161718class Solution &#123;public: int flipgame(vector&lt;int&gt;&amp; fronts, vector&lt;int&gt;&amp; backs) &#123; unordered_set&lt;int&gt; same; int n = fronts.size(); for (int i = 0; i &lt; n; i++) &#123; if (fronts[i] == backs[i]) same.insert(fronts[i]); &#125; int ret = INT_MAX; for (auto i : fronts) &#123; if (same.find(i) == same.end()) ret = min(ret, i); &#125; for (auto i : backs) &#123; if (same.find(i) == same.end()) ret = min(ret, i); &#125; return ret == INT_MAX ? 0 : ret; &#125;&#125;; 820. Short Encoding of Words [AC] Leetcode 820Given a list of words, we may encode it by writing a reference string S and a list of indexes A. For example, if the list of words is [“time”, “me”, “bell”], we can write it as S = “time#bell#” and indexes = [0, 2, 5]. Then for each index, we will recover the word by reading from the reference string from that index until we reach a “#” character. What is the length of the shortest reference string S possible that encodes the given words? Example:123Input: words = [&quot;time&quot;, &quot;me&quot;, &quot;bell&quot;]Output: 10Explanation: S = &quot;time#bell#&quot; and indexes = [0, 2, 5]. 1234567891011121314class Solution &#123;public: int minimumLengthEncoding(vector&lt;string&gt;&amp; words) &#123; unordered_set&lt;string&gt; s(words.begin(), words.end()); for (auto w : words) &#123; for (int i = 1; i &lt; w.size(); i++) &#123; s.erase(w.substr(i)); &#125; &#125; int ret = 0; for (auto i : s) ret += i.size() + 1; return ret; &#125;&#125;; 823. Binary Trees With Factors [AC] Leetcode 823 Given an array of unique integers, each integer is strictly greater than 1. We make a binary tree using these integers and each number may be used for any number of times. Each non-leaf node’s value should be equal to the product of the values of it’s children. How many binary trees can we make? Return the answer modulo 10 ** 9 + 7. Example 1:123Input: A = [2, 4]Output: 3Explanation: We can make these trees: [2], [4], [4, 2, 2] Example 2:123Input: A = [2, 4, 5, 10]Output: 7Explanation: We can make these trees: [2], [4], [5], [10], [4, 2, 2], [10, 2, 5], [10, 5, 2]. 1234567891011121314151617181920212223class Solution &#123;public: long MOD = 1000000007; int numFactoredBinaryTrees(vector&lt;int&gt;&amp; A) &#123; sort(A.begin(), A.end()); unordered_map&lt;int, long&gt; m; for (int i = 0; i &lt; A.size(); i++) &#123; int x = A[i]; m[x] = 1; for (int j = 0; j &lt; i; j++) &#123; int y = A[j]; if (x % y == 0 &amp;&amp; m.find(x / y) != m.end()) &#123; m[x] = (m[x] + (m[y] * m[x / y]) % MOD) % MOD; &#125; &#125; &#125; long ret = 0; for (auto i : m) &#123; ret = (ret + i.second) % MOD; &#125; return ret; &#125;&#125;; Weekly Contest 80 Leetcode 80 819. Most Common Word [AC] Leetcode 819 Given a paragraph and a list of banned words, return the most frequent word that is not in the list of banned words. It is guaranteed there is at least one word that isn’t banned, and that the answer is unique. Words in the list of banned words are given in lowercase, and free of punctuation. Words in the paragraph are not case sensitive. The answer is in lowercase. Example:12345678910Input: paragraph = &quot;Bob hit a ball, the hit BALL flew far after it was hit.&quot;banned = [&quot;hit&quot;]Output: &quot;ball&quot;Explanation: &quot;hit&quot; occurs 3 times, but it is a banned word.&quot;ball&quot; occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. Note that words in the paragraph are not case sensitive,that punctuation is ignored (even if adjacent to words, such as &quot;ball,&quot;), and that &quot;hit&quot; isn&apos;t the answer even though it occurs more because it is banned. 123456789101112131415161718192021222324252627282930313233343536373839404142class Solution &#123;public: vector&lt;string&gt; helper(string s) &#123; vector&lt;string&gt; ret; string ans; for (auto i : s) &#123; if (i == ' ' || ispunct(i)) &#123; if (ans != "") &#123; ret.push_back(ans); &#125; ans = ""; &#125; else &#123; if (i &lt;= 'Z' &amp;&amp; i &gt;= 'A') &#123; i = 'a' + (i - 'A'); &#125; ans.push_back(i); &#125; &#125; if (ans != "") ret.push_back(ans); return ret; &#125; string mostCommonWord(string paragraph, vector&lt;string&gt;&amp; banned) &#123; unordered_set&lt;string&gt; m(banned.begin(), banned.end()); unordered_map&lt;string, int&gt; cnt; for (auto s : helper(paragraph)) &#123; if (m.find(s) == m.end()) &#123; cout &lt;&lt; s &lt;&lt; endl; cnt[s] ++; &#125; &#125; string ret; int ans = 0; for (auto i : cnt) &#123; if (i.second &gt; ans) &#123; ans = i.second; ret = i.first; &#125; &#125; return ret; &#125;&#125;; 817. Linked List Components [AC] Leetcode 817 We are given head, the head node of a linked list containing unique integer values. We are also given the list G, a subset of the values in the linked list. Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list. Example 1:123456Input: head: 0-&gt;1-&gt;2-&gt;3G = [0, 1, 3]Output: 2Explanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components. Example 2:123456Input: head: 0-&gt;1-&gt;2-&gt;3-&gt;4G = [0, 3, 1, 4]Output: 2Explanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components. 1234567891011121314151617181920212223242526272829303132333435/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int numComponents(ListNode* head, vector&lt;int&gt;&amp; G) &#123; if (!head) return 0; unordered_set&lt;int&gt; m(G.begin(), G.end()); int ret = 0; int check = 0; ListNode* cur = head; while (true) &#123; int x = cur-&gt;val; if (m.find(x) != m.end()) &#123; check = 1; &#125; else &#123; if (check) &#123; ret += 1, check = 0; &#125; &#125; cur = cur-&gt;next; if (!cur) &#123; if (check) ret += 1; break; &#125; &#125; return ret; &#125;&#125;; 816. Ambiguous Coordinates [AC] Leetcode 816 We had some 2-dimensional coordinates, like “(1, 3)” or “(2, 0.5)”. Then, we removed all commas, decimal points, and spaces, and ended up with the string S. Return a list of strings representing all possibilities for what our original coordinates could have been. Our original representation never had extraneous zeroes, so we never started with numbers like “00”, “0.0”, “0.00”, “1.0”, “001”, “00.01”, or any other number that can be represented with less digits. Also, a decimal point within a number never occurs without at least one digit occuring before it, so we never started with numbers like “.1”. The final answer list can be returned in any order. Also note that all coordinates in the final answer have exactly one space between them (occurring after the comma.)12345678910111213141516Example 1:Input: &quot;(123)&quot;Output: [&quot;(1, 23)&quot;, &quot;(12, 3)&quot;, &quot;(1.2, 3)&quot;, &quot;(1, 2.3)&quot;]Example 2:Input: &quot;(00011)&quot;Output: [&quot;(0.001, 1)&quot;, &quot;(0, 0.011)&quot;]Explanation: 0.0, 00, 0001 or 00.01 are not allowed.Example 3:Input: &quot;(0123)&quot;Output: [&quot;(0, 123)&quot;, &quot;(0, 12.3)&quot;, &quot;(0, 1.23)&quot;, &quot;(0.1, 23)&quot;, &quot;(0.1, 2.3)&quot;, &quot;(0.12, 3)&quot;]Example 4:Input: &quot;(100)&quot;Output: [(10, 0)]Explanation: 1.0 is not allowed. 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: vector&lt;string&gt; helper(string s) &#123; vector&lt;string&gt; ret; if (s == "0") return vector&lt;string&gt;(&#123;"0"&#125;); if (s[0] == '0' &amp;&amp; s.back() == '0') return ret; if (s[0] == '0' &amp;&amp; s.back() != '0') &#123; string ans = "0."; for (int i = 1; i &lt; s.size(); i++) &#123; ans.push_back(s[i]); &#125; ret.push_back(ans); return ret; &#125; if (s[0] != '0' &amp;&amp; s.back() == '0') &#123; ret.push_back(s); return ret; &#125; ret.push_back(s); for (int i = 1; i &lt; s.size(); i++) &#123; ret.push_back(s.substr(0, i) + "." + s.substr(i)); &#125; return ret; &#125; vector&lt;string&gt; ambiguousCoordinates(string S) &#123; S.pop_back(); S.erase(S.begin()); vector&lt;string&gt; ret; for (int i = 1; i &lt; S.size(); i++) &#123; for (auto a : helper(S.substr(0, i))) &#123; if (a == "") continue; for (auto b : helper(S.substr(i))) &#123; if (b == "") continue; ret.push_back("(" + a + ", " + b + ")"); &#125; &#125; &#125; return ret; &#125;&#125;; 818. Race Car [AC] Leetcode 818 Your car starts at position 0 and speed +1 on an infinite number line. (Your car can go into negative positions.) Your car drives automatically according to a sequence of instructions A (accelerate) and R (reverse). When you get an instruction “A”, your car does the following: position += speed, speed *= 2. When you get an instruction “R”, your car does the following: if your speed is positive then speed = -1 , otherwise speed = 1. (Your position stays the same.) For example, after commands “AAR”, your car goes to positions 0-&gt;1-&gt;3-&gt;3, and your speed goes to 1-&gt;2-&gt;4-&gt;-1. Now for some target position, say the length of the shortest sequence of instructions to get there.123456789101112131415Example 1:Input: target = 3Output: 2Explanation: The shortest instruction sequence is &quot;AA&quot;.Your position goes from 0-&gt;1-&gt;3.Example 2:Input: target = 6Output: 5Explanation: The shortest instruction sequence is &quot;AAARA&quot;.Your position goes from 0-&gt;1-&gt;3-&gt;7-&gt;7-&gt;6. 123456789101112131415class Solution &#123;public: int dp[10001]; int racecar(int t) &#123; if (dp[t] &gt; 0) return dp[t]; int n = floor(log2(t)) + 1, res; if (1 &lt;&lt; n == t + 1) dp[t] = n; else &#123; dp[t] = racecar((1 &lt;&lt; n) - 1 - t) + n + 1; for (int m = 0; m &lt; n - 1; ++m) dp[t] = min(dp[t], racecar(t - (1 &lt;&lt; (n - 1)) + (1 &lt;&lt; m)) + n + m + 1); &#125; return dp[t]; &#125;&#125;;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由FTRL展开，在线梯度下降（OGD）理论基础以及与离线梯度下降算法等效性证明总结]]></title>
    <url>%2F2018%2F10%2F16%2Fonline-learning-algorithm-background-knowledge-ftrl-provement%2F</url>
    <content type="text"><![CDATA[之前的项目中用到了FTRL，在最近的交流中经常被问及这方面的相关基础，发现之前对在线学习的基础知识掌握不全面，以及对OGD和SGD等效性没有理论依据，这里作为总结。 本文参考资料losteng的csdn和雷天琪的回答 在线学习算法相关背景在线学习算法强调的是训练的实时性，面向流式数据，每次训练不使用全量数据，而是以之前训练好的参数为基础，每次利用一个样本更新一次模型，是属于增量学习的一部分，从而快速更新模型，提高模型的时效性。 在线学习算法与离线学习关注点的不同统计学习的先验假设是数据存在自己一定的分布，我们的目的是寻找与实际分布距离最小的策略来泛化未知的结果。数据由真实模型产生，如果能有无限数据、并在包含有真实模型的空间里求解，也许我们能算出真是模 型。但实际上我们只有有限的有噪音的数据，这又限制我们只能使用相对简单的模型。所以，理想的算法是能够用不多的数据来得到一个不错的模型。 离线学习算法强调的是数据中不断训练已有的模型，不断迭代达到真实的数据分布，在训练过程中，所有数据都是可见的，目标是一定的（就是最终的那个真实分布），其中可以采用不同的更新策略和采样策略，所以有了批量梯度下降和随机梯度下降等算法。 但是，在线学习算法的关注点是不同的，在线学习算法的限制条件是只能看到过去的数据和当前的数据，看不到未来的数据，所以我们训练的策略可能是任意的数据分布，通过不断的训练可能颠覆之前的训练结果，所以在线学习甚至是为了破坏我们之前的策略精心设计的。 在线学习关注点在于，追求对所知道的所有知识所能设计最优的策略，那么同这个最优的策略的差距成为后悔（regret）:后悔没有从一开始就选择这个策略，当然，我们希望的是，随着时间的增加，这个差异会不断的变小。因为我们不对数据进行任何假设，所以策略是否完美并不是我们关心的（比如回答所有问题），我们追求的是，没有后悔（no-regret） batch模式和delta模式梯度下降可以分成两种模式，batch模式和delta模式。batch模式的时效性比delta模式要低一些。分析一下batch模式，比如昨天及昨天的数据训练成了模型M，那么今天的每一条训练数据在训练过程中都会更新一次模型M，从而生成今天的模型M1。 batch学习可以认为是离线学习算法，强调的是每次训练都需要使用全量的样本，因而可能会面临数据量过大的问题。一般进行多轮迭代来向最优解靠近。online learning没有多轮的概念，如果数据量不够或训练数据不够充分，通过copy多份同样的训练数据来模拟batch learning的多轮训练也是有效的方法。 delta模式可以认为是在线学习算法，没有多轮的概念，如果数据量不够或训练数据不够充分，通过copy多份同样的训练数据来模拟batch learning的多轮训练也是有效的方法。所以，OGD和SGD都属于在线学习算法，因为每次更新模型只用一个样本。SGD则每次只针对一个观测到的样本进行更新。通常情况下，SGD能够比GD“更快”地令 逼近最优值。当样本数 特别大的时候，SGD的优势更加明显，并且由于SGD针对观测到的“一条”样本更新 ，很适合进行增量计算，实现梯度下降的Online模式（OGD, OnlineGradient Descent）。 在线凸优化 本章只是简单介绍，如果想要深入了解在线凸优化（OCO），强烈推荐阅读Elad Hazand的著作和Zinkevich的Paper 聊到在线学习算法通常会说到专家系统，在$t$时刻专家$i$的损失是$\ell_t(e^i)$，于是这个时刻Weighted Majority（WM）损失的期望是$\sum_{i=1}^m w_t^i\ell_t(e^i)$，是关于这m个专家的损失的一个线性组合（因为权重$w_t^i$关于$i$的和为1，所以实际上是在一个simplex上）。将专家在$t$时刻的损失看成是这个时候进来的数据点，于是我们便在这里使用了一个线性的损失函数。 WM的理论证明可以参考Littlestone 94,Freund 99，虽然在上个世纪已经完成，但是将其理论拓展到一般的凸的函数还是在03年由Zinkevich完成的。 在线梯度下降（OGD）Zinkevich提出的算法很简单，在时刻t做两步操作，首先利用当前得到数据对$h_t$进行一次梯度下降得到$h_{t+1}$，如果新的$h_{t+1}$不在$\mathcal{H}$中，那么将其投影进来： $$\displaystyle h_{t+1}=\Pi_{\mathcal{H}}(h_t-\eta_t\nabla\ell_t(h_t))$$ 这里$\nabla\ell_t(h_t)$是$\ell_t(h_t)$关于$h_t$的导数（如果导数不唯一，就用次导数），$\eta_t$是学习率，$\Pi_{\mathcal{H}}(\cdot)$是投影子，其将不在$\mathcal{H}$中的向量$x$投影成一个与$x$最近的但在$\mathcal{H}$中的向量（如果$x$已经在$\mathcal{H}$中了，那就不做任何事），用公式表达就是$\Pi_{\mathcal{H}}(x)=\arg\min_{y\in\mathcal{H}}|x-y|$。此算法通常被称之为 Online Gradient Descent。 先来啰嗦几句其与离线梯度下降的区别。在离线的情况下，我们知道所有数据，所以能计算得到整个目标函数的梯度，从而朝最优解 迈出坚实的一步。而在online设定下，我们只根据当前的数据来计算一个梯度，其很可能与真实目标函数的梯度有一定的偏差。我们能保证的只是会减小的值，而对别的项的减少程度是未知的。当然，我们还是一直在朝目标前进，只是可能要走点弯路。 那online的优势在哪里呢？其关键是每走一步只需要看一下当前的一个数据，所以代价很小。而offline的算法每走一个要看下所有数据来算一 个真实梯度，所以代价很大。假定有100个数据，offline走10步就到最优，而online要100步才能到。但这样offline需要看1000 个数据，而online只要看100个数据，所以还是online代价小。 在这里，$\mathcal{H}$的作用是什么呢？记得在ML中的目标函数通常是损失+罚$\ell(h)+\lambda f(h)$的形式。例如ridge regression就是平方误差+$\ell_2$罚，lasso是平方误差+$\ell_1$罚，SVM是hinge loss+$\ell_2$罚。最小化这个目标函数可以等价于在$f(h)\le\delta$的限制下最小化$\ell(h)$。$\lambda$和$\delta$是一一对应的关系。实际上$f(h)\le\delta$就是定义了一个凸子空间，例如使用$\ell_2$罚时就是一个半径为$\delta$的球。所以，Online Gradient Descent可以online的解这一类目标函数，只是对于不同的罚选择不同的投影子。 下面是理论分析。记投影前的 $\tilde h_{t+1} = h_t-\eta_t\nabla\ell_t(h_t)$，以及offline最优解$h^=\arg\min_{h\in\mathcal{H}}\sum_{t=1}^T\ell_t(h)$ 。因为$ \mathcal{H} $是凸的且 $ h^ $ 在其中，所以对 $ \tilde h_{t+1} $ 投影只会减少其与 $ h^ $ 的距离，既 $ |h_{t+1}-h^|\le|\tilde h_{t+1}-h^*| $ 。记 $ \nabla_t=\nabla \ell_t(h_t) $ ，注意到 $$\displaystyle |\tilde h_{t+1}-h^|^2=|h_t-h^|^2+\eta_t^2|\nabla_t|^2-2\eta_t\langle\nabla_t,h_t-h^*\rangle.$$ 由于$\ell_t$是凸的，所以有 $$\displaystyle \ell_t(h_t)-\ell_t(h^)\le \langle\nabla_t,h_t-h^\rangle \le \frac{1}{2\eta_t}\big(|h_t-h^|^2 - |h_{t+1}-h^|^2\big) + \frac{\eta_t}{2}|\nabla_t|^2.$$ 取固定的$\eta_t=\eta$，对$t$进行累加就有$R(T)\le \frac{1}{2\eta}|w_1-w^*|^2+\frac{\eta}{2}\sum_{t=1}^T|\nabla_t|^2$。记$\mathcal{H}$的直径为$D$，且对所有$t$有$|\nabla_t|\le L$成立（既Lipschitz常数为$L$），再取$\eta=\frac{D}{L\sqrt{T}}$，那么 $$\displaystyle R(T)\le LD\sqrt{T}.$$ 这个bound可以通过设置变动的学习率$\eta_t$加强。 FTRL更新公式和SGD更新公式的等效性SGD算法的迭代计算公式如下： 其中 t 为迭代轮数，w是模型参数，g是loss function关于w的梯度，而η是学习率。 FTRL算法的迭代算公式如下： 其中 t 为迭代轮数，w是模型参数，σs定义成 λ1是L1正则化系数。在公式2中，arg min算子的内容中由3项组成，如果我们去掉最后面的L1正则化项，公式2就变成下面的公式3： （3）式子在换个形式后就等价于梯度下降公式。 以下是推导过程： 首先，我们要求公式3中的最小值，我们可以对其求导，得到 令上面的求导公式等于0就得到极值，极值正是Wt+1： 将含有wt+1的项放到等号左边，剩下的放在右边，得到公式6： 进一步化简得到公式7： 用 t-1 替换 t，得到公式8： 用公式7减去公式8，即式子的左边右边同时减去，得到公式9： 把σt用ηt表示，得到公式10： 对公式10化简即可得到公式1： 通过上面的推导证明，我们看到公式3与公式1确实等价。]]></content>
      <tags>
        <tag>算法基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 周赛模拟 【1】]]></title>
    <url>%2F2018%2F09%2F16%2FLeetcode-virtual-contest-20180910%2F</url>
    <content type="text"><![CDATA[Weekly Contest 85 参赛地址 836. Rectangle Overlap [AC] Leetcode 836 A rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) are the coordinates of its bottom-left corner, and (x2, y2) are the coordinates of its top-right corner. Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap. Given two (axis-aligned) rectangles, return whether they overlap. Example 1:12Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]Output: true Example 2:12Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]Output: false 12345678910class Solution &#123;public: bool isRectangleOverlap(vector&lt;int&gt;&amp; rec1, vector&lt;int&gt;&amp; rec2) &#123; long long x11 = rec1[0], x12 = rec1[2], x21 = rec2[0], x22 = rec2[2]; bool r1 = max(x11, x21) &lt; min(x12, x22); long long y11 = rec1[1], y12 = rec1[3], y21 = rec2[1], y22 = rec2[3]; bool r2 = max(y11, y21) &lt; min(y12, y22); return r1 &amp;&amp; r2; &#125;&#125;; 838. Push Dominoes [AC] Leetcode 838 There are N dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right. After each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right. When a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces. For the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino. Given a string “S” representing the initial state. S[i] = ‘L’, if the i-th domino has been pushed to the left; S[i] = ‘R’, if the i-th domino has been pushed to the right; S[i] = ‘.’, if the i-th domino has not been pushed. Return a string representing the final state. Example 1:12Input: &quot;.L.R...LR..L..&quot;Output: &quot;LL.RR.LLRRLL..&quot; Example 2:123Input: &quot;RR.L&quot;Output: &quot;RR.L&quot;Explanation: The first domino expends no additional force on the second domino. 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: string pushDominoes(string A) &#123; char pre = 0; int index = -1, n = A.size(); for (int i = 0; i &lt; n; i++) &#123; if (A[i] == 'L') &#123; if (pre == 'R') &#123; int k = (index + i + 1) / 2 - index; for (int j = 0; j &lt; k; j++) &#123; A[j + index] = 'R', A[i - j] = 'L'; &#125; &#125; else &#123; for (int j = index + 1; j &lt;= i; j++) &#123; A[j] = 'L'; &#125; &#125; pre = 'L'; index = i; &#125; else if (A[i] == 'R')&#123; if (pre == 'R') &#123; for (int j = index + 1; j &lt; i; j++) A[j] = 'R'; &#125; pre = 'R'; index = i; &#125; &#125; if (pre == 'R') &#123; for (int i = index + 1; i &lt; n; i++) A[i] = 'R'; &#125; return A; &#125;&#125;; 837. New 21 Game [unsolved] Leetcode 837 Alice plays the following game, loosely based on the card game “21”. Alice starts with 0 points, and draws numbers while she has less than K points. During each draw, she gains an integer number of points randomly from the range [1, W], where W is an integer. Each draw is independent and the outcomes have equal probabilities. Alice stops drawing numbers when she gets K or more points. What is the probability that she has N or less points? Example 1:123Input: N = 10, K = 1, W = 10Output: 1.00000Explanation: Alice gets a single card, then stops. Example 2:1234Input: N = 6, K = 1, W = 10Output: 0.60000Explanation: Alice gets a single card, then stops.In 6 out of W = 10 possibilities, she is at or below N = 6 points. Example 3:12Input: N = 21, K = 17, W = 10Output: 0.73278 12345678910111213141516171819class Solution &#123; public double new21Game(int N, int K, int W) &#123; double[] dp = new double[N+3]; dp[0] = 1; dp[1] = -1; double val = 0; for(int i = 0;i &lt; K;i++)&#123; val += dp[i]; if(i+1 &lt;= N)dp[i+1] += val / W; if(i+W+1 &lt;= N)dp[i+W+1] -= val / W; &#125; double ret = 0; for(int i = K;i &lt;= N;i++)&#123; val += dp[i]; ret += val; &#125; return ret; &#125;&#125; 839. Similar String Groups [AC] Leetcode 839 Two strings X and Y are similar if we can swap two letters (in different positions) of X, so that it equals Y. For example, “tars” and “rats” are similar (swapping at positions 0 and 2), and “rats” and “arts” are similar, but “star” is not similar to “tars”, “rats”, or “arts”. Together, these form two connected groups by similarity: {“tars”, “rats”, “arts”} and {“star”}. Notice that “tars” and “arts” are in the same group even though they are not similar. Formally, each group is such that a word is in the group if and only if it is similar to at least one other word in the group. We are given a list A of strings. Every string in A is an anagram of every other string in A. How many groups are there? Example 1:12Input: [&quot;tars&quot;,&quot;rats&quot;,&quot;arts&quot;,&quot;star&quot;]Output: 2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 并查集class Solution &#123;public: bool helper(string a, string b) &#123; if (a == b) return true; if (a.size() != b.size()) return false; if (a.empty()) return true; int cnt = 0; char x1 = '\0', y1 = '\0', x2 = '\0', y2 = '\0'; for (int i = 0; i &lt; a.size(); i++) &#123; if (a[i] == b[i]) continue; cnt ++; if (cnt == 1) x1 = a[i], y1 = b[i]; if (cnt == 2) x2 = a[i], y2 = b[i]; &#125; return cnt == 2 &amp;&amp; x1 == y2 &amp;&amp; x2 == y1; &#125; int MyFind(vector&lt;int&gt;&amp; nums, int x) &#123; int y = x; while (nums[x] != x) &#123; x = nums[x]; &#125; while (x != y) &#123; int t = nums[y]; nums[y] = x; y = t; &#125; return x; &#125; void MyMerge(vector&lt;int&gt;&amp; nums, int x, int y) &#123; int p1 = MyFind(nums, x); int p2 = MyFind(nums, y); if (p1 != p2) nums[p1] = p2; &#125; int numSimilarGroups(vector&lt;string&gt;&amp; A) &#123; int n = A.size(); if (!n) return 0; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; nums[i] = i; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == j) continue; if (helper(A[i], A[j])) MyMerge(nums, i, j); &#125; &#125; int ret = 0; for (int i = 0; i &lt; n; i++) &#123; if (MyFind(nums, i) == i) ret ++; &#125; return ret; &#125;&#125;; Weekly Contest 84 参赛地址 832. Flipping an Image [AC] Leetcode 832 Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1:1234Input: [[1,1,0],[1,0,1],[0,0,0]]Output: [[1,0,0],[0,1,0],[1,1,1]]Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2:1234Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int m = A.size(), n = A[0].size(); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n / 2; j++) &#123; swap(A[i][j], A[i][n - 1 - j]); &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; A[i][j] ^= 1; &#125; &#125; return A; &#125;&#125;; 833. Find And Replace in String [AC] Leetcode 833 To some string S, we will perform some replacement operations that replace groups of letters with new ones (not necessarily the same size). Each replacement operation has 3 parameters: a starting index i, a source word x and a target word y. The rule is that if x starts at position i in the original string S, then we will replace that occurrence of x with y. If not, we do nothing. For example, if we have S = “abcd” and we have some replacement operation i = 2, x = “cd”, y = “ffff”, then because “cd” starts at position 2 in the original string S, we will replace it with “ffff”. Using another example on S = “abcd”, if we have both the replacement operation i = 0, x = “ab”, y = “eee”, as well as another replacement operation i = 2, x = “ec”, y = “ffff”, this second operation does nothing because in the original string S[2] = ‘c’, which doesn’t match x[0] = ‘e’. All these operations occur simultaneously. It’s guaranteed that there won’t be any overlap in replacement: for example, S = “abc”, indexes = [0, 1], sources = [“ab”,”bc”] is not a valid test case. Example 1:1234Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;a&quot;,&quot;cd&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]Output: &quot;eeebffff&quot;Explanation: &quot;a&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;.&quot;cd&quot; starts at index 2 in S, so it&apos;s replaced by &quot;ffff&quot;. Example 2:1234Input: S = &quot;abcd&quot;, indexes = [0,2], sources = [&quot;ab&quot;,&quot;ec&quot;], targets = [&quot;eee&quot;,&quot;ffff&quot;]Output: &quot;eeecd&quot;Explanation: &quot;ab&quot; starts at index 0 in S, so it&apos;s replaced by &quot;eee&quot;. &quot;ec&quot; doesn&apos;t starts at index 2 in the original S, so we do nothing. 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: bool static cmp(pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b) &#123; return a.first &lt; b.first; &#125; string helper(string s, vector&lt;pair&lt;int, int&gt;&gt;&amp; m, vector&lt;string&gt;&amp; src, vector&lt;string&gt;&amp; targets) &#123; string ret = ""; int n = s.size(); for (int i = 0; i &lt; n; i++) &#123; if (!m.empty() &amp;&amp; i == m[0].first) &#123; auto t = m[0]; m.erase(m.begin()); string a = src[t.second], b = targets[t.second]; if (i + a.size() &lt;= n &amp;&amp; a == s.substr(i, a.size())) &#123; ret += b; i += a.size() - 1; continue; &#125; &#125; ret.push_back(s[i]); &#125; return ret; &#125; string findReplaceString(string S, vector&lt;int&gt;&amp; indexes, vector&lt;string&gt;&amp; sources, vector&lt;string&gt;&amp; targets) &#123; vector&lt;pair&lt;int, int&gt;&gt; m; int n = indexes.size(); for (int i = 0; i &lt; n; i++) m.push_back(make_pair(indexes[i], i)); sort(m.begin(), m.end(), cmp); return helper(S, m, sources, targets); &#125;&#125;; 835. Image Overlap [AC] Leetcode 835 Two images A and B are given, represented as binary, square matrices of the same size. (A binary matrix has only 0s and 1s as values.) We translate one image however we choose (sliding it left, right, up, or down any number of units), and place it on top of the other image. After, the overlap of this translation is the number of positions that have a 1 in both images. (Note also that a translation does not include any kind of rotation.) What is the largest possible overlap? Example 1:12345678Input: A = [[1,1,0], [0,1,0], [0,1,0]] B = [[0,0,0], [0,1,1], [0,0,1]]Output: 3Explanation: We slide A to right by 1 unit and down by 1 unit. 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: string convert(int i, int j) &#123; return to_string(i) + "-" + to_string(j); &#125; void helper(int i, int j, vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; B, int&amp; ret, unordered_set&lt;string&gt;&amp; hash) &#123; int m = A.size(), n = A[0].size(); if (i &lt;= -m || i &gt;= m || j &lt;= -n || j &gt;= n) return; int ans = 0; for (int x = 0; x &lt; m; x ++) &#123; for (int y = 0; y &lt; n; y++) &#123; int X = x + i, Y = y + j; if (X &lt; m &amp;&amp; X &gt;= 0 &amp;&amp; Y &lt; n &amp;&amp; Y &gt;= 0 &amp;&amp; A[X][Y] == 1 &amp;&amp; B[x][y] == 1) ans ++; &#125; &#125; ret = max(ret, ans); int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;1, -1, 0, 0&#125;; for (int k = 0; k &lt; 4; k++) &#123; int x = i + a[k], y = j + b[k]; auto s = convert(x, y); if (hash.find(s) != hash.end()) continue; hash.insert(s); helper(x, y, A, B, ret, hash); &#125; &#125; int largestOverlap(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123; int ret = 0; unordered_set&lt;string&gt; m; m.insert("0-0"); helper(0, 0, A, B, ret, m); return ret; &#125;&#125;; 834. Sum of Distances in Tree [TLE] Leetcode 834 An undirected, connected tree with N nodes labelled 0…N-1 and N-1 edges are given. The ith edge connects nodes edges[i][0] and edges[i][1] together. Return a list ans, where ans[i] is the sum of the distances between node i and all other nodes. Example 1:1234567891011Input: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]Output: [8,12,6,10,10,10]Explanation: Here is a diagram of the given tree: 0 / \1 2 /|\ 3 4 5We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)equals 1 + 1 + 2 + 2 + 2 = 8. Hence, answer[0] = 8, and so on. 123456789101112131415161718192021222324252627282930313233// BFS 超时版本....class Solution &#123;public: int helper(int start, vector&lt;unordered_set&lt;int&gt;&gt; adj, ) &#123; vector&lt;int&gt; cur(1, start); int ret = 0, cnt = 0; while (!cur.empty()) &#123; vector&lt;int&gt; next; cnt ++; for (auto i : cur) &#123; for (auto j : adj[i]) &#123; ret += cnt; adj[j].erase(i); next.push_back(j); &#125; &#125; cur = next; &#125; return ret; &#125; vector&lt;int&gt; sumOfDistancesInTree(int N, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; vector&lt;unordered_set&lt;int&gt;&gt; adj(N); for (auto t : edges) &#123; adj[t[0]].insert(t[1]); adj[t[1]].insert(t[0]); &#125; vector&lt;int&gt; ret; for (int i = 0; i &lt; N; i++) &#123; ret.push_back(helper(i, adj)); &#125; return ret; &#125;&#125;; 1234567891011121314151617181920212223242526272829303132333435363738394041// 后用dfs保存中间状态ACconst int N = 1e4 + 10;vector&lt;int&gt; a[N];int dp0[N], dp1[N];void DFS(int u, int parent) &#123; dp0[u] = 1; dp1[u] = 0; for (auto&amp; v : a[u]) &#123; if (v == parent) continue; DFS(v, u); dp0[u] += dp0[v]; dp1[u] += dp1[v] + dp0[v]; &#125;&#125;void DFS2(int u, int parent, int n, vector&lt;int&gt;&amp; ret) &#123; for (auto&amp; v : a[u]) &#123; if (v == parent) continue; ret[v] = ret[u] + (n - dp0[v]) - (dp0[v]);// cout &lt;&lt; u &lt;&lt; " " &lt;&lt; v &lt;&lt; " " &lt;&lt; ret[u] &lt;&lt; " " &lt;&lt; dp0[u] &lt;&lt; " " &lt;&lt; dp0[v] &lt;&lt; " " &lt;&lt; ret[v] &lt;&lt; endl; DFS2(v, u, n, ret); &#125;&#125;class Solution &#123;public: vector&lt;int&gt; sumOfDistancesInTree(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) &#123; for (int i = 0; i &lt; n; ++i) a[i].clear(); for (auto&amp; it : edges) &#123; int x = it[0], y = it[1]; a[x].push_back(y); a[y].push_back(x); &#125; DFS(0, -1); vector&lt;int&gt; ret(n); ret[0] = dp1[0]; DFS2(0, -1, n, ret); return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>Leetcode</tag>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【总结】零星算法模板总结]]></title>
    <url>%2F2018%2F09%2F08%2Fleetcode-summary-some-sample%2F</url>
    <content type="text"><![CDATA[这里整理一些零星的算法，作为记录… 水塘抽样Linked List Random Node Leetcode 382 Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? Example:12345678// Init a singly linked list [1,2,3].ListNode head = new ListNode(1);head.next = new ListNode(2);head.next.next = new ListNode(3);Solution solution = new Solution(head);// getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.solution.getRandom(); 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* root; /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ Solution(ListNode* head) &#123; root = head; &#125; /** Returns a random node's value. */ int getRandom() &#123; if (!root) return -1; int ret = root-&gt;val; ListNode* cur = root-&gt;next; int cnt = 2; while (cur) &#123; int k = rand() % cnt; cnt ++; if (!k) ret = cur-&gt;val; cur = cur-&gt;next; &#125; return ret; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(head); * int param_1 = obj.getRandom(); */ Random Pick Index Leetcode 398 Given an array of integers with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array. Note:The array size can be very large. Solution that uses too much extra space will not pass the judge. Example:12345678int[] nums = new int[] &#123;1,2,3,3,3&#125;;Solution solution = new Solution(nums);// pick(3) should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.solution.pick(3);// pick(1) should return 0. Since in the array only nums[0] is equal to 1.solution.pick(1); 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; ans; Solution(vector&lt;int&gt; nums) &#123; ans = nums; &#125; int pick(int target) &#123; int ret = -1, cnt = 1; for (int i = 0; i &lt; ans.size(); i++) &#123; if (ans[i] == target) &#123; int key = rand() % cnt; if (!key) ret = i; cnt ++; &#125; &#125; return ret; &#125;&#125;;/** * Your Solution object will be instantiated and called as such: * Solution obj = new Solution(nums); * int param_1 = obj.pick(target); */ 线段树Count of Smaller Numbers After Self Leetcode 315 You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i]. Example:1234567Input: [5,2,6,1]Output: [2,1,1,0] Explanation:To the right of 5 there are 2 smaller elements (2 and 1).To the right of 2 there is only 1 smaller element (1).To the right of 6 there is 1 smaller element (1).To the right of 1 there is 0 smaller element. 1234567891011121314151617181920212223242526272829303132333435363738// 此题先用二分查找树实现，线段树实现方法之后正在更新struct MyTreeNode &#123; int val; int duplicate; int cnt; MyTreeNode* left, *right; MyTreeNode(int val) : val(val), duplicate(1), cnt(0), left(NULL), right(NULL) &#123;&#125;&#125;;class Solution &#123;public: int helper(int target, MyTreeNode* &amp;root) &#123; if (!root) &#123; root = new MyTreeNode(target); return 0; &#125; if (root-&gt;val &lt; target) &#123; return root-&gt;duplicate + root-&gt;cnt + helper(target, root-&gt;right); &#125; else if (root-&gt;val &gt; target) &#123; root-&gt;cnt ++; return helper(target, root-&gt;left); &#125; else &#123; root-&gt;duplicate ++; return root-&gt;cnt; &#125; &#125; vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return vector&lt;int&gt;(); int n = nums.size(); vector&lt;int&gt; ret(n, 0); MyTreeNode* root = new MyTreeNode(nums[n - 1]); for (int i = n - 2; i &gt;= 0; i--) &#123; ret[i] = helper(nums[i], root); &#125; return ret; &#125;&#125;; 最大公约数1234int gcd(int a, int b) &#123; if (!b) return a; return gcd(b, a % b);&#125; 子串和满足条件的最短长度Minimum Size Subarray Sum Leetcode 209 Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead. Example:123Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint. 12345678910111213class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int ret = INT_MAX; int n = nums.size(), left = 0, right = 0, ans = 0; while (right &lt; n) &#123; ans += nums[right++]; while (left &lt; right &amp;&amp; ans - nums[left] &gt;= s) ans -= nums[left++]; if (ans &gt;= s) ret = min(ret, right - left); &#125; return ret == INT_MAX ? 0 : ret; &#125;&#125;; 上一题数组中包含正负，找和为target的最小长度1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;stdlib.h&gt;#include &lt;climits&gt;using namespace std;int helper(int target, vector&lt;int&gt;&amp; nums) &#123; int ret = INT_MAX; unordered_map&lt;int, int&gt; m; int ans = 0; for (int i = 0; i &lt; nums.size(); i++) &#123; ans += nums[i]; int t = target - ans; m[ans] = i; if (m.count(t)) &#123; ret = min(ret, i - m[t]); &#125; &#125; return ret == INT_MAX ? 0 : ret;&#125;int main() &#123; int target, n; cin &gt;&gt; target &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(target, nums) &lt;&lt; endl; return 0;&#125; 上一题的follow up，包含正负，找出大于等于k的最小长度 Leetcode 862 Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1. Example 1:12Input: A = [1], K = 1Output: 1 Example 2:12Input: A = [1,2], K = 4Output: -1 Example 3:12Input: A = [2,-1,2], K = 3Output: 3 12345678910111213141516171819202122232425262728293031323334353637#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums, int k) &#123; int ret = INT_MAX; deque&lt;int&gt; s; int n = nums.size(); vector&lt;int&gt; ans(n + 1, 0); for (int i = 1; i &lt;= n; i++) &#123; ans[i] = ans[i - 1] + nums[i - 1]; &#125; for (int i = 0; i &lt;= n; i++) &#123; while (!s.empty() &amp;&amp; ans[i] - ans[s.front()] &gt;= k) &#123; ret = min(ret, i - s.front()); s.pop_front(); &#125; while (!s.empty() &amp;&amp; ans[s.back()] &gt;= ans[i]) s.pop_back(); s.push_back(i); &#125; return ret == INT_MAX ? -1 : ret;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums, k) &lt;&lt; endl; return 0;&#125; 快排相关快排模板12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int base = nums[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[right] &gt;= base) right --; if (left &lt; right) nums[left] = nums[right]; while (left &lt; right &amp;&amp; nums[left] &lt; base) left ++; if (left &lt; right) nums[right] = nums[left]; &#125; nums[left] = base; return left;&#125;void helper(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left &lt; right) &#123; int mid = partition(nums, left, right); helper(nums, left, mid); helper(nums, mid + 1, right); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; helper(nums, 0, n); for (auto i : nums) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 快排优化 快排的优化可以参考此处文献 基准随机化算法 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stdlib.h&gt;using namespace std;int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int base = nums[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[right] &gt;= base) right --; if (left &lt; right) nums[left] = nums[right]; while (left &lt; right &amp;&amp; nums[left] &lt; base) left ++; if (left &lt; right) nums[right] = nums[left]; &#125; nums[left] = base; return left;&#125;void helper(vector&lt;int&gt;&amp; nums, int left, int right) &#123; if (left &lt; right) &#123; // 随机产生基准 int index = left + rand() % (right - left + 1); swap(nums[left], nums[right]); int mid = partition(nums, left, right); helper(nums, left, mid - 1); helper(nums, mid + 1, right); &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; helper(nums, 0, n - 1); for (int i : nums) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 将前后中间三个数取中值作为标兵元素 在数组大小等于一定范围的时候，改为插入排序，防止排序退化 将相等的数字聚集到一起，然后跳过此处的排序 快速选择算法模板 验证地址Leetcode 215 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int base = nums[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[right] &lt;= base) right--; if (left &lt; right) nums[left] = nums[right]; while (left &lt; right &amp;&amp; nums[left] &gt; base) left ++; if (left &lt; right) nums[right] = nums[left]; &#125; nums[left] = base; return left;&#125;int helper(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123; if (left &lt;= right) &#123; int mid = partition(nums, left, right); if (mid == k - 1) return nums[mid]; if (mid &lt; k - 1) return helper(nums, mid + 1, right, k); else return helper(nums, left, mid - 1, k); &#125; return -1;&#125;int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); if (n &lt; k) return -1; return helper(nums, 0, n - 1, k);&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; findKthLargest(nums, k) &lt;&lt; endl; return 0;&#125; 快速选择算法复杂度为O(n)的证明参考文献 最大子串和 贪心算法，最小类似 12345678910111213141516171819202122232425262728#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;climits&gt;#include &lt;stdlib.h&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums) &#123; int ans = 0, n = nums.size(); int ret = INT_MIN; for (int i = 0; i &lt; n; i++) &#123; ans += nums[i]; ret = max(ret, ans); if (ans &lt;= 0) ans = 0; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; 并查集模板12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int find(vector&lt;int&gt;&amp; nums, int x) &#123; int y = x; while (nums[x] != x) &#123; x = nums[x]; &#125; while (y != x) &#123; int t = nums[y]; nums[y] = x; y = t; &#125; return x;&#125;void merge(vector&lt;int&gt;&amp; nums, int x, int y) &#123; int p1 = find(nums, x); int p2 = find(nums, y); if (p1 != p2) &#123; nums[p1] = p2; &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) nums[i] = i; for (int i = 0; i &lt; k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(nums, x, y); &#125; int ret = 0; for (int i = 0; i &lt; n; i++) &#123; if (i == find(nums, i)) ret ++; &#125; cout &lt;&lt; ret &lt;&lt; endl; return 0;&#125; 牛顿法 Leetcode 69 Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1:12Input: 4Output: 2 Example 2:1234Input: 8Output: 2Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned. 12345678910class Solution &#123;public: int mySqrt(int x) &#123; long long ret = x; while (ret * ret &gt; x) &#123; ret = (ret + x / ret) / 2; &#125; return ret; &#125;&#125;; 堆排序 验证地址 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void heapfy(vector&lt;int&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; nums[left] &lt; nums[smallest]) smallest = left; if (right &lt; max &amp;&amp; nums[right] &lt; nums[smallest]) smallest = right; if (smallest != index) &#123; swap(nums[index], nums[smallest]); heapfy(nums, smallest, max); &#125;&#125;int helper(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); if (n &lt; k) return -1; vector&lt;int&gt; ans; for (int i = 0; i &lt; k; i++) &#123; ans.push_back(nums[i]); &#125; for (int i = k / 2 - 1; i &gt;= 0; i--) heapfy(ans, i, k); for (int i = k; i &lt; n; i++) &#123; if (nums[i] &lt; ans[0]) continue; ans[0] = nums[i]; for (int j = k / 2 - 1; j &gt;= 0; j--) heapfy(ans, j, k); &#125; return ans[0];&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums, k) &lt;&lt; endl; return 0;&#125; 拓扑排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;unordered_set&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; helper(vector&lt;unordered_set&lt;int&gt;&gt;&amp; adj, vector&lt;int&gt;&amp; cnt) &#123; int n = cnt.size(); unordered_set&lt;int&gt; m; vector&lt;int&gt; cur; vector&lt;vector&lt;int&gt;&gt; ret; for (int i = 0; i &lt; n; i++) &#123; if (!cnt[i]) &#123; cur.push_back(i); m.insert(i); &#125; &#125; while (true) &#123; ret.push_back(cur); vector&lt;int&gt; next; for (auto i : cur) &#123; for (auto j : adj[i]) &#123; cnt[j]--; if (!cnt[j]) &#123; if (m.find(j) != m.end()) return vector&lt;vector&lt;int&gt;&gt;(); next.push_back(j); m.insert(j); &#125; &#125; &#125; if (next.empty()) break; else cur = next; &#125; if (n != m.size()) return vector&lt;vector&lt;int&gt;&gt;(); return ret;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; cnt(n, 0); vector&lt;unordered_set&lt;int&gt;&gt; adj(n); for (int i = 0; i &lt; k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; cnt[y]++; adj[x].insert(y); &#125; auto ret = helper(adj, cnt); for (auto i : ret) &#123; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 快速幂Pow(x, n) Leetcode 50 Implement pow(x, n), which calculates x raised to the power n (xn). 12Input: 2.00000, 10Output: 1024.00000 代码1234567891011121314class Solution &#123;public: double myPow(double x, int n) &#123; double ret = 1.0; // 注意要整型溢出 long N = abs((long) n); while (N) &#123; if (N &amp; 1) ret *= x; N &gt;&gt;= 1; x *= x; &#125; return n &gt; 0 ? ret : 1 / ret; &#125;&#125;; 矩阵快速幂 矩阵乘法还可以做dp优化，之后更新…. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;vector&gt;#include &lt;iostream&gt;#define MOD 1000000007using namespace std;vector&lt;vector&lt;int&gt;&gt; mul(vector&lt;vector&lt;int&gt;&gt;&amp; A, vector&lt;vector&lt;int&gt;&gt;&amp; B) &#123; int n = A.size(); vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(n, 0)); for (int i = 0;i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; for (int k = 0; k &lt; n; k++) &#123; ret[i][j] += A[i][k] * B[k][j]; ret[i][j] %= MOD; &#125; &#125; &#125; return ret;&#125;vector&lt;vector&lt;int&gt;&gt; Qpow(vector&lt;vector&lt;int&gt;&gt; nums, int k) &#123; int n = nums.size(); cout &lt;&lt; n &lt;&lt; endl; vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; n; i++) &#123; ret[i][i] = 1; &#125; while (k) &#123; if (k &amp; 1) ret = mul(ret, nums); nums = mul(nums, nums); k &gt;&gt;= 1; &#125; return ret;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; nums(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; auto ret = Qpow(nums, k); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cout &lt;&lt; ret[i][j] &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 验证地址 全排列相关Permutation Sequence Leetcode 60 对于数字全排列可以用这种方法 12345678910111213141516string getPermutation(int n, int k) &#123; long long ans[n + 1] = &#123;1&#125;; string ret; vector&lt;int&gt; nums; for (int i = 1; i &lt;= n; i++) &#123; ans[i] = ans[i - 1] * i; nums.push_back(i); &#125; for (int i = 0; i &lt; n; i++) &#123; int index = (k - 1) / ans[n - i - 1]; ret += to_string(nums[index]); nums.erase(nums.begin() + index); k = k - ans[n - i - 1] * index; &#125; return ret;&#125; 字母全排列 数字可以用上面的方法，但是对于字母来说就不行了，因为long long也存不下所有全排列的种类数 第二个思路是使用nextPermutation，此函数的原理是 从最后向前找相邻的两个元素是的i &lt; ii 然后再从最后向前找一个元素使得i &lt; j i和j交换，然后将ii之后的元素reverse排序 nextPermutation的头文件是algorithm 12345678910string getPermutation(int n, int k) &#123; string ret; for (int i = 1; i &lt;= n; i++) &#123; ret += to_string(i); &#125; for (int i = 1; i &lt; k; i++) &#123; next_permutation(ret.begin(), ret.end()); &#125; return ret;&#125; 面试题集合面试题1 一个树形的图，要遍历其中k个节点，最少需要走多少步 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;unordered_set&gt;using namespace std;int helper(vector&lt;unordered_set&lt;int&gt;&gt;&amp; adj) &#123; int n = adj.size(); int ret = 0; vector&lt;int&gt; cur; for (int i = 0; i &lt; n; i++) &#123; if (adj[i].size() == 1) cur.push_back(i); &#125; while (true) &#123; ret ++; vector&lt;int&gt; next; for (auto i : cur) &#123; for (auto j : adj[i]) &#123; adj[j].erase(i); if (adj[j].size() == 1) next.push_back(j); &#125; &#125; if (next.empty()) break; else cur = next; &#125; if (cur.size() == 1) return 2 *(ret - 1); else return 2 * (ret - 1) + 1;&#125;int main() &#123; int n, k, d; cin &gt;&gt; n &gt;&gt; k &gt;&gt; d; vector&lt;unordered_set&lt;int&gt;&gt; adj(n, unordered_set&lt;int&gt;()); for (int i = 0; i &lt; k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; adj[x].insert(y); adj[y].insert(x); &#125; int len = helper(adj), ret; if (len &gt;= d) ret = d; else ret = len + (d - len) * 2; cout &lt;&lt; ret &lt;&lt; endl; return 0;&#125; 面试题2 表达式求值 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;double getNum(string s, int&amp; index) &#123; double ret = 0.0; int cnt = -1, n = s.size(); while (index &lt; n &amp;&amp; (s[index] == '.' || isdigit(s[index]))) &#123; if (s[index] == '.') cnt ++; else &#123; ret = ret * 10 + (s[index] - '0'); if (cnt &gt;= 0) cnt ++; &#125; index ++; &#125; if (cnt == -1) cnt = 0; return ret / pow(10, cnt);&#125;double helper(string s, int&amp; index) &#123; double ret = 0.0, cur_ret = 0.0; char op = '+'; int n = s.size(); while (index &lt; n &amp;&amp; s[index] != ')') &#123; if (s[index] == ' ') &#123; index ++; continue; &#125; if (isdigit(s[index]) || s[index] == '(') &#123; double ans; if (isdigit(s[index])) ans = getNum(s, index); else &#123; index ++; ans = helper(s, index); index ++; &#125; switch(op) &#123; case '+' : cur_ret += ans; break; case '-' : cur_ret -= ans; break; case '*' : cur_ret *= ans; break; case '/' : cur_ret /= ans; break; &#125; &#125; else &#123; if (s[index] == '+' || s[index] == '-') &#123; ret += cur_ret; cur_ret = 0.0; &#125; op = s[index++]; &#125; &#125; return ret + cur_ret;&#125;int main() &#123; string s; cin &gt;&gt; s; int index = 0; cout &lt;&lt; helper(s, index) &lt;&lt; endl; return 0;&#125; 面试题3 寻找能使数组跷跷板平衡的支点有几个 123456789101112131415161718192021222324252627282930#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;int helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(), ret = 0; for (int i = 0; i &lt;= n; i++) &#123; int left = 0, right = 0; for (int j = 0; j &lt; i; j++) &#123; left += (i - j) * nums[j]; &#125; for (int j = i; j &lt; n; j++) &#123; right += (j - i + 1) * nums[j]; &#125; if (left == right) ret ++; &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; 面试题4 给定一组数，表示他所在组的大小，输出一个数组，同一分组的在一起，数组保证字典序最小 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;bool cmp(const vector&lt;int&gt;&amp; a, const vector&lt;int&gt;&amp; b) &#123; return a[0] &lt; b[0];&#125;vector&lt;int&gt; helper(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ret; vector&lt;vector&lt;int&gt;&gt; ans; unordered_map&lt;int, vector&lt;int&gt;&gt; m; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; m[nums[i]].push_back(i); if (m[nums[i]].size() == nums[i]) &#123; ans.push_back(m[nums[i]]); m[nums[i]].clear(); &#125; &#125; sort(ans.begin(), ans.end(), cmp); for (auto i : ans) &#123; ret.insert(ret.end(), i.begin(), i.end()); &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; for (auto i : helper(nums)) &#123; cout &lt;&lt; i &lt;&lt; endl; &#125; return 0;&#125; 面试题5题目：给定一个状态转移图，和一个目标字符集合 M=| |A |B |C ||—-|:–:|:–:|:–:||A |B,C |C |A ||B |A,C |C |C ||C |A |A |A,B | S={A,B,C} 每两个字符可以转换成一个字符，例如AAB可以转成BC，判断是否能最后转化成目标集合中的字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;vector&gt;#include &lt;map&gt;#include &lt;iostream&gt;#include &lt;unordered_set&gt;using namespace std;bool helper(map&lt;char, map&lt;char, string&gt;&gt;&amp; trans, unordered_set&lt;char&gt;&amp; goals, string cur, string next, int index) &#123; int n = cur.size(); if (index == n) &#123; if (n == 1) return goals.find(cur[0]) != goals.end(); return helper(trans, goals, next, "", 1); &#125; for (auto i : trans[cur[index - 1]][cur[index]]) &#123; if (helper(trans, goals, cur, next + i, index + 1)) return true; &#125; return false;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; map&lt;char, map&lt;char, string&gt;&gt; trans; unordered_set&lt;char&gt; goals; for (int i = 0; i &lt; n * n; i++) &#123; char x, y; string s; cin &gt;&gt; x &gt;&gt; y &gt;&gt; s; trans[x][y] = s; &#125; for (int i = 0; i &lt; k; i++) &#123; char x; cin &gt;&gt; x; goals.insert(x); &#125; string s; cin &gt;&gt; s; cout &lt;&lt; helper(trans, goals, s, "", 1) &lt;&lt; endl; return 0;&#125;/*3 3A A BCA B CA C AB A ACB B CB C CC A AC B AC C ABA B CAAB*/]]></content>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>OJ</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode DP及贪心算法总结]]></title>
    <url>%2F2018%2F09%2F05%2Fleetcode-summary-dp-and-greedy%2F</url>
    <content type="text"><![CDATA[这里总结一些DP类型的题目，因为贪心一定程度可以认为是一维的DP，所以也做总结 贪心Jump Game Leetcode 55 Given an array of non-negative integers, you are initially positioned at the first index of the array. Each element in the array represents your maximum jump length at that position. Determine if you are able to reach the last index. Example 1:123Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:1234Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. 1234567891011class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return true; int n = nums.size(), reach = 0, index = 0; for (index = 0; index &lt; n &amp;&amp; index &lt;= reach; index ++) &#123; reach = max(reach, index + nums[index]); &#125; return reach &gt;= n - 1; &#125;&#125;; Majority Element II Leetcode 229 Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1:12Input: [3,2,3]Output: [3] Example 2:12Input: [1,1,1,3,3,2,2,2]Output: [1,2] 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; majorityElement(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int c1 = 0, c2 = 0, i1 = 0, i2 = 1; for (auto i : nums) &#123; if (i == i1) c1 ++; else if (i == i2) c2 ++; else if (!c1) i1 = i, c1 = 1; else if (!c2) i2 = i, c2 = 1; else c1--, c2--; &#125; c1 = 0, c2 = 0; for (auto i : nums) &#123; if (i == i1) c1++; if (i == i2) c2++; &#125; vector&lt;int&gt; ret; if (c1 &gt; n / 3) ret.push_back(i1); if (c2 &gt; n / 3) ret.push_back(i2); return ret; &#125;&#125;; Queue Reconstruction by Height Leetcode 406 Suppose you have a random list of people standing in a queue. Each person is described by a pair of integers (h, k), where h is the height of the person and k is the number of people in front of this person who have a height greater than or equal to h. Write an algorithm to reconstruct the queue. Note:The number of people is less than 1,100. Example12345Input:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]Output:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 1234567891011121314class Solution &#123;public: bool static cmp(pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b) &#123; return a.first == b.first ? a.second &lt; b.second : a.first &gt; b.first; &#125; vector&lt;pair&lt;int, int&gt;&gt; reconstructQueue(vector&lt;pair&lt;int, int&gt;&gt;&amp; people) &#123; sort(people.begin(), people.end(), cmp); vector&lt;pair&lt;int, int&gt;&gt; ret; for (auto i : people) &#123; ret.insert(ret.begin() + i.second, i); &#125; return ret; &#125;&#125;; Minimum Number of Arrows to Burst Balloons Leetcode 452 There are a number of spherical balloons spread in two-dimensional space. For each balloon, provided input is the start and end coordinates of the horizontal diameter. Since it’s horizontal, y-coordinates don’t matter and hence the x-coordinates of start and end of the diameter suffice. Start is always smaller than end. There will be at most 104 balloons. An arrow can be shot up exactly vertically from different points along the x-axis. A balloon with xstart and xend bursts by an arrow shot at x if xstart ≤ x ≤ xend. There is no limit to the number of arrows that can be shot. An arrow once shot keeps travelling up infinitely. The problem is to find the minimum number of arrows that must be shot to burst all balloons. Example:12345678Input:[[10,16], [2,8], [1,6], [7,12]]Output:2Explanation:One way is to shoot one arrow for example at x = 6 (bursting the balloons [2,8] and [1,6]) and another arrow at x = 11 (bursting the other two balloons). 1234567891011121314151617181920212223class Solution &#123;public: // 扫描线算法 bool static cmp(pair&lt;int, int&gt;&amp; a, pair&lt;int, int&gt;&amp; b) &#123; return a.first == b.first ? a.second &lt; b.second : a.first &lt; b.first; &#125; int findMinArrowShots(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) &#123; if (points.empty()) return 0; int ret = 1, n = points.size(); sort(points.begin(), points.end(), cmp); int limit = points[0].second; for (auto i : points) &#123; if (i.first &gt; limit) &#123; ret ++; limit = i.second; &#125; else &#123; limit = min(limit, i.second); &#125; &#125; return ret; &#125;&#125;; Remove K Digits Leetcode 402 Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Note: The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero. Example 1:123Input: num = &quot;1432219&quot;, k = 3Output: &quot;1219&quot;Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2:123Input: num = &quot;10200&quot;, k = 1Output: &quot;200&quot;Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3:123Input: num = &quot;10&quot;, k = 2Output: &quot;0&quot;Explanation: Remove all the digits from the number and it is left with nothing which is 0. 1234567891011121314151617181920212223242526class Solution &#123;public:// 这里用了栈，其实也可以用两个指针实现 string removeKdigits(string num, int k) &#123; int n = num.size(); if (n &lt;= k) return "0"; stack&lt;char&gt; s; for (auto i : num) &#123; while (!s.empty() &amp;&amp; k &amp;&amp; s.top() &gt; i) &#123; k--; s.pop(); &#125; s.push(i); &#125; for (int i = 0; i &lt; k; i++) &#123; s.pop(); &#125; string ret; while (!s.empty()) &#123; ret = s.top() + ret; s.pop(); &#125; while (!ret.empty() &amp;&amp; ret[0] == '0') ret.erase(ret.begin()); return ret.empty() ? "0" : ret; &#125;&#125;; 动态规划矩阵链相乘 算法导论 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;climits&gt;#include &lt;math.h&gt;using namespace std;int helper(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; p(n + 1, 0); for (int i = 0; i &lt; n; i++) &#123; p[i] = nums[i].first; &#125; p[n] = nums.back().second; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); for (int i = 2; i &lt;= n; i++) &#123; for (int l = 0; l &lt;= n - i; l ++) &#123; int r = l + i - 1; dp[l][r] = INT_MAX; for (int k = l; k &lt; r; k++) &#123; int ans = dp[l][k] + dp[k + 1][r] + p[l] * p[k + 1] * p[r + 1]; dp[l][r] = min(dp[l][r], ans); &#125; &#125; &#125; return dp[0][n - 1];&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; nums; for (int i = 0; i &lt; n; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; nums.push_back(&#123;x, y&#125;); &#125; cout &lt;&lt; helper(nums) &lt;&lt; endl; return 0;&#125; Gas Station Leetcode 134 There are N gas stations along a circular route, where the amount of gas at station i is gas[i]. You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations. Return the starting gas station’s index if you can travel around the circuit once in the clockwise direction, otherwise return -1. Note: If there exists a solution, it is guaranteed to be unique. Both input arrays are non-empty and have the same length. Each element in the input arrays is a non-negative integer. Example 1:1234567891011121314Input: gas = [1,2,3,4,5]cost = [3,4,5,1,2]Output: 3Explanation:Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 4. Your tank = 4 - 1 + 5 = 8Travel to station 0. Your tank = 8 - 2 + 1 = 7Travel to station 1. Your tank = 7 - 3 + 2 = 6Travel to station 2. Your tank = 6 - 4 + 3 = 5Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.Therefore, return 3 as the starting index. Example 2:12345678910111213Input: gas = [2,3,4]cost = [3,4,3]Output: -1Explanation:You can&apos;t start at station 0 or 1, as there is not enough gas to travel to the next station.Let&apos;s start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4Travel to station 0. Your tank = 4 - 3 + 2 = 3Travel to station 1. Your tank = 3 - 3 + 3 = 3You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.Therefore, you can&apos;t travel around the circuit once no matter where you start. 1234567891011121314151617class Solution &#123;public: int canCompleteCircuit(vector&lt;int&gt;&amp; gas, vector&lt;int&gt;&amp; cost) &#123; int ans = 0, c = 0, g = 0; int ret = 0; for (int i = 0; i &lt; gas.size(); i++) &#123; ans += gas[i] - cost[i]; g += gas[i]; c += cost[i]; if (ans &lt; 0) &#123; ans = 0; ret = i + 1; &#125; &#125; return g &gt;= c ? ret : -1; &#125;&#125;; Counting Bits Leetcode 338 Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array. Example 1:12Input: 2Output: [0,1,1] Example 2:12Input: 5Output: [0,1,1,2,1,2] 12345678910class Solution &#123;public: vector&lt;int&gt; countBits(int num) &#123; vector&lt;int&gt; dp(num + 1, 0); for (int i = 1; i &lt;= num; i++) &#123; dp[i] = dp[i &amp; (i - 1)] + 1; &#125; return dp; &#125;&#125;; House Robber II Leetcode 213 You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. Example 1:1234Input: [2,3,2]Output: 3Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses. Example 2:1234Input: [1,2,3,1]Output: 4Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4. 12345678910111213141516class Solution &#123;public: int helper(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int pre = 0, ret = 0; for (int i = left; i &lt;= right; i++) &#123; int temp = max(pre + nums[i], ret); pre = ret, ret = temp; &#125; return ret; &#125; int rob(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt; 2) return n == 0 ? 0 : nums[0]; return max(helper(nums, 0, n - 2), helper(nums, 1, n - 1)); &#125;&#125;; Largest Divisible Subset Leetcode 368 Given a set of distinct positive integers, find the largest subset such that every pair (Si, Sj) of elements in this subset satisfies: Si % Sj = 0 or Sj % Si = 0. If there are multiple solutions, return any subset is fine. Example 1:12Input: [1,2,3]Output: [1,2] (of course, [1,3] will also be ok) Example 2:12Input: [1,2,4,8]Output: [1,2,4,8] 12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; ret; sort(nums.begin(), nums.end(), greater&lt;int&gt;()); vector&lt;int&gt; dp(n, 0); vector&lt;int&gt; parents(n, -1); int index = -1, m = 0; for (int i = 0; i &lt; n; i++) &#123; dp[i] = 1; parents[i] = i; for (int j = 0; j &lt; i; j ++) &#123; if (nums[j] % nums[i] == 0 &amp;&amp; dp[i] &lt; dp[j] + 1) &#123; dp[i] = dp[j] + 1; parents[i] = j; &#125; &#125; if (m &lt; dp[i]) &#123; m = dp[i]; index = i; &#125; &#125; for (int i = 0; i &lt; m; i++) &#123; ret.push_back(nums[index]); index = parents[index]; &#125; reverse(ret.begin(), ret.end()); return ret; &#125;&#125;; Best Time to Buy and Sell Stock with Cooldown Leetcode 309 Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).After you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day) Example:123Input: [1,2,3,0,2]Output: 3 Explanation: transactions = [buy, sell, cooldown, buy, sell] 12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int buy(INT_MIN), sell(0), pre_sell(0); for (auto i : prices) &#123; int pre_buy = buy; buy = max(buy, pre_sell - i); pre_sell = sell; sell = max(sell, pre_buy + i); &#125; return sell; &#125;&#125;; 最长公共子序列12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;string helper(string a, string b) &#123; int m = a.size(), n = b.size(); vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); vector&lt;vector&lt;int&gt;&gt; parents(m + 1, vector&lt;int&gt;(n + 1, 0)); for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (a[i - 1] == b[j - 1]) &#123; dp[i][j] = dp[i - 1][j - 1] + 1; parents[i][j] = 1; &#125; else &#123; dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]); if (dp[i - 1][j] &gt; dp[i][j - 1]) parents[i][j] = 2; else parents[i][j] = 3; &#125; &#125; &#125; string ret; while (m &amp;&amp; n) &#123; if (parents[m][n] == 1) &#123; ret = a[m - 1] + ret; m--, n--; &#125; else if (parents[m][n] == 2) &#123; m--; &#125; else n--; &#125; return ret;&#125;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; helper(a, b) &lt;&lt; endl; return 0;&#125; Word Break Leetcode 139 Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. Note: The same word in the dictionary may be reused multiple times in the segmentation. You may assume the dictionary does not contain duplicate words. Example 1:123Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]Output: trueExplanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;. Example 2:1234Input: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]Output: trueExplanation: Return true because &quot;applepenapple&quot; can be segmented as &quot;apple pen apple&quot;. Note that you are allowed to reuse a dictionary word. Example 3:12Input: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output: false 1234567891011121314151617181920class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; if (wordDict.empty()) return false; int n = s.size(); vector&lt;bool&gt; dp(n + 1, false); dp[0] = true; for (int i = 0; i &lt;= n; i++) &#123; if (!dp[i]) continue; for (int j = i + 1; j &lt;= n; j++) &#123; string ans = s.substr(i, j - i); if (find(wordDict.begin(), wordDict.end(), ans) != wordDict.end()) &#123; dp[j] = true; &#125; &#125; &#125; return dp[n]; &#125;&#125;; Wiggle Subsequence Leetcode 376 A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence. For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero. Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order. Examples:12345678910Input: [1,7,4,9,2,5]Output: 6The entire sequence is a wiggle sequence.Input: [1,17,5,10,13,15,10,5,16,8]Output: 7There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].Input: [1,2,3,4,5,6,7,8,9]Output: 2 1234567891011class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; int f = 1, d = 1, n = nums.size(); for (int i = 1; i &lt; nums.size(); i++) &#123; if (nums[i] &gt; nums[i - 1]) f = d + 1; if (nums[i] &lt; nums[i - 1]) d = f + 1; &#125; return min(max(f, d), n); &#125;&#125;; Arithmetic Slices Leetcode 413 A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.12345678910111213141516For example, these are arithmetic sequence:1, 3, 5, 7, 97, 7, 7, 73, -1, -5, -9The following sequence is not arithmetic.1, 1, 2, 5, 7A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.A slice (P, Q) of array A is called arithmetic if the sequence:A[P], A[p + 1], ..., A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.The function should return the number of arithmetic slices in the array A. Example:123A = [1, 2, 3, 4]return: 3, for 3 arithmetic slices in A: [1, 2, 3], [2, 3, 4] and [1, 2, 3, 4] itself. 123456789101112131415class Solution &#123;public: int numberOfArithmeticSlices(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt; 3) return 0; int cur = nums[1] - nums[0] == nums[2] - nums[1] ? 1 : 0; int ret = cur; for (int i = 3; i &lt; n; i++) &#123; if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) cur ++; else cur = 0; ret += cur; &#125; return ret; &#125;&#125;; Regular Expression Matching Leetcode 10 Given an input string (s) and a pattern (p), implement regular expression matching with support for ‘.’ and ‘*’.123&apos;.&apos; Matches any single character.&apos;*&apos; Matches zero or more of the preceding element.The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like . or *. Example 1:12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2:12345Input:s = &quot;aa&quot;p = &quot;a*&quot;Output: trueExplanation: &apos;*&apos; means zero or more of the precedeng element, &apos;a&apos;. Therefore, by repeating &apos;a&apos; once, it becomes &quot;aa&quot;. Example 3:12345Input:s = &quot;ab&quot;p = &quot;.*&quot;Output: trueExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;. Example 4:12345Input:s = &quot;aab&quot;p = &quot;c*a*b&quot;Output: trueExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore it matches &quot;aab&quot;. Example 5:1234Input:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;Output: false 1234567891011121314151617181920212223242526272829class Solution &#123;public: bool isMatch(string s, string p) &#123; if (s.empty() &amp;&amp; p.empty()) return true; int m = s.size(), n = p.size(); bool dp[m + 1][n + 1]; memset(dp, false, sizeof(dp)); dp[0][0] = true; for (int i = 1; i &lt;= n; i++) &#123; dp[0][i] = p[i - 1] == '*' &amp;&amp; dp[0][i - 2]; &#125; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; if (p[j - 1] == '*') &#123; char c = p[j - 2]; if (c != '.' &amp;&amp; s[i - 1] != c) dp[i][j] = dp[i][j - 2]; else dp[i][j] = (dp[i][j - 2] || dp[i - 1][j] || dp[i - 1][j - 2]); // .* // 不匹配：dp[i][j - 2] // 匹配.：dp[i - 1][j - 2] // 匹配.*：dp[i - 1][j] 因为i-1不一定是由.匹配的可能是由*匹配的，所以用dp[i - 1][j] &#125; else dp[i][j] = (s[i - 1] == p[j - 1] || p[j - 1] == '.') &amp;&amp; dp[i - 1][j - 1]; &#125; &#125; return dp[m][n]; &#125;&#125;; Wildcard Matching Leetcode 44 Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’. ‘?’ Matches any single character.‘*’ Matches any sequence of characters (including the empty sequence).The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z.p could be empty and contains only lowercase letters a-z, and characters like ? or *. Example 1:12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2:12345Input:s = &quot;aa&quot;p = &quot;*&quot;Output: trueExplanation: &apos;*&apos; matches any sequence. Example 3:12345Input:s = &quot;cb&quot;p = &quot;?a&quot;Output: falseExplanation: &apos;?&apos; matches &apos;c&apos;, but the second letter is &apos;a&apos;, which does not match &apos;b&apos;. Example 4:12345Input:s = &quot;adceb&quot;p = &quot;*a*b&quot;Output: trueExplanation: The first &apos;*&apos; matches the empty sequence, while the second &apos;*&apos; matches the substring &quot;dce&quot;. Example 5:1234Input:s = &quot;acdcb&quot;p = &quot;a*c?b&quot;Output: false 123456789101112131415161718192021class Solution &#123;public: bool isMatch(string s, string p) &#123; if (s.empty() &amp;&amp; p.empty()) return true; int m = s.size(), n = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(m + 1, vector&lt;bool&gt;(n + 1, false)); dp[0][0] = true; for (int i = 1; i &lt;= n; i++) &#123; dp[0][i] = p[i - 1] == '*' &amp;&amp; dp[0][i - 1]; &#125; for (int i = 1; i &lt;= m; i++) &#123; char c = s[i - 1]; for (int j = 1; j &lt;= n; j++) &#123; char t = p[j - 1]; if (t == '?' || t == c) dp[i][j] = dp[i - 1][j - 1]; if (t == '*') dp[i][j] = dp[i - 1][j - 1] || dp[i][j - 1] || dp[i - 1][j]; &#125; &#125; return dp[m][n]; &#125;&#125;; Length of Longest Fibonacci Subsequence Leetcode 873 A sequence X_1, X_2, …, X_n is fibonacci-like if: n &gt;= 3 X_i + X_{i+1} = X_{i+2} for all i + 2 &lt;= n Given a strictly increasing array A of positive integers forming a sequence, find the length of the longest fibonacci-like subsequence of A. If one does not exist, return 0. (Recall that a subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].) Example 1:1234Input: [1,2,3,4,5,6,7,8]Output: 5Explanation:The longest subsequence that is fibonacci-like: [1,2,3,5,8]. Example 2:12345Input: [1,3,7,11,12,14,18]Output: 3Explanation:The longest subsequence that is fibonacci-like:[1,11,12], [3,11,14] or [7,11,18]. 12345678910111213141516171819202122232425class Solution &#123;public: int lenLongestFibSubseq(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (n &lt; 3) return 0; unordered_map&lt;int, int&gt; m; for (int i = 0; i &lt; n; i++) &#123; m[nums[i]] = i; &#125; vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(n + 1, 0)); int ret = 2; // 从后向前更新，将阶段的结果用于后面的过程 for (int i = n - 2; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt;= n; j++) &#123; dp[i][j] = 2; int ans = nums[i] + nums[j]; if (!m.count(ans)) continue; int k = m[ans]; dp[i][j] = dp[j][k] + 1; ret = max(dp[i][j], ret); &#125; &#125; return ret &gt;= 3 ? ret : 0; &#125;&#125;; 背包Ones and Zeroes Leetcode 474 In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue. For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s. Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once. Note: The given numbers of 0s and 1s will both not exceed 100 The size of given string array won’t exceed 600. Example 1:123Input: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3Output: 4Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0” Example 2:123Input: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1Output: 2Explanation: You could form &quot;10&quot;, but then you&apos;d have nothing left. Better form &quot;0&quot; and &quot;1&quot;. 1234567891011121314151617181920212223class Solution &#123;public: void helper(string s, int&amp; one, int&amp; zero) &#123; one = zero = 0; for (auto i : s) &#123; if (i == '0') zero ++; else one ++; &#125; &#125; int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) &#123; vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0)); for (auto s : strs) &#123; int o, z; helper(s, o, z); for (int i = m; i &gt;= z; i--) &#123; for (int j = n; j &gt;= o; j--) &#123; dp[i][j] = max(dp[i][j], dp[i - z][j - o] + 1); &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; Partition Equal Subset Sum Leetcode 416 Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Note: Each of the array element will not exceed 100. The array size will not exceed 200. Example 1:12345Input: [1, 5, 11, 5]Output: trueExplanation: The array can be partitioned as [1, 5, 5] and [11]. Example 2:12345Input: [1, 2, 3, 5]Output: falseExplanation: The array cannot be partitioned into equal sum subsets. 123456789101112131415161718class Solution &#123;public: bool canPartition(vector&lt;int&gt;&amp; nums) &#123; if (nums.size() &lt; 2) return false; int ans = 0; for (auto i : nums) ans += i; if (ans % 2) return false; int target = ans / 2; vector&lt;bool&gt; dp(target + 1, false); dp[0] = true; for (auto i : nums) &#123; for (int j = target; j &gt;= i; j--) &#123; dp[j] = dp[j] || dp[j - i]; &#125; &#125; return dp[target]; &#125;&#125;; 最长回文子序列 参考资料 12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;math.h&gt;using namespace std;int helper(string s) &#123; if (s.empty()) return 0; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; n; i++) &#123; dp[i][i] = 1; &#125; for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (s[i] == s[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; return dp[0][n - 1];&#125;int main() &#123; string s; cin &gt;&gt; s; cout &lt;&lt; helper(s) &lt;&lt; endl; return 0;&#125; 回文子序列个数12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int helper(string s) &#123; int n = s.size(); if (!n) return 0; vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; if (s[i] == s[j]) &#123; dp[i][j] = dp[i + 1][j] + dp[i][j + 1] + 1; &#125; else &#123; dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1]; &#125; &#125; &#125; return dp[0][n - 1];&#125;int main() &#123; string s; cin &gt;&gt; s; cout &lt;&lt; helper(s) &lt;&lt; endl; return 0;&#125;]]></content>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>OJ</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 搜索算法相关整理]]></title>
    <url>%2F2018%2F09%2F03%2Fleetcode-summary-search-algorithm%2F</url>
    <content type="text"><![CDATA[这里总结一些leetcode上比较经典的搜索类题目 快速搜索相关Kth Largest Element in an Array Leetcode 215 Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. 1234567Example 1:Input: [3,2,1,5,6,4] and k = 2Output: 5Example 2:Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int partition(vector&lt;int&gt;&amp; nums, int left, int right) &#123; int base = nums[left]; while (left &lt; right) &#123; // 挖坑填数方法 // 第一次的left被保存到了base中，之后直接将该位置赋值为right // 则下次再找到就会赋值到right位置上，此时right原来的数保存在了原来left中，原来left的值也保存下来 // 剩下的值就是缺一个第一次的left，最后赋值到left位置就可以了 while (left &lt; right &amp;&amp; nums[right] &lt;= base) right--; if (left &lt; right) nums[left] = nums[right]; while (left &lt; right &amp;&amp; nums[left] &gt; base) left ++; if (left &lt; right) nums[right] = nums[left]; &#125; nums[left] = base; return left; &#125; int qsearch(vector&lt;int&gt;&amp; nums, int left, int right, int k) &#123; // 要注意只剩下一个数据的情况 if (left &lt;= right) &#123; int mid = partition(nums, left, right); if (mid == k - 1) return nums[mid]; if (mid &lt; k - 1) return qsearch(nums, mid + 1, right, k); else return qsearch(nums, left, mid - 1, k); &#125; return -1; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); if (len &lt; k || k &lt; 1) return -1; return qsearch(nums, 0, len - 1, k); &#125;&#125;; Wiggle Sort II Leetcode 324 Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….1234567Example 1:Input: nums = [1, 5, 1, 1, 6, 4]Output: One possible answer is [1, 4, 1, 5, 1, 6].Example 2:Input: nums = [1, 3, 2, 2, 3, 1]Output: One possible answer is [2, 3, 1, 3, 1, 2]. 1234567891011121314class Solution &#123;public: void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; // 之所以这样是防止中间的部分重叠例如[4, 5, 5, 6] vector&lt;int&gt; ans(nums); sort(ans.begin(), ans.end()); int n = nums.size(); int l = (n + 1) / 2 - 1, r = n - 1; for (int i = 0; i &lt; n; i++) &#123; if (i &amp; 1) nums[i] = ans[r--]; else nums[i] = ans[l--]; &#125; &#125;&#125;; Follow Up: Can you do it in O(n) time and/or in-place with O(1) extra space? 主要思想是先用快速找到中间的数，然后利用快搜中partition的思想将前半数据放到奇数位上，后半段的数放入偶数位，解释可以参考Discuss12345678910111213141516171819202122void wiggleSort(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); // Find a median. auto midptr = nums.begin() + n / 2; nth_element(nums.begin(), midptr, nums.end()); int mid = *midptr; // Index-rewiring. #define A(i) nums[(1+2*(i)) % (n|1)] // 3-way-partition-to-wiggly in O(n) time with O(1) space. int i = 0, j = 0, k = n - 1; while (j &lt;= k) &#123; if (A(j) &gt; mid) swap(A(i++), A(j++)); else if (A(j) &lt; mid) swap(A(j), A(k--)); else j++; &#125;&#125; 并查集Longest Consecutive Sequence Leetcode 128 Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Your algorithm should run in O(n) complexity. Example:123Input: [100, 4, 200, 1, 3, 2]Output: 4Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. 12345678910111213141516171819class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; m; int ret = 0; for (auto i : nums) &#123; int l = 0, r = 0; // 此题借用了并查集的思想，将边缘的数据进行合并 // 找到就跳过，防止存在中间结果 if (m.find(i) != m.end()) continue; if (m.find(i - 1) != m.end()) l = m[i - 1]; if (m.find(i + 1) != m.end()) r = m[i + 1]; int ans = l + r + 1; ret = max(ret, ans); m[i] = m[i - l] = m[i + r] = ans; &#125; return ret; &#125;&#125;; BFSBFS因为占用的空间比较大且一般时间比较长，所以经常用在需要全部数据都要检索的题目上，一般的类型包括： 图上任意两点之间的距离 图的拓扑排序 树与层数相关的题目，例如树形图的直径，寻找根节点等 可能还有其他的类型，之后会来补充… Course Schedule （拓扑排序） Leetcode 207 There are a total of n courses you have to take, labeled from 0 to n-1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?123456789101112Example 1:Input: 2, [[1,0]] Output: trueExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible.Example 2:Input: 2, [[1,0],[0,1]]Output: falseExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible. 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: bool canFinish(int numCourses, vector&lt;pair&lt;int, int&gt;&gt;&amp; prerequisites) &#123; int ret = 0; unordered_map&lt;int, vector&lt;int&gt;&gt; adj; vector&lt;int&gt; cnt(numCourses, 0); for (auto i : prerequisites) &#123; cnt[i.first]++; adj[i.second].push_back(i.first); &#125; vector&lt;int&gt; next; for (int i = 0; i &lt; numCourses; i++) &#123; if (!cnt[i]) &#123; ret ++; next.push_back(i); &#125; &#125; while (!next.empty()) &#123; vector&lt;int&gt; cur; for (auto i : next) &#123; for (auto j : adj[i]) &#123; cnt[j]--; if (!cnt[j]) &#123; ret ++; cur.push_back(j); &#125; &#125; &#125; next = cur; &#125; return ret == numCourses; &#125;&#125;; Minimum Height Trees Leetcode 310 For a undirected graph with tree characteristics, we can choose any node as the root. The result graph is then a rooted tree. Among all possible rooted trees, those with minimum height are called minimum height trees (MHTs). Given such a graph, write a function to find all the MHTs and return a list of their root labels. FormatThe graph contains n nodes which are labeled from 0 to n - 1. You will be given the number n and a list of undirected edges (each edge is a pair of labels). You can assume that no duplicate edges will appear in edges. Since all edges are undirected, [0, 1] is the same as [1, 0] and thus will not appear together in edges. Example 1 :123456789Input: n = 4, edges = [[1, 0], [1, 2], [1, 3]] 0 | 1 / \ 2 3 Output: [1] Example 2 :1234567891011Input: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]] 0 1 2 \ | / 3 | 4 | 5 Output: [3, 4] 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; findMinHeightTrees(int n, vector&lt;pair&lt;int, int&gt;&gt;&amp; edges) &#123; if (n == 1) return vector&lt;int&gt;(&#123;0&#125;); vector&lt;unordered_set&lt;int&gt;&gt; adj(n, unordered_set&lt;int&gt;()); for (auto i : edges) &#123; int x = i.first, y = i.second; adj[x].insert(y); adj[y].insert(x); &#125; vector&lt;int&gt; cur; for (int i = 0; i &lt; n; i++) &#123; if (adj[i].size() == 1) cur.push_back(i); &#125; while (true) &#123; vector&lt;int&gt; next; for (auto i : cur) &#123; for (auto j : adj[i]) &#123; // 此处是细节，和拓扑排序不一样 // 因为此树形图是无向图，所以必须将反向的边删除 adj[j].erase(i); if (adj[j].size() == 1) next.push_back(j); &#125; &#125; if (next.empty()) break; else cur = next; &#125; return cur; &#125;&#125;; Reconstruct Itinerary Leetcode 332 Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].All airports are represented by three capital letters (IATA code).You may assume all tickets form at least one valid itinerary. Example 1:12Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;] Example 2:1234Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]. But it is larger in lexical order. 123456789101112131415161718192021222324252627282930// 欧拉环路class Solution &#123;public: vector&lt;string&gt; findItinerary(vector&lt;pair&lt;string, string&gt;&gt; tickets) &#123; unordered_map&lt;string, vector&lt;string&gt;&gt; m; for (auto i : tickets) &#123; m[i.first].push_back(i.second); &#125; for (auto &amp;i : m) &#123; sort(i.second.begin(), i.second.end()); &#125; vector&lt;string&gt; ret; stack&lt;string&gt; s; s.push("JFK"); while (!s.empty()) &#123; string ans = s.top(); if (m[ans].empty()) &#123; s.pop(); ret.push_back(ans); &#125; else &#123; s.push(m[ans][0]); m[ans].erase(m[ans].begin()); &#125; &#125; reverse(ret.begin(), ret.end()); return ret; &#125;&#125;; Populating Next Right Pointers in Each Node Leetcode 116 Given a binary tree12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. Note: You may only use constant extra space.Recursive approach is fine, implicit stack space does not count as extra space for this problem.You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children). Example:1234567891011121314Given the following perfect binary tree, 1 / \ 2 3 / \ / \4 5 6 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ / \4-&gt;5-&gt;6-&gt;7 -&gt; NULL 1234567891011121314151617181920212223242526/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) return; TreeLinkNode* pre = root; pre-&gt;next = NULL; while (pre-&gt;left) &#123; TreeLinkNode* temp = pre; while (pre) &#123; pre-&gt;left-&gt;next = pre-&gt;right; if (pre-&gt;next) pre-&gt;right-&gt;next = pre-&gt;next-&gt;left; else pre-&gt;right-&gt;next = NULL; pre = pre-&gt;next; &#125; pre = temp-&gt;left; &#125; &#125;&#125;; DFSBinary Tree Maximum Path Sum Leetcode 124 Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example 1:1234567Input: [1,2,3] 1 / \ 2 3Output: 6 Example 2:123456789Input: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7Output: 42 1234567891011121314151617181920212223242526/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int helper(TreeNode* root, int&amp; ret) &#123; if (!root) return 0; // 此题用了贪心的思路，如果路径上的和为负，则就可以删掉这段路径 // 因此可以满足任意两点之间路径和最大的值，而不用考虑是不是从叶子节点开始 int l = max(0, helper(root-&gt;left, ret)); int r = max(0, helper(root-&gt;right, ret)); ret = max(ret, l + r + root-&gt;val); return max(l, r) + root-&gt;val; &#125; int maxPathSum(TreeNode* root) &#123; int ret = INT_MIN; helper(root, ret); return ret; &#125;&#125;; Kth Smallest Element in a BST Leetcode 230 Given a binary search tree, write a function kthSmallest to find the kth smallest element in it. Note:You may assume k is always valid, 1 ≤ k ≤ BST’s total elements. Example 1:1234567Input: root = [3,1,4,null,2], k = 1 3 / \ 1 4 \ 2Output: 1 Example 2:123456789Input: root = [5,3,6,2,4,null,null,1], k = 3 5 / \ 3 6 / \ 2 4 / 1Output: 3 123456789101112131415161718192021/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int helper(TreeNode* root, int&amp; k) &#123; if (!root) return 0; int x = helper(root-&gt;left, k); return !k ? x : (!--k ? root-&gt;val : helper(root-&gt;right, k)); &#125; int kthSmallest(TreeNode* root, int k) &#123; if (!root) return -1; return helper(root, k); &#125;&#125;; Generate Parentheses Leetcode 22 Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is:1234567[ &quot;((()))&quot;, &quot;(()())&quot;, &quot;(())()&quot;, &quot;()(())&quot;, &quot;()()()&quot;] 123456789101112131415class Solution &#123;public: void helper(int i, int j, int n, string ans, vector&lt;string&gt;&amp; ret) &#123; if (j != i) helper(i, j + 1, n, ans + ")", ret); if (i != n) helper(i + 1, j, n, ans + "(", ret); if (j == n) ret.push_back(ans); &#125; vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; ret; if (n &lt; 1) return ret; helper(0, 0, n, "", ret); return ret; &#125;&#125;; House Robber III Leetcode 337 The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the “root.” Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that “all houses in this place forms a binary tree”. It will automatically contact the police if two directly-linked houses were broken into on the same night. Determine the maximum amount of money the thief can rob tonight without alerting the police. Example 1:12345678910Input: [3,2,3,null,3,null,1] 3 / \ 2 3 \ \ 3 1Output: 7 Explanation: Maximum amount of money the thief can rob = 3 + 3 + 1 = 7. Example 2:12345678910Input: [3,4,5,1,3,null,1] 3 / \ 4 5 / \ \ 1 3 1Output: 9Explanation: Maximum amount of money the thief can rob = 4 + 5 = 9. 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public:// 不一定是隔一行，也可能是左右子树所在行不一样，但是max保证了一定是隔着的 int helper(TreeNode* root, int&amp; l, int&amp; r) &#123; if (!root) return 0; int ll = 0, lr = 0, rl = 0, rr = 0; l = helper(root-&gt;left, ll, lr); r = helper(root-&gt;right, rl, rr); return max(ll + lr + rl + rr + root-&gt;val, l + r); &#125; int rob(TreeNode* root) &#123; int l, r; return helper(root, l, r); &#125;&#125;; Decode String Leetcode 394 Given an encoded string, return it’s decoded string. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer. You may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won’t be input like 3a or 2[4]. Examples:123s = &quot;3[a]2[bc]&quot;, return &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, return &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, return &quot;abcabccdcdcdef&quot;. 12345678910111213141516171819202122232425class Solution &#123;public: string helper(string s, int&amp; index) &#123; string ret; int n = s.size(); while (index &lt; n &amp;&amp; s[index] != ']') &#123; if (isdigit(s[index])) &#123; int cnt = 0; while (s[index] != '[') cnt = cnt * 10 + (s[index++] - '0'); index ++; string ans = helper(s, index); index ++; for (int i = 0; i &lt; cnt; i++) ret += ans; &#125; else &#123; ret.push_back(s[index++]); &#125; &#125; return ret; &#125; string decodeString(string s) &#123; int index = 0; return helper(s, index); &#125;&#125;; Matchsticks to Square Leetcode 473 Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time. Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has. Example 1:123Input: [1,1,2,2,2]Output: trueExplanation: You can form a square with length 2, one side of the square came two sticks with length 1. Example 2:1234Input: [3,3,3,3,4]Output: falseExplanation: You cannot find a way to form a square with all the matchsticks. 12345678910111213141516171819202122232425class Solution &#123;public: bool helper(vector&lt;int&gt;&amp; ans, vector&lt;int&gt;&amp; nums, int index, int target) &#123; int n = nums.size(); if (index == n) &#123; return ans[0] == target &amp;&amp; ans[1] == target &amp;&amp; ans[2] == target; &#125; for (int i = 0; i &lt; 4; i++) &#123; if (ans[i] + nums[index] &gt; target) continue; ans[i] += nums[index]; if (helper(ans, nums, index + 1, target)) return true; ans[i] -= nums[index]; &#125; return false; &#125; bool makesquare(vector&lt;int&gt;&amp; nums) &#123; int target = 0; for (auto i : nums) target += i; if (target % 4 != 0 || nums.size() &lt; 4) return false; sort(nums.rbegin(), nums.rend()); vector&lt;int&gt; ans(4, 0); return helper(ans, nums, 0, target / 4); &#125;&#125;; follow up: Partition to K Equal Sum Subsets Leetcode 698 Given an array of integers nums and a positive integer k, find whether it’s possible to divide this array into k non-empty subsets whose sums are all equal. Example 1:123Input: nums = [4, 3, 2, 3, 5, 2, 1], k = 4Output: TrueExplanation: It&apos;s possible to divide it into 4 subsets (5), (1, 4), (2,3), (2,3) with equal sums. 1234567891011121314151617181920212223242526class Solution &#123;public: bool helper(vector&lt;int&gt; ans, int index, vector&lt;int&gt;&amp; nums, int target) &#123; int k = ans.size(), n = nums.size(); if (index == n) &#123; for (int i = 0; i &lt; k; i++) &#123; if (ans[i] != target) return false; &#125; return true; &#125; for (int i = 0; i &lt; k; i++) &#123; if (ans[i] + nums[index] &gt; target) continue; ans[i] += nums[index]; if (helper(ans, index + 1, nums, target)) return true; ans[i] -= nums[index]; &#125; return false; &#125; bool canPartitionKSubsets(vector&lt;int&gt;&amp; nums, int k) &#123; int ans = 0, n = nums.size(); for (auto i : nums) ans += i; if (n &lt; k || ans % k) return false; sort(nums.begin(), nums.end(), greater&lt;int&gt;()); return helper(vector&lt;int&gt;(k, 0), 0, nums, ans / k); &#125;&#125;; Subsets II Leetcode 90 DescriptionHintsSubmissionsDiscussSolutionGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example:12345678910Input: [1,2,2]Output:[ [2], [1], [1,2,2], [2,2], [1,2], []] 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; ret.push_back(vector&lt;int&gt;()); if (nums.empty()) return ret; sort(nums.begin(), nums.end()); int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; int index = 0; while (i + index &lt; n &amp;&amp; nums[i] == nums[i + index]) index ++; int len = ret.size(); for (int j = 0; j &lt; len; j++) &#123; auto temp = ret[j]; for (int k = 0; k &lt; index; k++) &#123; temp.push_back(nums[i]); ret.push_back(temp); &#125; &#125; i += index - 1; &#125; return ret; &#125;&#125;; Word Search Leetcode 79 DescriptionHintsSubmissionsDiscussSolutionGiven a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. Example:12345678910board =[ [&apos;A&apos;,&apos;B&apos;,&apos;C&apos;,&apos;E&apos;], [&apos;S&apos;,&apos;F&apos;,&apos;C&apos;,&apos;S&apos;], [&apos;A&apos;,&apos;D&apos;,&apos;E&apos;,&apos;E&apos;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false. 12345678910111213141516171819202122232425262728class Solution &#123;public: bool helper(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word, int index, int x, int y) &#123; // 尽量在helper函数中做相等判断，否则还需要在外层函数中实现相等判断和访问覆盖操作 if (word[index] != board[x][y]) return false; int len = word.size(), m = board.size(), n = board[0].size(); if (index == len - 1) return true; int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; board[x][y] = '\0'; for (int i = 0; i &lt; 4; i++) &#123; int X = x + a[i], Y = y + b[i]; if (X &gt;= 0 &amp;&amp; X &lt; m &amp;&amp; Y &gt;= 0 &amp;&amp; Y &lt; n &amp;&amp; helper(board, word, index + 1, X, Y)) return true; &#125; board[x][y] = word[index]; return false; &#125; bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) &#123; if (board.empty() || board[0].empty()) return false; if (word.empty()) return true; int m = board.size(), n = board[0].size(); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (helper(board, word, 0, i, j)) return true; &#125; &#125; return false; &#125;&#125;; Longest Increasing Path in a Matrix Leetcode 329 Given an integer matrix, find the length of the longest increasing path. From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed). Example 1:12345678Input: nums = [ [9,9,4], [6,6,8], [2,1,1]] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9]. Example 2:12345678Input: nums = [ [3,4,5], [3,2,6], [2,2,1]] Output: 4 Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed. 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int helper(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;vector&lt;int&gt;&gt;&amp; ma, int x, int y) &#123; if (ma[x][y]) return ma[x][y]; int ans = matrix[x][y]; int m = matrix.size(), n = matrix[0].size(); int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; for (int i = 0; i &lt; 4; i++) &#123; int X = x + a[i], Y = y + b[i]; if (X &gt;= 0 &amp;&amp; X &lt; m &amp;&amp; Y &gt;= 0 &amp;&amp; Y &lt; n) &#123; int local = 1; if (matrix[X][Y] &gt; ans) &#123; local += helper(matrix, ma, X, Y); &#125; ma[x][y] = max(local, ma[x][y]); &#125; &#125; return ma[x][y]; &#125; int longestIncreasingPath(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int ret = 1; if (matrix.empty() || matrix[0].empty()) return 0; int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;int&gt;&gt; ma(m, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; ret = max(ret, helper(matrix, ma, i, j)); &#125; &#125; return ret; &#125;&#125;; Word Break II Leetcode 140 Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences. Note: The same word in the dictionary may be reused multiple times in the segmentation.You may assume the dictionary does not contain duplicate words. Example 1:12345678Input:s = &quot;catsanddog&quot;wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]Output:[ &quot;cats and dog&quot;, &quot;cat sand dog&quot;] Example 2:12345678910Input:s = &quot;pineapplepenapple&quot;wordDict = [&quot;apple&quot;, &quot;pen&quot;, &quot;applepen&quot;, &quot;pine&quot;, &quot;pineapple&quot;]Output:[ &quot;pine apple pen apple&quot;, &quot;pineapple pen apple&quot;, &quot;pine applepen apple&quot;]Explanation: Note that you are allowed to reuse a dictionary word. Example 3:12345Input:s = &quot;catsandog&quot;wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]Output:[] 12345678910111213141516171819202122232425262728293031class Solution &#123;public: void merge(vector&lt;string&gt; ans, string word, vector&lt;string&gt;&amp; ret) &#123; for (auto i : ans) &#123; ret.push_back(word + " " + i); &#125; &#125; vector&lt;string&gt; helper(string s, unordered_set&lt;string&gt;&amp; dict, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; m) &#123; if (m.find(s) != m.end()) return m[s]; vector&lt;string&gt; ret; if (dict.find(s) != dict.end()) ret.push_back(s); int n = s.size(); for (int i = 0; i &lt; n; i++) &#123; string word = s.substr(0, i); if (dict.find(word) == dict.end()) continue; string rem = s.substr(i); merge(helper(rem, dict, m), word, ret); &#125; m[s] = ret; return ret; &#125; vector&lt;string&gt; wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; dict; unordered_map&lt;string, vector&lt;string&gt;&gt; m; for (auto i : wordDict) &#123; dict.insert(i); &#125; return helper(s, dict, m); &#125;&#125;; Add and Search Word - Data structure design Leetcode 211 Design a data structure that supports the following two operations: void addWord(word)bool search(word)search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. Example:1234567addWord(&quot;bad&quot;)addWord(&quot;dad&quot;)addWord(&quot;mad&quot;)search(&quot;pad&quot;) -&gt; falsesearch(&quot;bad&quot;) -&gt; truesearch(&quot;.ad&quot;) -&gt; truesearch(&quot;b..&quot;) -&gt; true 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct TrieNode &#123; TrieNode* child[26]; bool isKey; TrieNode() : isKey(false) &#123; memset(child, NULL, sizeof(child)); &#125;&#125;;class WordDictionary &#123;public: TrieNode* root; /** Initialize your data structure here. */ WordDictionary() &#123; root = new TrieNode(); &#125; /** Adds a word into the data structure. */ void addWord(string word) &#123; TrieNode* cur = root; for (auto i : word) &#123; int c = i - 'a'; if (!cur-&gt;child[c]) cur-&gt;child[c] = new TrieNode(); cur = cur-&gt;child[c]; &#125; cur-&gt;isKey = true; &#125; bool helper(string s, int index, TrieNode* cur) &#123; int n = s.size(); for (int i = index; i &lt; n; i++) &#123; if (s[i] == '.') &#123; for (int j = 0; j &lt; 26; j++) &#123; if (cur-&gt;child[j] &amp;&amp; helper(s, i + 1, cur-&gt;child[j])) return true; &#125; return false; &#125; int c = s[i] - 'a'; if (!cur-&gt;child[c]) return false; cur = cur-&gt;child[c]; &#125; return cur &amp;&amp; cur-&gt;isKey; &#125; /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */ bool search(string word) &#123; return helper(word, 0, root); &#125;&#125;;/** * Your WordDictionary object will be instantiated and called as such: * WordDictionary obj = new WordDictionary(); * obj.addWord(word); * bool param_2 = obj.search(word); */ Reconstruct Itinerary Leetcode 332 Given a list of airline tickets represented by pairs of departure and arrival airports [from, to], reconstruct the itinerary in order. All of the tickets belong to a man who departs from JFK. Thus, the itinerary must begin with JFK. Note: If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string. For example, the itinerary [“JFK”, “LGA”] has a smaller lexical order than [“JFK”, “LGB”].All airports are represented by three capital letters (IATA code).You may assume all tickets form at least one valid itinerary. Example 1:12Input: [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]Output: [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;] Example 2:1234Input: [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]Output: [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;]Explanation: Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;]. But it is larger in lexical order. 1234567891011121314151617181920212223242526272829303132// dfs 版本class Solution &#123;public: void helper(vector&lt;string&gt;&amp; ret, unordered_map&lt;string, vector&lt;string&gt;&gt;&amp; m, int n) &#123; if (ret.size() == n) return; string ans = ret.back(); for (int i = 0; i &lt; m[ans].size(); i++) &#123; string temp = m[ans][i]; ret.push_back(temp); m[ans].erase(m[ans].begin() + i); helper(ret, m, n); if (ret.size() == n) return; ret.pop_back(); m[ans].insert(m[ans].begin() + i, temp); &#125; &#125; vector&lt;string&gt; findItinerary(vector&lt;pair&lt;string, string&gt;&gt; tickets) &#123; vector&lt;string&gt; ret; int n = tickets.size() + 1; unordered_map&lt;string, vector&lt;string&gt;&gt; m; for (auto i : tickets) &#123; m[i.first].push_back(i.second); &#125; for (auto&amp; i : m) &#123; sort(i.second.begin(), i.second.end()); &#125; ret.push_back("JFK"); helper(ret, m, n); if (ret.size() == n) return ret; else return vector&lt;string&gt;(); &#125;&#125;; Construct Binary Tree from Inorder and Postorder Traversal Leetcode 106 Given inorder and postorder traversal of a tree, construct the binary tree. Note:You may assume that duplicates do not exist in the tree. For example, given123456789inorder = [9,3,15,20,7]postorder = [9,15,7,20,3]Return the following binary tree: 3 / \ 9 20 / \ 15 7 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */typedef vector&lt;int&gt;::iterator Iter;class Solution &#123;public: TreeNode* helper(Iter ibegin, Iter iend, Iter pbegin, Iter pend) &#123; if (ibegin == iend) return NULL; int val = *(pend - 1); Iter mid = find(ibegin, iend, val); TreeNode* ret = new TreeNode(val); ret-&gt;left = helper(ibegin, mid, pbegin, pbegin + (mid - ibegin)); ret-&gt;right = helper(mid + 1, iend, pbegin + (mid - ibegin), pend - 1); return ret; &#125; TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) &#123; return helper(inorder.begin(), inorder.end(), postorder.begin(), postorder.end()); &#125;&#125;; Restore IP Addresses Leetcode 93 Given a string containing only digits, restore it by returning all possible valid IP address combinations. Example:12Input: &quot;25525511135&quot;Output: [&quot;255.255.11.135&quot;, &quot;255.255.111.35&quot;] 1234567891011121314151617181920212223242526class Solution &#123;public: void helper(string s, int index, vector&lt;string&gt;&amp; ret, vector&lt;int&gt; ans) &#123; if (ans.size() == 4 &amp;&amp; index == s.size()) &#123; ret.push_back(to_string(ans[0]) + "." + to_string(ans[1]) + "." + to_string(ans[2]) + "." + to_string(ans[3])); return; &#125; if (ans.size() &lt; 4 &amp;&amp; index &lt; s.size()) &#123; int temp = 0, n = s.size(); for (int i = 0; i &lt; 3 &amp;&amp; index + i &lt; n ; i++) &#123; if (i &amp;&amp; !temp) return; temp = temp * 10 + (s[index + i] - '0'); if (temp &lt;= 255) &#123; ans.push_back(temp); helper(s, index + i + 1, ret, ans); ans.pop_back(); &#125; &#125; &#125; &#125; vector&lt;string&gt; restoreIpAddresses(string s) &#123; vector&lt;string&gt; ret; helper(s, 0, ret, vector&lt;int&gt;()); return ret; &#125;&#125;; Different Ways to Add Parentheses Leetcode 241 Given a string of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. The valid operators are +, - and *. Example 1:12345Input: &quot;2-1-1&quot;Output: [0, 2]Explanation: ((2-1)-1) = 0 (2-(1-1)) = 2 Example 2:12345678Input: &quot;2*3-4*5&quot;Output: [-34, -14, -10, -10, 10]Explanation: (2*(3-(4*5))) = -34 ((2*3)-(4*5)) = -14 ((2*(3-4))*5) = -10 (2*((3-4)*5)) = -10 (((2*3)-4)*5) = 10 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; diffWaysToCompute(string input) &#123; vector&lt;int&gt; ret; for (int i = 0; i &lt; input.size(); i++) &#123; if (ispunct(input[i])) &#123; auto c = input[i]; for (auto a : diffWaysToCompute(input.substr(0, i))) &#123; for (auto b : diffWaysToCompute(input.substr(i + 1))) &#123; ret.push_back(c == '+' ? a + b : (c == '-' ? a - b : a * b)); &#125; &#125; &#125; &#125; return ret.empty() ? vector&lt;int&gt;(&#123;stoi(input)&#125;) : ret; &#125;&#125;; Palindrome Partitioning Leetcode 131 Given a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s. Example:123456Input: &quot;aab&quot;Output:[ [&quot;aa&quot;,&quot;b&quot;], [&quot;a&quot;,&quot;a&quot;,&quot;b&quot;]] 123456789101112131415161718192021222324252627class Solution &#123;public: void helper(vector&lt;vector&lt;string&gt;&gt;&amp; ret, vector&lt;string&gt; ans, int index, string s) &#123; int n = s.size(); if (index == n) &#123; ret.push_back(ans); return; &#125; for (int i = index; i &lt; n; i++) &#123; int l = index, r = i; while (l &lt; r &amp;&amp; s[l] == s[r]) l++, r--; if (l &gt;= r) &#123; ans.push_back(s.substr(index, i - index + 1)); helper(ret, ans, i + 1, s); ans.pop_back(); &#125; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; partition(string s) &#123; vector&lt;vector&lt;string&gt;&gt; ret; if (s.empty()) return ret; helper(ret, vector&lt;string&gt;(), 0, s); return ret; &#125;&#125;; Permutations II Leetcode Given a collection of numbers that might contain duplicates, return all possible unique permutations. Example:1234567Input: [1,1,2]Output:[ [1,1,2], [1,2,1], [2,1,1]] 12345678910111213141516171819202122class Solution &#123;public: void helper(int index, vector&lt;int&gt; ans, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; int n = ans.size(); if (index == n - 1) &#123; ret.push_back(ans); return; &#125; for (int i = index; i &lt; n; i++) &#123; if (index != i &amp;&amp; ans[i] == ans[index]) continue; swap(ans[i], ans[index]); helper(index + 1, ans, ret); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (nums.empty()) return ret; sort(nums.begin(), nums.end()); helper(0, nums, ret); return ret; &#125;&#125;; Permutation Sequence Leetcode 60 The set [1,2,3,…,n] contains a total of n! unique permutations. By listing and labeling all of the permutations in order, we get the following sequence for n = 3:1234567&quot;123&quot;&quot;132&quot;&quot;213&quot;&quot;231&quot;&quot;312&quot;&quot;321&quot;Given n and k, return the kth permutation sequence. Note: Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive. Example 1:12Input: n = 3, k = 3Output: &quot;213&quot; Example 2:12Input: n = 4, k = 9Output: &quot;2314&quot; 12345678910111213141516171819202122232425class Solution &#123;public: string getPermutation(int n, int k) &#123; if (n &lt; 1) return ""; vector&lt;int&gt; fac(n, 1); vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; nums[i] = i + 1; &#125; for (int i = 1; i &lt; n; i++) &#123; fac[i] = fac[i - 1] * i; &#125; string ret; for (int i = 0; i &lt; n; i++) &#123; int index = (k - 1) / fac[n - i - 1]; ret += to_string(nums[index]); nums.erase(nums.begin() + index); k -= index * fac[n - 1 - i]; &#125; return ret; &#125;&#125;; 12345678910111213141516171819202122232425// next permutation 版本class Solution &#123;public: void next_permutation(string&amp; s) &#123; int n = s.size(); int i = n - 2; while (i &gt;= 0 &amp;&amp; s[i] &gt;= s[i + 1]) i--; if (i &gt;= 0) &#123; int j = n - 1; while (s[j] &lt;= s[i]) j --; swap(s[j], s[i]); &#125; reverse(s.begin() + i + 1, s.end()); &#125; string getPermutation(int n, int k) &#123; string ret; for (int i = 1; i &lt;= n; i++) &#123; ret = ret + to_string(i);; &#125; for (int i = 0; i &lt; k - 1; i++) &#123; next_permutation(ret); &#125; return ret; &#125;&#125;; 二分查找 二分查找一般用来简化查找逻辑，将O(n)降低成O(logn)，但是由于左右边界更新的细节比较多，每个题都需要单独推导分析 Missing Number Leetcode 268 Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. Example 1:12Input: [3,0,1]Output: 2 Example 2:12Input: [9,6,4,2,3,5,7,0,1]Output: 8 1234567891011121314// 除此之外还有循环替换算法以及位操作算法class Solution &#123;public: int missingNumber(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end()); int left = 0, right = nums.size(); while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == mid) left = mid + 1; else right = mid; &#125; return left; &#125;&#125;; Search a 2D Matrix Leetcode 74 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right. The first integer of each row is greater than the last integer of the previous row. Example 1:12345678Input:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 3Output: true Example 2:12345678Input:matrix = [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]]target = 13Output: false 123456789101112131415// 线性扫描class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty() || matrix[0].empty()) return false; int m = matrix.size(), n = matrix[0].size(); int i = 0, j = n - 1; while (i &lt; m &amp;&amp; j &gt;= 0) &#123; if (matrix[i][j] == target) return true; if (matrix[i][j] &gt; target) j--; else i ++; &#125; return false; &#125;&#125;; 1234567891011121314151617181920212223242526// 二分法class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty() || matrix[0].empty()) return false; int m = matrix.size(), n = matrix[0].size(); int low = 0, high = m - 1; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; if (matrix[mid][0] &gt; target) high = mid - 1; else if (matrix[mid][n - 1] &lt; target) low = mid + 1; else &#123; int left = 0, right = n - 1; while (left &lt;= right) &#123; int m = left + (right - left) / 2; int x = matrix[mid][m]; if (x == target) return true; if (x &lt; target) left = m + 1; else right = m - 1; &#125; return false; &#125; &#125; return false; &#125;&#125;; Search a 2D Matrix II Leetcode 240 Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted in ascending from left to right. Integers in each column are sorted in ascending from top to bottom. Example:123456789101112Consider the following matrix:[ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30]]Given target = 5, return true.Given target = 20, return false. 12345678910111213141516171819// 其实也就是二分查找的思想，右侧路过的值就是查找空间的上界，左侧路过的值是下界// 查找不到就是左侧和右侧不重叠会始终找不到，从而超过边界退出循环// 此处不是像惯性思维的i,j封闭了左侧封锁了搜索空间class Solution &#123;public: bool searchMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int target) &#123; if (matrix.empty() || matrix[0].empty()) return false; int m = matrix.size(), n = matrix[0].size(); int i = 0, j = n - 1; while (i &lt; m &amp;&amp; j &gt;= 0) &#123; int x = matrix[i][j]; if (x == target) return true; if (x &lt; target) i++; else j --; &#125; return false; &#125;&#125;; Kth Smallest Element in a Sorted Matrix Leetcode 378 Given a n x n matrix where each of the rows and columns are sorted in ascending order, find the kth smallest element in the matrix. Note that it is the kth smallest element in the sorted order, not the kth distinct element. Example:12345678matrix = [ [ 1, 5, 9], [10, 11, 13], [12, 13, 15]],k = 8,return 13. 12345678910111213141516171819202122// upper_bound是找到大于该值的第一个数，lower_bound是找到大于等于该值的第一个数class Solution &#123;public: int kthSmallest(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int k) &#123; if (matrix.empty() || matrix[0].empty()) -1; int m = matrix.size(), n = matrix[0].size(); int left = matrix[0][0], right = matrix[m - 1][n - 1]; while (left &lt; right) &#123; int mid = left + (right - left) / 2; int cnt = 0; for (int i = 0; i &lt; m; i++) &#123; cnt += (int)(upper_bound(matrix[i].begin(), matrix[i].end(), mid) - matrix[i].begin()); &#125; if (cnt &lt; k) &#123; // 如果不满足等于k，则left会一直向后扩直至取到矩阵中的值 left = mid + 1; &#125; else right = mid; &#125; return left; &#125;&#125;; Median of Two Sorted Arrays Leetcode 4 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1:1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2:1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 1234567891011121314151617181920typedef vector&lt;int&gt;::iterator Iter;class Solution &#123;public: int helper(Iter l, int m, Iter r, int n, int k) &#123; if (!m) return r[k - 1]; if (!n) return l[k - 1]; if (k == 1) return min(l[0], r[0]); int i = min(m, k / 2), j = min(n, k / 2); if (l[i - 1] &lt; r[j - 1]) return helper(l + i, m - i, r, n, k - i); else return helper(l, m, r + j, n - j, k - j); &#125; double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int n1 = nums1.size(), n2 = nums2.size(); int a = helper(nums1.begin(), n1, nums2.begin(), n2, (n1 + n2 + 1) / 2); int b = helper(nums1.begin(), n1, nums2.begin(), n2, (n1 + n2 + 2) / 2); return (a + b) / 2.0; &#125;&#125;; Find Right Interval Leetcode 436 Given a set of intervals, for each of the interval i, check if there exists an interval j whose start point is bigger than or equal to the end point of the interval i, which can be called that j is on the “right” of i. For any interval i, you need to store the minimum interval j’s index, which means that the interval j has the minimum start point to build the “right” relationship for interval i. If the interval j doesn’t exist, store -1 for the interval i. Finally, you need output the stored value of each interval as an array. Note:You may assume the interval’s end point is always bigger than its start point.You may assume none of these intervals have the same start point. Example 1:12345Input: [ [1,2] ]Output: [-1]Explanation: There is only one interval in the collection, so it outputs -1. Example 2:1234567Input: [ [3,4], [2,3], [1,2] ]Output: [-1, 0, 1]Explanation: There is no satisfied &quot;right&quot; interval for [3,4].For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point;For [1,2], the interval [2,3] has minimum-&quot;right&quot; start point. Example 3:123456Input: [ [1,4], [2,3], [3,4] ]Output: [-1, 2, -1]Explanation: There is no satisfied &quot;right&quot; interval for [1,4] and [3,4].For [2,3], the interval [3,4] has minimum-&quot;right&quot; start point. 1234567891011121314151617181920212223242526/** * Definition for an interval. * struct Interval &#123; * int start; * int end; * Interval() : start(0), end(0) &#123;&#125; * Interval(int s, int e) : start(s), end(e) &#123;&#125; * &#125;; */class Solution &#123;public:// map的upper_bound和lower_bound是使用二分查找 vector&lt;int&gt; findRightInterval(vector&lt;Interval&gt;&amp; intervals) &#123; int n = intervals.size(); vector&lt;int&gt; ret(n, -1); map&lt;int, int&gt; m; for (int i = 0; i &lt; n; i++) &#123; m[intervals[i].start] = i; &#125; for (int i = 0; i &lt; n; i++) &#123; auto cur = m.lower_bound(intervals[i].end); if (cur != m.end()) ret[i] = cur-&gt;second; &#125; return ret; &#125;&#125;; Find First and Last Position of Element in Sorted Array Leetcode 34 Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value. Your algorithm’s runtime complexity must be in the order of O(log n). If the target is not found in the array, return [-1, -1]. Example 1:12Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4] Example 2:12Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1] 12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; searchRange(vector&lt;int&gt;&amp; nums, int target) &#123; // 此题是推导更新公式最典型的题目 vector&lt;int&gt; ret(2, -1); if (nums.empty()) return ret; int n = nums.size(); int left = 0, right = n - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &lt; target) left = mid + 1; else right = mid; &#125; if (nums[left] != target) return ret; else ret[0] = left; right = n - 1; while (left &lt;= right) &#123; // 等号是防止单元素 int mid = left + (right - left) / 2; if (nums[mid] &gt; target) right = mid - 1; else &#123; ret[1] = mid; left = mid + 1; &#125; &#125; return ret; &#125;&#125;; Find Minimum in Rotated Sorted Array Leetcode 153 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). Find the minimum element. You may assume no duplicate exists in the array. Example 1:12Input: [3,4,5,1,2] Output: 1 Example 2:12Input: [4,5,6,7,0,1,2]Output: 0 1234567891011121314class Solution &#123;public: int findMin(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return -1; int n = nums.size(); int left = 0, right = n - 1; while (left &lt; right) &#123; int mid = left + (right - left) / 2; if (nums[mid] &gt; nums[right]) left = mid + 1; else right = mid; &#125; return nums[left]; &#125;&#125;; Search in Rotated Sorted Array Leetcode 33 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. Your algorithm’s runtime complexity must be in the order of O(log n). Example 1:12Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4 Example 2:12Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1 123456789101112131415161718192021222324class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.empty()) return -1; int n = nums.size(); int left = 0, right = n - 1; while (left &lt;= right) &#123; // 更新过程可能存在1，【2】这种情况， // 所以需要在更新了left之后指向同一个数依旧生效 int mid = left + (right - left) / 2; if (nums[mid] == target) return mid; if (nums[mid] &gt; nums[right]) &#123; if (nums[mid] &gt; target &amp;&amp; nums[right] &lt; target) right = mid - 1; else left = mid + 1; &#125; else &#123; // 因为是nums[mid] &lt;= nums[right]，所以可能存在nums[right] == target if (nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target) left = mid + 1; else right = mid - 1; &#125; &#125; return -1; &#125;&#125;; Search in Rotated Sorted Array II Leetcode 81 Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand. (i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]). You are given a target value to search. If found in the array return true, otherwise return false. Example 1:12Input: nums = [2,5,6,0,0,1,2], target = 0Output: true Example 2:12Input: nums = [2,5,6,0,0,1,2], target = 3Output: false Follow up: This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates. Would this affect the run-time complexity? How and why? 12345678910111213141516171819202122232425class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; if (nums.empty()) return false; int n = nums.size(); int left = 0, right = n - 1; while (left &lt;= right) &#123; int mid = left + (right - left) / 2; if (nums[mid] == target) return true; // 与上一题的区别在于，因为需要根据mid和right的大小判断target处于哪个区间， // 所以需要更新一下右边界 if (nums[mid] == nums[right]) right --; else if (nums[mid] &gt; nums[right]) &#123; if (nums[mid] &gt; target &amp;&amp; nums[right] &lt; target) right = mid - 1; else left = mid + 1; &#125; else &#123; if (nums[mid] &lt; target &amp;&amp; nums[right] &gt;= target) left = mid + 1; else right = mid - 1; &#125; &#125; return false; &#125;&#125;; Koko Eating Bananas (*) Leetcode 875 Koko loves to eat bananas. There are N piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in H hours. Koko can decide her bananas-per-hour eating speed of K. Each hour, she chooses some pile of bananas, and eats K bananas from that pile. If the pile has less than K bananas, she eats all of them instead, and won’t eat any more bananas during this hour. Koko likes to eat slowly, but still wants to finish eating all the bananas before the guards come back. Return the minimum integer K such that she can eat all the bananas within H hours. Example 1:12Input: piles = [3,6,7,11], H = 8Output: 4 Example 2:12Input: piles = [30,11,23,4,20], H = 5Output: 30 Example 3:12Input: piles = [30,11,23,4,20], H = 6Output: 23 Note: 1 &lt;= piles.length &lt;= 10^4 piles.length &lt;= H &lt;= 10^9 1 &lt;= piles[i] &lt;= 10^9 1234567891011121314151617181920212223// 二分的实际应用，用来寻找最优值class Solution &#123;public: int minEatingSpeed(vector&lt;int&gt;&amp; piles, int H) &#123; int mx = 0; for (auto i : piles) &#123; mx = max(mx, i); &#125; int left = 1, right = mx; while (left &lt; right) &#123; int i = (left + right) / 2; long long ans = 0; for (auto j : piles) &#123; int x = j / i; ans += (j % i == 0) ? x * i : (x + 1) * i; &#125; int h = ans / i; if (h &gt; H) left = i + 1; else right = i; &#125; return left; &#125;&#125;; 特殊题目 还未归类的题目放到这里，此部分待编辑 数组中的逆序对 (*) 牛客网 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 思路可以参考牛客网 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; int length=data.size(); if(length&lt;=0) return 0; //vector&lt;int&gt; copy=new vector&lt;int&gt;[length]; vector&lt;int&gt; copy; for(int i=0;i&lt;length;i++) copy.push_back(data[i]); long long count=InversePairsCore(data,copy,0,length-1); //delete[]copy; return count%1000000007; &#125; long long InversePairsCore(vector&lt;int&gt; &amp;data,vector&lt;int&gt; &amp;copy,int start,int end) &#123; if(start==end) &#123; copy[start]=data[start]; return 0; &#125; int length=(end-start)/2; long long left=InversePairsCore(copy,data,start,start+length); long long right=InversePairsCore(copy,data,start+length+1,end); int i=start+length; int j=end; int indexcopy=end; long long count=0; while(i&gt;=start&amp;&amp;j&gt;=start+length+1) &#123; if(data[i]&gt;data[j]) &#123; copy[indexcopy--]=data[i--]; count=count+j-start-length; //count=count+j-(start+length+1)+1; &#125; else &#123; copy[indexcopy--]=data[j--]; &#125; &#125; for(;i&gt;=start;i--) copy[indexcopy--]=data[i]; for(;j&gt;=start+length+1;j--) copy[indexcopy--]=data[j]; return left+right+count; &#125;&#125;;]]></content>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>OJ</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 数据结构相关整理]]></title>
    <url>%2F2018%2F08%2F27%2Fleetcode-summary-data-structure%2F</url>
    <content type="text"><![CDATA[这里总结一些leetcode上比较经典的与数据结构相关的例题与思路，因为部分数据结构更偏向与搜索或贪心类型，该类题目就不再本部分总结… 字符串和数组 字符串和数组是比较典型的线性表结构，由于比较好访问，所以通常会在该类数据结构上设计搜索和dp类型的题目。搜索和动规类型的题目会另做讨论，本部分主要总结比较典型反映字符串和数组属性的题目，例如线性表操作或双指针等。 字符串表达式求值表达式求值是一类比较考察细节的题目，一般会涉及括号，四则运算，小数和空格，所以在写的时候要注意思路清晰，以下提供一个模板： 模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;math.h&gt;using namespace std;double getNum(string s, int&amp; index) &#123; int n = s.size(); int cnt = -1, ans = 0; while (index &lt; n &amp;&amp; (isdigit(s[index]) || s[index] == '.')) &#123; if (s[index] == '.') cnt ++; else &#123; ans = ans * 10 + (s[index] - '0'); if (cnt &gt;= 0) cnt ++; &#125; index ++; &#125; cnt = cnt &lt; 0 ? 0 : cnt; return ans / pow(10, cnt);&#125;double helper(string s, int&amp; index) &#123; double ret = 0.0, cur_ret = 0.0; int n = s.size(); char op = '+'; while (index &lt; n &amp;&amp; s[index] != ')') &#123; if (s[index] == ' ') &#123; index ++; continue; &#125; if (isdigit(s[index]) || s[index] == '(') &#123; double temp = 0.0; if (s[index] == '(') &#123; index ++; temp = helper(s, index); index ++; &#125; else &#123; temp = getNum(s, index); &#125; switch(op) &#123; case '+' : cur_ret += temp; break; case '-' : cur_ret -= temp; break; case '*' : cur_ret *= temp; break; case '/' : cur_ret /= temp; break; &#125; &#125; else &#123; if (s[index] == '+' || s[index] == '-') &#123; ret += cur_ret; cur_ret = 0.0; &#125; op = s[index++]; &#125; &#125; return ret + cur_ret;&#125;int main() &#123; string s; cin &gt;&gt; s; int index = 0; cout &lt;&lt; helper(s, index) &lt;&lt; endl; return 0;&#125; Basic Calculator Leetcode 224 123456789101112131415Implement a basic calculator to evaluate a simple expression string.The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .Example 1:Input: &quot;1 + 1&quot;Output: 2Example 2:Input: &quot; 2-1 + 2 &quot;Output: 3Example 3:Input: &quot;(1+(4+5+2)-3)+(6+8)&quot;Output: 23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: int getNum(string s, int&amp; index) &#123; int ret = 0, n = s.size(); while (index &lt; n &amp;&amp; isdigit(s[index])) &#123; ret = ret * 10 + (s[index++] - '0'); &#125; return ret; &#125; int helper(string s, int&amp; index) &#123; int ret = 0, cur_ret = 0; char op = '+'; int n = s.size(); while (index &lt; n &amp;&amp; s[index] != ')') &#123; if (s[index] == ' ') &#123; index ++; continue; &#125; if (isdigit(s[index]) || s[index] == '(') &#123; int temp = 0; if (s[index] == '(') &#123; index ++; temp = helper(s, index); index ++; &#125; else temp = getNum(s, index); switch(op) &#123; case '+': cur_ret += temp; break; case '-': cur_ret -= temp; break; case '*': cur_ret *= temp; break; case '/': cur_ret /= temp; break; &#125; &#125; else &#123; if (s[index] == '+' || s[index] == '-') &#123; ret += cur_ret; cur_ret = 0; &#125; op = s[index ++]; &#125; &#125; return ret + cur_ret; &#125; int calculate(string s) &#123; int index = 0; return helper(s, index); &#125;&#125;; Basic Calculator II Leetcode 227 123456789101112131415Implement a basic calculator to evaluate a simple expression string.The expression string contains only non-negative integers, +, -, *, / operators and empty spaces . The integer division should truncate toward zero.Example 1:Input: &quot;3+2*2&quot;Output: 7Example 2:Input: &quot; 3/2 &quot;Output: 1Example 3:Input: &quot; 3+5 / 2 &quot;Output: 5 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class Solution &#123;public: int getNum(string s, int&amp; index) &#123; int ret = 0, n = s.size(); while (index &lt; n &amp;&amp; isdigit(s[index])) &#123; ret = ret * 10 + (s[index++] - '0'); &#125; return ret; &#125; int helper(string s, int&amp; index) &#123; int ret = 0, cur_ret = 0; char op = '+'; int n = s.size(); while (index &lt; n &amp;&amp; s[index] != ')') &#123; if (s[index] == ' ') &#123; index ++; continue; &#125; if (isdigit(s[index]) || s[index] == '(') &#123; int temp = 0; if (s[index] == '(') &#123; index ++; temp = helper(s, index); index ++; &#125; else temp = getNum(s, index); switch(op) &#123; case '+': cur_ret += temp; break; case '-': cur_ret -= temp; break; case '*': cur_ret *= temp; break; case '/': cur_ret /= temp; break; &#125; &#125; else &#123; if (s[index] == '+' || s[index] == '-') &#123; ret += cur_ret; cur_ret = 0; &#125; op = s[index ++]; &#125; &#125; return ret + cur_ret; &#125; int calculate(string s) &#123; int index = 0; return helper(s, index); &#125;&#125;; 字符串操作Multiply Strings Leetcode 43字符串乘法 Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string. 1234567Example 1:Input: num1 = &quot;2&quot;, num2 = &quot;3&quot;Output: &quot;6&quot;Example 2:Input: num1 = &quot;123&quot;, num2 = &quot;456&quot;Output: &quot;56088&quot; 1234567891011121314151617181920212223class Solution &#123;public: string multiply(string num1, string num2) &#123; int n1 = num1.size(), n2 = num2.size(); string ret(n1 + n2, '0'); reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); for (int i = 0; i &lt; n1; i++) &#123; int a = num1[i] - '0'; int c = 0; for (int j = 0; j &lt; n2; j++) &#123; int b = num2[j] - '0'; int ans = a * b + c + (ret[i + j] - '0'); c = ans / 10; ret[i + j] = '0' + (ans % 10); &#125; ret[n2 + i] = c + '0'; &#125; reverse(ret.begin(), ret.end()); while (!ret.empty() &amp;&amp; ret[0] == '0') ret.erase(ret.begin()); return ret.empty() ? "0" : ret; &#125;&#125;; Add Two Numbers II Leetcode 445无符号字符串加法 You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up:What if you cannot modify the input lists? In other words, reversing the lists is not allowed.123Example:Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; string num1, num2; ListNode* cur = l1; while (cur) &#123; num1.push_back('0' + cur-&gt;val); cur = cur-&gt;next; &#125; cur = l2; while (cur) &#123; num2.push_back('0' + cur-&gt;val); cur = cur-&gt;next; &#125; string ret; int c = 0; int i = num1.size() - 1, j = num2.size() - 1; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; int a = num1[i--] - '0'; int b = num2[j--] - '0'; int ans = c + a + b; ret = to_string(ans % 10) + ret; c = ans / 10; &#125; while (i &gt;= 0) &#123; int a = num1[i--] - '0'; int ans = c + a; ret = to_string(ans % 10) + ret; c = ans / 10; &#125; while (j &gt;= 0) &#123; int a = num2[j--] - '0'; int ans = c + a; ret = to_string(ans % 10) + ret; c = ans / 10; &#125; if (c) ret = to_string(c) + ret; ListNode* head = NULL; for (i = ret.size() - 1; i &gt;= 0; i--) &#123; ListNode* cur = new ListNode(ret[i] - '0'); cur-&gt;next = head; head = cur; &#125; return head; &#125;&#125;; 带符号字符串加减法模板12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;// 此处由于是默认加法所以没有对减法进行符号处理，否则这里也需要像加法一样对其进行符号判断string INT_SUB(string a, string b) &#123; int syn = 1; if (a &lt; b) &#123; string temp = a; a = b; b = temp; syn *= -1; &#125; int i = a.size() - 1, j = b.size() - 1; int c = 0; string ret; while (i &gt;= 0) &#123; int x = a[i--] - '0'; int y = b[j--] - '0'; int ans = (10 + x - y - c) % 10; c = x &lt; y ? 1 : 0; ret = (char)('0' + ans) + ret; &#125; while (ret.empty() &amp;&amp; ret[0] == '0') ret.erase(ret.begin()); if (ret.empty()) return "0"; return syn == -1 ? "-" + ret : ret;&#125;string INT_ADD(string a, string b) &#123; if (a.empty()) return b; if (b.empty()) return a; if (a[0] == '+') a.erase(a.begin()); if (b[0] == '+') b.erase(b.begin()); int syn = 1; string ret; if (a[0] == '-') &#123; if (b[0] == '-') &#123; syn = -1; ret = INT_ADD(a.substr(1), b.substr(1)); &#125; else &#123; ret = INT_SUB(b, a.substr(1)); &#125; &#125; else &#123; if (b[0] == '-') &#123; ret = INT_SUB(a, b.substr(1)); &#125; else &#123; int i = a.size() - 1, j = b.size() - 1; int c = 0; while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123; int x = a[i--] - '0'; int y = b[j--] - '0'; int ans = x + y + c; ret = (char)('0' + ans % 10) + ret; c = ans / 10; &#125; while (i &gt;= 0) &#123; int x = a[i--] - '0'; int ans = x + c; ret = (char)('0' + ans % 10) + ret; c = ans / 10; &#125; while (j &gt;= 0) &#123; int x = b[j--] - '0'; int ans = x + c; ret = (char)('0' + ans % 10) + ret; c = ans / 10; &#125; if (c) ret = (char)('0' + c) + ret; &#125; &#125; if (ret[0] == '-') &#123; if (syn == 1) return ret; else return ret.substr(1); &#125; else &#123; if (syn == 1) return ret; else return ret != "0" ? "-" + ret : ret; &#125;&#125;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; INT_ADD(a, b) &lt;&lt; endl; return 0;&#125; 字符串双指针题目双指针有两种用法，第一种是用于更新原字符串，另一种是用于搜索。一般而言，快指针不光可以表示原本字符串上的位置，同时还可以表示扩展字符串后的位置。 Longest Substring with At Least K Repeating Characters Leetcode 395 Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times. Example 1:1234567Input:s = &quot;aaabb&quot;, k = 3Output:3The longest substring is &quot;aaa&quot;, as &apos;a&apos; is repeated 3 times. Example 2:1234567Input:s = &quot;ababbc&quot;, k = 2Output:5The longest substring is &quot;ababb&quot;, as &apos;a&apos; is repeated 2 times and &apos;b&apos; is repeated 3 times. 123456789101112131415161718192021222324252627class Solution &#123;public: int longestSubstring(string s, int k) &#123; int ret = 0, n = s.size(); for (int h = 1; h &lt;= 26; h++) &#123; vector&lt;int&gt; m(26, 0); int i = 0, j = 0, unique = 0, ans = 0; while (j &lt; n) &#123; if (unique &lt;= h) &#123; int index = s[j++] - 'a'; m[index] ++; if (m[index] == k) ans ++; if (m[index] == 1) unique ++; &#125; else &#123; int index = s[i++] - 'a'; m[index] --; if (m[index] == k - 1) ans --; if (m[index] == 0) unique --; &#125; if (unique == h &amp;&amp; unique == ans) ret = max(ret, j - i); &#125; &#125; return ret; &#125;&#125;; Reverse Words in a String Leetcode 151 123456789101112Given an input string, reverse the string word by word.Example: Input: &quot;the sky is blue&quot;,Output: &quot;blue is sky the&quot;.Note:A word is defined as a sequence of non-space characters.Input string may contain leading or trailing spaces. However, your reversed string should not contain leading or trailing spaces.You need to reduce multiple spaces between two words to a single space in the reversed string.Follow up: For C programmers, try to solve it in-place in O(1) space. 123456789101112131415161718192021class Solution &#123;public: void reverseWords(string &amp;s) &#123; // 更新原本字符串 if (s.empty()) return; reverse(s.begin(), s.end()); int i = 0, cur = 0; int n = s.size(); while (i &lt; n) &#123; if (s[i] != ' ') &#123; if (cur) s[cur++] = ' '; int j = i; while (j &lt; n &amp;&amp; s[j] != ' ') s[cur++] = s[j++]; reverse(s.begin() + cur - (j - i), s.begin() + cur); i = j; &#125; i++; &#125; s.erase(s.begin() + cur, s.end()); &#125;&#125;; Minimum Window Substring Leetcode 76 123456789Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).Example:Input: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;Output: &quot;BANC&quot;Note:If there is no such window in S that covers all characters in T, return the empty string &quot;&quot;.If there is such window, you are guaranteed that there will always be only one unique minimum window in S. 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: string minWindow(string s, string t) &#123; // ans保存未满足的字符数 unordered_map&lt;char, int&gt; m; for (auto i : t) m[i] ++; int ans = m.size(), n = s.size(); int cnt = INT_MAX, i = 0, j = 0; string ret; while (j &lt;= n &amp;&amp; i &lt;= j) &#123; if (j &lt; n &amp;&amp; ans &gt; 0) &#123; if (m.find(s[j]) != m.end()) &#123; m[s[j]]--; if (!m[s[j]]) ans--; &#125; j ++; &#125; else &#123; if (m.find(s[i]) != m.end()) &#123; if (!m[s[i]]) ans ++; m[s[i]] ++; &#125; i++; &#125; if (!ans) &#123; if (j - i &lt; cnt) &#123; cnt = j - i; ret = s.substr(i, cnt); &#125; &#125; &#125; return ret; &#125;&#125;; Decoded String at Index Leetcode 884 An encoded string S is given. To find and write the decoded string to a tape, the encoded string is read one character at a time and the following steps are taken: If the character read is a letter, that letter is written onto the tape.If the character read is a digit (say d), the entire current tape is repeatedly written d-1 more times in total.Now for some encoded string S, and an index K, find and return the K-th letter (1 indexed) in the decoded string. 123456789101112131415161718Example 1:Input: S = &quot;leet2code3&quot;, K = 10Output: &quot;o&quot;Explanation: The decoded string is &quot;leetleetcodeleetleetcodeleetleetcode&quot;.The 10th letter in the string is &quot;o&quot;.Example 2:Input: S = &quot;ha22&quot;, K = 5Output: &quot;h&quot;Explanation: The decoded string is &quot;hahahaha&quot;. The 5th letter is &quot;h&quot;.Example 3:Input: S = &quot;a2345678999999999999999&quot;, K = 1Output: &quot;a&quot;Explanation: The decoded string is &quot;a&quot; repeated 8301530446056247680 times. The 1st letter is &quot;a&quot;. 123456789101112131415161718192021222324252627282930class Solution &#123;public: string decodeAtIndex(string S, int K) &#123; int n = S.size(); // 此题因为反复更新K，也可以认为是栈类型的题目 // 但是由于栈通常一般时间复杂度为O(n)，所以放到双指针类型中 while (K &gt;= 0) &#123; long long cur = 0, pre = 0; for (int i = 0; i &lt; n; i++) &#123; if (isdigit(S[i])) &#123; cur = pre * (S[i] - '0'); if (cur &gt;= K) &#123; // 更新K K = ((K - 1) % pre) + 1; break; &#125; &#125; else &#123; cur ++; if (cur &gt;= K) &#123; // 如果超过了原本就超过K则K就会被更新 // 这里就是在当前字符串段上 return S.substr(i, 1); &#125; &#125; pre = cur; &#125; &#125; &#125;&#125;; Longest Palindromic Substring Leetcode 5 Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000. 12345678Example 1:Input: &quot;babad&quot;Output: &quot;bab&quot;Note: &quot;aba&quot; is also a valid answer.Example 2:Input: &quot;cbbd&quot;Output: &quot;bb&quot; 123456789101112131415161718// 最长回文数的最常见算法为O(n2)，还有优化版本，但是需要讲解数学逻辑，之后更新...class Solution &#123;public: string longestPalindrome(string s) &#123; if (s.empty()) return s; int n = s.size(), len = 0, index = 0; for (int i = 0; i &lt; n; i++) &#123; if (n - i &lt;= len / 2) break; int l = i, r = i; while (r &lt; n - 1 &amp;&amp; s[r + 1] == s[r]) r++; while (l &gt; 0 &amp;&amp; r &lt; n - 1 &amp;&amp; s[l - 1] == s[r + 1]) l--, r++; if (len &lt; r - l + 1) &#123; index = l, len = r - l + 1; &#125; &#125; return s.substr(index, len); &#125;&#125;; 字符串处理此部分会不断更新… Validate IP Address Leetcode 468 12345678910111213141516171819202122232425262728Write a function to check whether an input string is a valid IPv4 address or IPv6 address or neither.IPv4 addresses are canonically represented in dot-decimal notation, which consists of four decimal numbers, each ranging from 0 to 255, separated by dots (&quot;.&quot;), e.g.,172.16.254.1;Besides, leading zeros in the IPv4 is invalid. For example, the address 172.16.254.01 is invalid.IPv6 addresses are represented as eight groups of four hexadecimal digits, each group representing 16 bits. The groups are separated by colons (&quot;:&quot;). For example, the address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 is a valid one. Also, we could omit some leading zeros among four hexadecimal digits and some low-case characters in the address to upper-case ones, so 2001:db8:85a3:0:0:8A2E:0370:7334 is also a valid IPv6 address(Omit leading zeros and using upper cases).However, we don&apos;t replace a consecutive group of zero value with a single empty group using two consecutive colons (::) to pursue simplicity. For example, 2001:0db8:85a3::8A2E:0370:7334 is an invalid IPv6 address.Besides, extra leading zeros in the IPv6 is also invalid. For example, the address 02001:0db8:85a3:0000:0000:8a2e:0370:7334 is invalid.Note: You may assume there is no extra space or special characters in the input string.Example 1:Input: &quot;172.16.254.1&quot;Output: &quot;IPv4&quot;Explanation: This is a valid IPv4 address, return &quot;IPv4&quot;.Example 2:Input: &quot;2001:0db8:85a3:0:0:8A2E:0370:7334&quot;Output: &quot;IPv6&quot;Explanation: This is a valid IPv6 address, return &quot;IPv6&quot;.Example 3:Input: &quot;256.256.256.256&quot;Output: &quot;Neither&quot;Explanation: This is neither a IPv4 address nor a IPv6 address. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 此方法主要是用于练习字符串处理，如果想要寻找更加高效的算法请在leetcode discuss区寻找class Solution &#123;public: bool helper4(string s) &#123; vector&lt;string&gt; nums; string ans; int cnt = 0; for (int i = 0; i &lt; s.size(); i++) &#123; if (isdigit(s[i]) || s[i] == '.') &#123; if (s[i] == '.') &#123; nums.push_back(ans); ans = ""; cnt ++; &#125; else &#123; ans.push_back(s[i]); &#125; &#125; else return false; &#125; nums.push_back(ans); for (string i : nums) &#123; if (i.empty() || (i.size() &gt; 1 &amp;&amp; i[0] == '0')) return false; int temp = atoi(i.c_str()); if (temp &lt; 0 || temp &gt; 255) return false; &#125; return nums.size() == 4 &amp;&amp; cnt == 3; &#125; bool helper6(string s) &#123; vector&lt;string&gt; nums; string ans; int cnt = 0; for (auto i : s) &#123; if (i == ':') &#123; nums.push_back(ans); ans = ""; cnt ++; &#125; else &#123; ans.push_back(i); &#125; &#125; nums.push_back(ans); for (auto i : nums) &#123; int n = i.size(); if (n &lt; 1 || n &gt; 4) return false; for (auto j : i) &#123; if ((j &lt;= '9' &amp;&amp; j &gt;= '0') || (j &lt;= 'F' &amp;&amp; j &gt;= 'A') || (j &lt;= 'f' &amp;&amp; j &gt;= 'a')); else return false; &#125; &#125; return nums.size() == 8 &amp;&amp; cnt == 7; &#125; string validIPAddress(string IP) &#123; if (helper4(IP)) return "IPv4"; else if (helper6(IP)) return "IPv6"; else return "Neither"; &#125;&#125;; 数组数组操作Increasing Triplet Subsequence Leetcode 334 Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array. Formally the function should: Return true if there exists i, j, ksuch that arr[i] &lt; arr[j] &lt; arr[k] given 0 ≤ i &lt; j &lt; k ≤ n-1 else return false.Note: Your algorithm should run in O(n) time complexity and O(1) space complexity.1234567Example 1:Input: [1,2,3,4,5]Output: trueExample 2:Input: [5,4,3,2,1]Output: false 123456789101112class Solution &#123;public: bool increasingTriplet(vector&lt;int&gt;&amp; nums) &#123; int c1 = INT_MAX, c2 = INT_MAX; for (auto i : nums) &#123; if (i &lt;= c1) c1 = i; else if (i &lt;= c2) c2 = i; else return true; &#125; return false; &#125;&#125;; Contiguous Array Leetcode 525 Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.123456789Example 1:Input: [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1.Example 2:Input: [0,1,0]Output: 2Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. Note: The length of the given binary array will not exceed 50,000. 123456789101112131415161718class Solution &#123;public: int findMaxLength(vector&lt;int&gt;&amp; nums) &#123; // 前缀和的变形 for (auto &amp;i : nums) &#123; if (!i) i = -1; &#125; unordered_map&lt;int, int&gt; m; m[0] = -1; int ans = 0, ret = 0, n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; ans += nums[i]; if (m.find(ans) != m.end()) ret = max(ret, i - m[ans]); else m[ans] = i; &#125; return ret; &#125;&#125;; 4Sum II Leetcode 454 Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero. To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.123456789101112131415Example:Input:A = [ 1, 2]B = [-2,-1]C = [-1, 2]D = [ 0, 2]Output:2Explanation:The two tuples are:1. (0, 0, 0, 1) -&gt; A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 02. (1, 1, 0, 0) -&gt; A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0 1234567891011121314151617181920class Solution &#123;public: void helper(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, unordered_map&lt;int, int&gt;&amp; ret) &#123; for (auto i : A) &#123; for (auto j : B) &#123; ret[i + j]++; &#125; &#125; &#125; int fourSumCount(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, vector&lt;int&gt;&amp; C, vector&lt;int&gt;&amp; D) &#123; unordered_map&lt;int, int&gt; a, b; helper(A, B, a); helper(C, D, b); int ret = 0; for (auto i : a) &#123; if (b.find(-i.first) != b.end()) ret += i.second * b[-i.first]; &#125; return ret; &#125;&#125;; Largest Number Leetcode 179 Given a list of non negative integers, arrange them such that they form the largest number.1234567Example 1:Input: [10,2]Output: &quot;210&quot;Example 2:Input: [3,30,34,5,9]Output: &quot;9534330&quot; Note: The result may be very large, so you need to return a string instead of an integer. 123456789101112131415161718class Solution &#123;public: bool static cmp(const int&amp; a, const int&amp; b) &#123; string a1 = to_string(a); string b1 = to_string(b); return a1 + b1 &gt; b1 + a1; &#125; string largestNumber(vector&lt;int&gt;&amp; nums) &#123; string ret; if (nums.empty()) return ret; sort(nums.begin(), nums.end(), cmp); for (auto i : nums) &#123; ret += to_string(i); &#125; while (!ret.empty() &amp;&amp; ret[0] == '0') ret.erase(ret.begin()); return ret.empty() ? "0" : ret; &#125;&#125;; First Missing Positive Leetcode 41 Given an unsorted integer array, find the smallest missing positive integer.1234567891011Example 1:Input: [1,2,0]Output: 3Example 2:Input: [3,4,-1,1]Output: 2Example 3:Input: [7,8,9,11,12]Output: 1 12345678910111213class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; while (nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i]) swap(nums[nums[i] - 1], nums[i]); &#125; for (int i = 0; i &lt; n; i++) &#123; if (i + 1 != nums[i]) return i + 1; &#125; return n + 1; &#125;&#125;; Find the Duplicate Number Leetcode 287 Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.1234567Example 1:Input: [1,3,4,2,2]Output: 2Example 2:Input: [3,1,3,4,2]Output: 3 1234567891011class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return -1; for (auto &amp;i : nums) &#123; if (nums[abs(i) - 1] &lt; 0) return abs(i); nums[abs(i) - 1] *= -1; &#125; return -1; &#125;&#125;; Find All Duplicates in an Array Leetcode 442 Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements that appear twice in this array. Could you do it without extra space and in O(n) runtime?123456Example:Input:[4,3,2,7,8,2,3,1]Output:[2,3] 1234567891011class Solution &#123;public: vector&lt;int&gt; findDuplicates(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ret; for (auto &amp;i : nums) &#123; if (nums[abs(i) - 1] &lt; 0) ret.push_back(abs(i)); nums[abs(i) - 1] *= -1; &#125; return ret; &#125;&#125;; Longest Substring Without Repeating Characters Leetcode 3 Given a string, find the length of the longest substring without repeating characters.123456789101112131415Example 1:Input: &quot;abcabcbb&quot;Output: 3 Explanation: The answer is &quot;abc&quot;, which the length is 3.Example 2:Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1.Example 3:Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 123456789101112131415class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; if (s.empty()) return 0; unordered_map&lt;char, int&gt; m; int index = -1, n = s.size(), ret = 0; for (int i = 0; i &lt; n; i++) &#123; auto c = s[i]; if (m.find(c) != m.end() &amp;&amp; m[c] &gt; index) index = m[c]; ret = max(ret, i - index); m[c] = i; &#125; return ret; &#125;&#125;; 连续子数组的最大值 牛客网 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 12345678910111213class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; int ans = 0, n = array.size(); int ret = INT_MIN; for (int i = 0; i &lt; n; i++) &#123; ans += array[i]; ret = max(ret, ans); if (ans &lt;= 0) ans = 0; &#125; return ret; &#125;&#125;; 整数中1出现的次数（从1到n整数中1出现的次数） 牛客网因为此题细节较多，为了多加练习，在此处也做整理 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 1234567891011121314151617181920class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; string s = to_string(n); int len = s.size(), ret = 0; for (int i = 0; i &lt; len; i++) &#123; int c = s[len - 1 - i] - '0'; if (c == 0) &#123; ret += n / (int)pow(10, i + 1) * pow(10, i); &#125; else if (c == 1) &#123; ret += n / (int)pow(10, i + 1) * pow(10, i) + (n % (int)pow(10, i)) + 1; &#125; else &#123; ret += (n / (int)pow(10, i + 1) + 1) * pow(10, i); &#125; &#125; return ret; &#125;&#125;; 双指针Minimum Size Subarray Sum Leetcode 209 Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.12345Example: Input: s = 7, nums = [2,3,1,2,4,3]Output: 2Explanation: the subarray [4,3] has the minimal length under the problem constraint. Follow up:If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log n). 1234567891011121314class Solution &#123;public: // 因为是正整数，和一直是递增的，所以使用双指针就可以了 int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int ans = 0, i = 0, j = 0, n = nums.size(); int ret = INT_MAX; while (j &lt; n) &#123; ans += nums[j++]; while (i &lt; j &amp;&amp; ans - nums[i] &gt;= s) ans -= nums[i++]; if (ans &gt;= s) ret = min(ret, j - i); &#125; return ret == INT_MAX ? 0 : ret; &#125;&#125;; 3Sum Leetcode 15 Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets.123456789Example:Given array nums = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int n = nums.size(); if (n &lt; 3) return ret; sort(nums.begin(), nums.end()); for (int i = 0; i &lt; n - 2; i++) &#123; if (i == 0 || nums[i] != nums[i - 1]) &#123; int j = i + 1, k = n - 1; while (j &lt; k) &#123; int ans = nums[i] + nums[j] + nums[k]; if (!ans) &#123; ret.push_back(vector&lt;int&gt;&#123;nums[i], nums[j], nums[k]&#125;); while (j &lt; k &amp;&amp; nums[j + 1] == nums[j]) j++; while (j &lt; k &amp;&amp; nums[k - 1] == nums[k]) k--; j ++, k --; &#125; else if (ans &gt; 0) k --; else j ++; &#125; &#125; &#125; return ret; &#125;&#125;; 3Sum Closest Leetcode 16 Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.123Example:Given array nums = [-1, 2, 1, -4], and target = 1. The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). 123456789101112131415161718192021// 3Sum的扩展版本class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; int n = nums.size(); if (n &lt; 3) return -1; sort(nums.begin(), nums.end()); int ret = nums[0] + nums[1] + nums[2]; for (int i = 0; i &lt; n - 2; i++) &#123; int j = i + 1, k = n - 1; while (j &lt; k) &#123; int ans = nums[i] + nums[j] + nums[k]; if (ans == target) return target; if (abs(ans - target) &lt; abs(ret - target)) ret = ans; if (ans &gt; target) k--; else j ++; &#125; &#125; return ret; &#125;&#125;; 丑数 牛客网 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 12345678910111213141516class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if (index &lt; 1) return 0; vector&lt;int&gt; ret(index, 0); int c2 = 0, c3 = 0, c5 = 0; ret[0] = 1; for (int i = 1; i &lt; index; i++) &#123; ret[i] = min(ret[c2] * 2, min(ret[c3] * 3, ret[c5] * 5)); if (ret[c2] * 2 == ret[i]) c2 ++; if (ret[c3] * 3 == ret[i]) c3 ++; if (ret[c5] * 5 == ret[i]) c5 ++; &#125; return ret[index - 1]; &#125;&#125;; Super Ugly Number Leetcode 313 Write a program to find the nth super ugly number. Super ugly numbers are positive numbers whose all prime factors are in the given prime list primes of size k.123456Example:Input: n = 12, primes = [2,7,13,19]Output: 32 Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19] of size 4. 12345678910111213141516class Solution &#123;public: int nthSuperUglyNumber(int n, vector&lt;int&gt;&amp; primes) &#123; int len = primes.size(); vector&lt;int&gt; cnt(len + 1, 0); vector&lt;int&gt; ret(n, INT_MAX); ret[0] = 1; for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; len; j++) ret[i] = min(ret[i], primes[j] * ret[cnt[j]]); for (int j = 0; j &lt; len; j++) &#123; if (ret[i] == primes[j] * ret[cnt[j]]) cnt[j] ++; &#125; &#125; return ret[n - 1]; &#125;&#125;; Remove Duplicates from Sorted Array II Leetcode 80 Given a sorted array nums, remove the duplicates in-place such that duplicates appeared at most twice and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.123456789Example 1:Given nums = [1,1,1,2,2,3],Your function should return length = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.It doesn&apos;t matter what you leave beyond the returned length.Example 2:Given nums = [0,0,1,1,1,1,2,3,3],Your function should return length = 7, with the first seven elements of nums being modified to 0, 0, 1, 1, 2, 3 and 3 respectively.It doesn&apos;t matter what values are set beyond the returned length. Clarification: Confused why the returned value is an integer but your answer is an array? Note that the input array is passed in by reference, which means modification to the input array will be known to the caller as well. Internally you can think of this:12345678// nums is passed in by reference. (i.e., without making a copy)int len = removeDuplicates(nums);// any modification to nums in your function would be known by the caller.// using the length returned by your function, it prints the first len elements.for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 12345678910class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; int index = 0, n = nums.size(); for (int i = 0; i &lt; n; i++) &#123; if (index &lt; 2 || nums[index - 2] != nums[i]) nums[index ++] = nums[i]; &#125; return index; &#125;&#125;; Trapping Rain Water Leetcode 42 Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image! 123Example:Input: [0,1,0,2,1,0,1,3,2,1,2,1]Output: 6 12345678910111213class Solution &#123;public: int trap(vector&lt;int&gt;&amp; height) &#123; int ret = 0, n = height.size(); int level = 0, l = 0, r = n - 1; while (l &lt; r) &#123; int lower = height[height[l] &lt; height[r] ? l ++ : r --]; level = max(level, lower); ret += level - lower; &#125; return ret; &#125;&#125;; 构建乘积数组 牛客网 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123; int len = A.size(); vector&lt;int&gt; B(len, 1); for (int i = 1; i &lt; len; i++) &#123; B[i] = A[i - 1] * B[i - 1]; &#125; int ans = 1; for (int i = len - 1; i&gt;= 0; i--) &#123; B[i] *= ans; ans *= A[i]; &#125; return B; &#125;&#125;; 队列队列通常的应用一般包括单调队列等，这里只列出一部分单调队列题目，之后不断补充… Shortest Subarray with Sum at Least K Leetcode 862 Return the length of the shortest, non-empty, contiguous subarray of A with sum at least K. If there is no non-empty subarray with sum at least K, return -1. 123456789101112131415161718Example 1:Input: A = [1], K = 1Output: 1Example 2:Input: A = [1,2], K = 4Output: -1Example 3:Input: A = [2,-1,2], K = 3Output: 3 Note:1 &lt;= A.length &lt;= 50000-10 ^ 5 &lt;= A[i] &lt;= 10 ^ 51 &lt;= K &lt;= 10 ^ 9 1234567891011121314151617181920212223class Solution &#123;public: int shortestSubarray(vector&lt;int&gt;&amp; A, int K) &#123; // 此算法是利用了双指针的思路，不过需要维护一个单调队列 // 才能需要保证更新长度过程中是满足条件的，否则有升有降只能使用平方级的时间复杂度 int n = A.size(), ret = n + 1; vector&lt;int&gt; B(n + 1, 0); for (int i = 0; i &lt; n; i++) &#123; B[i + 1] = B[i] + A[i]; &#125; deque&lt;int&gt; d; for (int i = 0; i &lt;= n; i++) &#123; // 因为是有序的，所以此处还可以使用二分查找 while (!d.empty() &amp;&amp; B[i] - B[d.front()] &gt;= K) &#123; ret = min(ret, i - d.front()); d.pop_front(); &#125; while (!d.empty() &amp;&amp; B[d.back()] &gt;= B[i]) d.pop_back(); d.push_back(i); &#125; return ret == n + 1 ? -1 : ret; &#125;&#125;; Sliding Window Maximum Leetcode 239 Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window. 1234567891011121314Example:Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3Output: [3,3,5,5,6,7] Explanation: Window position Max--------------- -----[1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Note:You may assume k is always valid, 1 ≤ k ≤ input array’s size for non-empty array. Follow up:Could you solve it in linear time? 123456789101112131415class Solution &#123;public: vector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int n = nums.size(); vector&lt;int&gt; ret; deque&lt;int&gt; d; for (int i = 0; i &lt; n; i++) &#123; while (!d.empty() &amp;&amp; nums[i] &gt; nums[d.back()]) d.pop_back(); d.push_back(i); if (i &gt;= k - 1) ret.push_back(nums[d.front()]); if (d.front() &lt;= i - k + 1) d.pop_front(); &#125; return ret; &#125;&#125;; 链表LRU Cache（双端链表list） Leetcode 146 Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. Follow up:Could you do both operations in O(1) time complexity?12345678910111213Example:LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 list是stl的双端链表，链表指针可以用O(1)时间删除，但是随机访问时间慢 123456789101112131415161718192021222324252627282930313233343536373839404142class LRUCache &#123;public: LRUCache(int capacity) : _capacity(capacity) &#123;&#125; // 双端链表里存的是id，map里存的是key，val，iter int get(int key) &#123; auto it = cache.find(key); if (it == cache.end()) return -1; touch(it); return it-&gt;second.first; &#125; void put(int key, int value) &#123; auto it = cache.find(key); if (it != cache.end()) touch(it); else &#123; if (cache.size() == _capacity) &#123; cache.erase(used.back()); used.pop_back(); &#125; used.push_front(key); &#125; cache[key] = &#123; value, used.begin() &#125;; &#125; private: typedef list&lt;int&gt; LI; typedef pair&lt;int, LI::iterator&gt; PII; typedef unordered_map&lt;int, PII&gt; HIPII; void touch(HIPII::iterator it) &#123; int key = it-&gt;first; used.erase(it-&gt;second.second); used.push_front(key); it-&gt;second.second = used.begin(); &#125; HIPII cache; LI used; int _capacity;&#125;; Insertion Sort List Leetcode 147 Sort a linked list using insertion sort. Algorithm of Insertion Sort: Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.It repeats until no input elements remain.1234567Example 1:Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4Example 2:Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void helper(ListNode* &amp;ret, ListNode* head) &#123; while (head) &#123; ListNode* temp = head; head = head-&gt;next; temp-&gt;next = NULL; ListNode* cur = ret; while (cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val &lt; temp-&gt;val) &#123; cur = cur-&gt;next; &#125; temp-&gt;next = cur-&gt;next; cur-&gt;next = temp; &#125; &#125; ListNode* insertionSortList(ListNode* head) &#123; if (!head) return NULL; ListNode* ret = new ListNode(-1); helper(ret, head); return ret-&gt;next; &#125;&#125;; Sort List Leetcode 148 Sort a linked list in O(n log n) time using constant space complexity.1234567Example 1:Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4Example 2:Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* merge(ListNode* p1, ListNode* p2) &#123; if (!p1) return p2; if (!p2) return p1; ListNode* ret = new ListNode(INT_MIN); ListNode* cur = ret; while (p1 &amp;&amp; p2) &#123; if (p1-&gt;val &lt; p2-&gt;val) &#123; cur-&gt;next = p1; cur = p1; p1 = p1-&gt;next; &#125; else &#123; cur-&gt;next = p2; cur = p2; p2 = p2-&gt;next; &#125; &#125; if (p1) &#123; cur-&gt;next = p1; &#125; if (p2) &#123; cur-&gt;next = p2; &#125; return ret-&gt;next; &#125; ListNode* sortList(ListNode* head) &#123; if (!head || !head-&gt;next) return head; ListNode* fast = head, *slow = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; auto mid = slow-&gt;next; slow-&gt;next = NULL; auto l = sortList(head); auto r = sortList(mid); return merge(l, r); &#125;&#125;; Remove Duplicates from Sorted List II Leetcode 82 Given a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list.1234567Example 1:Input: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5Output: 1-&gt;2-&gt;5Example 2:Input: 1-&gt;1-&gt;1-&gt;2-&gt;3Output: 2-&gt;3 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if (!head || !head-&gt;next) return head; int val = head-&gt;val; ListNode* cur = head-&gt;next; if (cur-&gt;val != val) &#123; head-&gt;next = deleteDuplicates(cur); return head; &#125; while (cur &amp;&amp; cur-&gt;val == val) cur = cur-&gt;next; return deleteDuplicates(cur); &#125;&#125;; Reorder List Leetcode 143 Given a singly linked list L: L0→L1→…→Ln-1→Ln,reorder it to: L0→Ln→L1→Ln-1→L2→Ln-2→… You may not modify the values in the list’s nodes, only nodes itself may be changed.12345Example 1:Given 1-&gt;2-&gt;3-&gt;4, reorder it to 1-&gt;4-&gt;2-&gt;3.Example 2:Given 1-&gt;2-&gt;3-&gt;4-&gt;5, reorder it to 1-&gt;5-&gt;2-&gt;4-&gt;3. 12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void reorderList(ListNode* head) &#123; if (!head || !head-&gt;next) return; ListNode* fast = head, *slow = head; while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) &#123; fast = fast-&gt;next-&gt;next; slow = slow-&gt;next; &#125; auto mid = slow-&gt;next; slow-&gt;next = NULL; ListNode* cur = NULL; while (mid) &#123; ListNode* temp = mid-&gt;next; mid-&gt;next = cur; cur = mid; mid = temp; &#125; mid = cur; cur = head; while (mid) &#123; ListNode* temp = cur-&gt;next; cur-&gt;next = mid; mid = mid-&gt;next; cur-&gt;next-&gt;next = temp; cur = temp; &#125; &#125;&#125;; Reverse Linked List II Leetcode 92 Reverse a linked list from position m to n. Do it in one-pass. Note: 1 ≤ m ≤ n ≤ length of list.123Example:Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; if (m == n) return head; ListNode* ret = new ListNode(-1); ret-&gt;next = head; auto cur = ret; // 因为从1开始数，所以m-1 for (int i = 0; i &lt; m - 1; i++) cur = cur-&gt;next; auto start = cur-&gt;next; for (int i = 0; i &lt; n - m; i++) &#123; auto temp = start-&gt;next; start-&gt;next = temp-&gt;next; temp-&gt;next = cur-&gt;next; cur-&gt;next = temp; &#125; return ret-&gt;next; &#125;&#125;; 栈132 Pattern Leetcode 456 Given a sequence of n integers a1, a2, …, an, a 132 pattern is a subsequence ai, aj, ak such that i &lt; j &lt; k and ai &lt; ak &lt; aj. Design an algorithm that takes a list of n numbers as input and checks whether there is a 132 pattern in the list. Note: n will be less than 15,000.1234567891011121314Example 1:Input: [1, 2, 3, 4]Output: FalseExplanation: There is no 132 pattern in the sequence.Example 2:Input: [3, 1, 4, 2]Output: TrueExplanation: There is a 132 pattern in the sequence: [1, 4, 2].Example 3:Input: [-1, 3, 2, 0]Output: TrueExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0]. 12345678910111213141516171819class Solution &#123;public: bool find132pattern(vector&lt;int&gt;&amp; nums) &#123; stack&lt;pair&lt;int, int&gt;&gt; s; for (auto i : nums) &#123; if (s.empty() || s.top().second &gt; i) &#123; s.push(make_pair(i, i)); &#125; else if (s.top().second &lt; i) &#123; int m = s.top().second; if (s.top().first &gt; i) return true; while (!s.empty() &amp;&amp; s.top().first &lt;= i) s.pop(); if (!s.empty() &amp;&amp; s.top().second &lt; i) return true; s.push(&#123;i, m&#125;); &#125; &#125; return false; &#125;&#125;; Next Greater Element II Leetcode 503 Given a circular array (the next element of the last element is the first element of the array), print the Next Greater Number for every element. The Next Greater Number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn’t exist, output -1 for this number. 1234567Example 1:Input: [1,2,1]Output: [2,-1,2]Explanation: The first 1&apos;s next greater number is 2; The number 2 can&apos;t find next greater number; The second 1&apos;s next greater number needs to search circularly, which is also 2.Note: The length of given array won&apos;t exceed 10000. 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return vector&lt;int&gt;(); int len = nums.size(); stack&lt;int&gt; s; vector&lt;int&gt; ret(len, -1); for (int i = 0; i &lt; len * 2; i++) &#123; while (!s.empty() &amp;&amp; nums[s.top()] &lt; nums[i % len]) &#123; ret[s.top()] = nums[i % len]; s.pop(); &#125; if (i &lt; len) s.push(i); &#125; return ret; &#125;&#125;; Binary Search Tree Iterator Leetcode 173 Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. 1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class BSTIterator &#123;public: stack&lt;TreeNode*&gt; s; void helper(TreeNode* cur) &#123; while (cur) &#123; s.push(cur); cur = cur-&gt;left; &#125; &#125; BSTIterator(TreeNode *root) &#123; helper(root); &#125; /** @return whether we have a next smallest number */ bool hasNext() &#123; return !s.empty(); &#125; /** @return the next smallest number */ int next() &#123; auto cur = s.top(); s.pop(); helper(cur-&gt;right); return cur-&gt;val; &#125;&#125;;/** * Your BSTIterator will be called like this: * BSTIterator i = BSTIterator(root); * while (i.hasNext()) cout &lt;&lt; i.next(); */ Verify Preorder Serialization of a Binary Tree Leetcode 331 One way to serialize a binary tree is to use pre-order traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as #.1234567 _9_ / \ 3 2 / \ / \ 4 1 # 6/ \ / \ / \# # # # # # For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where # represents a null node. Given a string of comma separated values, verify whether it is a correct preorder traversal serialization of a binary tree. Find an algorithm without reconstructing the tree. Each comma separated value in the string must be either an integer or a character ‘#’ representing null pointer. You may assume that the input format is always valid, for example it could never contain two consecutive commas such as “1,,3”. 1234567891011Example 1:Input: &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;Output: trueExample 2:Input: &quot;1,#&quot;Output: falseExample 3:Input: &quot;9,#,#,1&quot;Output: false 1234567891011121314151617181920212223242526class Solution &#123;public: bool isValidSerialization(string preorder) &#123; if (preorder.empty()) return false; vector&lt;string&gt; s; string ans; for (auto c : preorder) &#123; if (c == ',') &#123; s.push_back(ans); ans = ""; &#125; else ans.push_back(c); &#125; s.push_back(ans); int d = 0; for (int i = 0; i &lt; s.size() - 1; i++) &#123; string temp = s[i]; if (temp == "#") &#123; if (!d) return false; else d--; &#125; else d++; &#125; return !d &amp;&amp; s.back() == "#"; &#125;&#125;; HashTable 哈希表通常用来记录一些中间状态从而实现O(1)，这里提供一些比较典型的例子，之后不断补充… Max Points on a Line Leetcode 149 Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.12345678910111213141516171819202122232425Example 1:Input: [[1,1],[2,2],[3,3]]Output: 3Explanation:^|| o| o| o +-------------&gt;0 1 2 3 4Example 2:Input: [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]Output: 4Explanation:^|| o| o o| o| o o+-------------------&gt;0 1 2 3 4 5 6 12345678910111213141516171819202122232425262728293031323334353637383940/** * Definition for a point. * struct Point &#123; * int x; * int y; * Point() : x(0), y(0) &#123;&#125; * Point(int a, int b) : x(a), y(b) &#123;&#125; * &#125;; */class Solution &#123;public: int maxPoints(vector&lt;Point&gt;&amp; points) &#123; int ret = 0; int len = points.size(); if (len &lt; 3) return len; for (int i = 0; i &lt; len; i++) &#123; map&lt;pair&lt;int, int&gt;, int&gt; m; int vertical = 0, overlap = 0, local_ret = 0; for (int j = i + 1; j &lt; len; j++) &#123; int a = points[i].x - points[j].x; int b = points[i].y - points[j].y; if (!a &amp;&amp; !b) overlap ++; else if (!a) vertical ++; else &#123; int k = GCD(a, b); auto ans = make_pair(a / k, b / k); m[ans] ++; local_ret = max(local_ret, m[ans]); &#125; local_ret = max(local_ret, vertical); &#125; ret = max(ret, local_ret + overlap + 1); &#125; return ret; &#125; int GCD(int a, int b) &#123; if (!b) return a; else return GCD(b, a % b); &#125;&#125;; 桶Contains Duplicate III Leetcode 220 Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k. 1234567891011Example 1:Input: nums = [1,2,3,1], k = 3, t = 0Output: trueExample 2:Input: nums = [1,0,1,1], k = 1, t = 2Output: trueExample 3:Input: nums = [1,5,9,1,5,9], k = 2, t = 3Output: false 123456789101112131415161718192021222324class Solution &#123;public: long long helper(long long num, long long w) &#123; return num &gt;= 0 ? num / w : ((num + 1) / w - 1); &#125; bool containsNearbyAlmostDuplicate(vector&lt;int&gt;&amp; nums, int k, int t) &#123; if (t &lt; 0) return false; int n = nums.size(); long long w = t + 1; unordered_map&lt;long long, int&gt; m; for (int i = 0; i &lt; n; i++) &#123; long long ID = helper(nums[i], w); if (m.find(ID) != m.end()) return true; // 要注意不能用t比较大小否则int会溢出 if (m.find(ID - 1) != m.end() &amp;&amp; abs(nums[i] - nums[m[ID - 1]]) &lt; w) return true; if (m.find(ID + 1) != m.end() &amp;&amp; abs(nums[i] - nums[m[ID + 1]]) &lt; w) return true; m[ID] = i; if (i &gt;= k) &#123; m.erase(helper(nums[i - k], w)); &#125; &#125; return false; &#125;&#125;; 树最近公共祖先12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;unordered_set&gt;#include &lt;iostream&gt;using namespace std;struct TreeNode &#123; int val; TreeNode* left, *right; TreeNode(int x): val(x), left(NULL), right(NULL) &#123;&#125;&#125;;TreeNode* build() &#123; int c; cin &gt;&gt; c; if (c == -1) return NULL; TreeNode* root = new TreeNode(c); root-&gt;left = build(); root-&gt;right = build(); return root;&#125;int helper(TreeNode* root, int&amp; index, unordered_set&lt;int&gt;&amp; m) &#123; if (!root) return -1; int x = root-&gt;val; int l, r; if (m.find(x) != m.end()) &#123; m.erase(x); l = helper(root-&gt;left, index, m); if (l != -1) &#123; index = x; return l + 1; &#125; r = helper(root-&gt;right, index, m); if (r != -1) &#123; index = x; return 1 + r; &#125; return 0; &#125; else &#123; l = 1 + helper(root-&gt;left, index, m); if (index != -1) return l - 1; r = 1 + helper(root-&gt;right, index, m); if (index != -1) return r - 1; if (!l &amp;&amp; !r) return -1; if (l &amp;&amp; r) &#123; index = root-&gt;val; return l + r - 1; &#125; return l + r; &#125;&#125;int main() &#123; TreeNode* root = build(); int index = -1; unordered_set&lt;int&gt; m; for (int i = 0; i &lt; 2; i++) &#123; int c; cin &gt;&gt; c; m.insert(c); &#125; cout &lt;&lt; helper(root, index, m) &lt;&lt; endl; cout &lt;&lt; index &lt;&lt; endl; return 0;&#125; 指定节点距离叶子节点最近的距离此题是之前面试中一道题，题目意思是如果指定一个值（若存在则唯一存在），寻找距离此节点最近叶子节点的距离，因为此题的细节比较多，所以这里也列出来 例如：按前序遍历的树 1,2,3,4,5,#,#,#,6,7,#,#,8,9,#,10,#,#,11,#,#,#,12,#,# 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;climits&gt;using namespace std;struct TreeNode &#123; int val; TreeNode* left, *right; TreeNode(int x): val(x), left(NULL), right(NULL) &#123;&#125;;&#125;;TreeNode* build(int&amp; index, vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if (index == n) return NULL; int val = nums[index++]; if (val == -1) return NULL; TreeNode* ret = new TreeNode(val); ret-&gt;left = build(index, nums); ret-&gt;right = build(index, nums); return ret;&#125;void helper(int&amp; ret, int&amp; l, int&amp; r, int&amp; m, int target, TreeNode* root) &#123; l = r = m = 0; if (!root) return; int val = root-&gt;val; if (val == target) &#123; m = 1; &#125; if (!root-&gt;left &amp;&amp; !root-&gt;right) &#123; if (m) ret = 0; return; &#125; int ll, lr, rl, rr, ml, mr; helper(ret, ll, lr, ml, target, root-&gt;left); helper(ret, rl, rr, mr, target, root-&gt;right); if (m) &#123; if (!root-&gt;left) ret = min(ret, min(rl, rr) + 1); if (!root-&gt;right) ret = min(ret, min(ll, lr) + 1); if (root-&gt;left &amp;&amp; root-&gt;right) &#123; int ans = min(min(ll, lr) + 1, min(rl, rr) + 1); ret = min(ret, ans); &#125; return; &#125; if (ml) &#123; if (root-&gt;right) &#123; ret = min(ret, min(rl, rr) + ll + 2); //cout &lt;&lt; "ml " &lt;&lt; ret&lt;&lt; endl; &#125; l = r = ll + 1; m = 1; return; &#125; else if (mr) &#123; if (root-&gt;left) &#123; ret = min(ret, min(ll, lr) + rr + 2); //cout &lt;&lt; "mr " &lt;&lt; ret&lt;&lt; endl; &#125; l = r = rr + 1; m = 1; return; &#125; else &#123; l = !root-&gt;left ? INT_MAX : min(ll, lr) + 1; r = !root-&gt;right ? INT_MAX : min(rr, rl) + 1; //cout &lt;&lt; "mid: " &lt;&lt; val &lt;&lt; " " &lt;&lt; l &lt;&lt; " " &lt;&lt; r &lt;&lt; endl; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; int index = 0; TreeNode* root = build(index, nums); for (int i = 0; i &lt; 12; i++) &#123; int ret = INT_MAX; int m = 0, l, r; helper(ret, l, r, m, i + 1, root); cout &lt;&lt; i + 1 &lt;&lt; " "; if (m) cout &lt;&lt; ret &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; &#125; return 0;&#125;/*251 2 3 4 5 -1 -1 -1 6 7 -1 -1 8 9 -1 10 -1 -1 11 -1 -1 -1 12 -1 -11 12 23 24 15 46 17 38 19 110 311 312 3*//*251 2 3 4 5 -1 -1 -1 6 7 -1 -1 8 9 -1 10 -1 -1 11 -1 -1 -1 12 -1 -1*/ Populating Next Right Pointers in Each Node II Leetcode 117 Given a binary tree12345struct TreeLinkNode &#123; TreeLinkNode *left; TreeLinkNode *right; TreeLinkNode *next;&#125; Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL. Initially, all next pointers are set to NULL. 1234567891011121314151617181920Note:You may only use constant extra space.Recursive approach is fine, implicit stack space does not count as extra space for this problem.Example:Given the following binary tree, 1 / \ 2 3 / \ \4 5 7After calling your function, the tree should look like: 1 -&gt; NULL / \ 2 -&gt; 3 -&gt; NULL / \ \4-&gt; 5 -&gt; 7 -&gt; NULL 1234567891011121314151617181920212223242526272829303132333435/** * Definition for binary tree with next pointer. * struct TreeLinkNode &#123; * int val; * TreeLinkNode *left, *right, *next; * TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: void connect(TreeLinkNode *root) &#123; if (!root) return; TreeLinkNode* pre = root; pre-&gt;next = NULL; while (pre) &#123; while (pre &amp;&amp; !pre-&gt;left &amp;&amp; !pre-&gt;right) pre = pre-&gt;next; if (!pre) continue; TreeLinkNode* head = pre-&gt;left ? pre-&gt;left : pre-&gt;right; TreeLinkNode* cur = head; while (pre) &#123; if (pre-&gt;left) &#123; cur-&gt;next = pre-&gt;left; cur = cur-&gt;next; &#125; if (pre-&gt;right) &#123; cur-&gt;next = pre-&gt;right; cur = cur-&gt;next; &#125; pre = pre-&gt;next; &#125; cur-&gt;next = NULL; pre = head; &#125; &#125;&#125;; Count Complete Tree Nodes Leetcode 222 Given a complete binary tree, count the number of nodes. Note: Definition of a complete binary tree from Wikipedia:In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.12345678910Example:Input: 1 / \ 2 3 / \ /4 5 6Output: 6 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; // 本题的重点是不能遍历所有， // 所以如果是完全树，则直接返回该树的节点数， // 如果不是，则返回左子树加右子树加自己的节点数 if (!root) return 0; int h1 = 0, h2 = 0; TreeNode* l = root, *r = root; while (l) &#123; h1 ++; l = l-&gt;left; &#125; while (r) &#123; h2 ++; r = r-&gt;right; &#125; if (h1 == h2) return pow(2, h1) - 1; return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125;&#125;; Delete Node in a BST Leetcode 450 Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST. Basically, the deletion can be divided into two stages: Search for a node to remove.If the node is found, delete the node.Note: Time complexity should be O(height of tree).12345678910111213141516171819202122232425262728Example:root = [5,3,6,2,4,null,7]key = 3 5 / \ 3 6 / \ \2 4 7Given key to delete is 3. So we find the node with value 3 and delete it.One valid answer is [5,4,6,2,null,null,7], shown in the following BST. 5 / \ 4 6 / \2 7Another valid answer is [5,2,6,null,4,null,7]. 5 / \ 2 6 \ \ 4 7 12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* deleteNode(TreeNode* root, int key) &#123; if (!root) return NULL; if (root-&gt;val == key) &#123; if (!root-&gt;left) return root-&gt;right; if (!root-&gt;right) return root-&gt;left; TreeNode* cur = root-&gt;right; while (cur-&gt;left) cur = cur-&gt;left; swap(root-&gt;val, cur-&gt;val); &#125; root-&gt;left = deleteNode(root-&gt;left, key); root-&gt;right = deleteNode(root-&gt;right, key); return root; &#125;&#125;; Serialize and Deserialize BST Leetcode 449 Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment. Design an algorithm to serialize and deserialize a binary search tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary search tree can be serialized to a string and this string can be deserialized to the original tree structure. The encoded string should be as compact as possible. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Codec &#123;public: void helper(TreeNode* root, string&amp; ret) &#123; if (!root) ret += ",#"; else &#123; ret += "," + to_string(root-&gt;val); helper(root-&gt;left, ret); helper(root-&gt;right, ret); &#125; &#125; // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; string ret; helper(root, ret); return ret.substr(1); &#125; TreeNode* helper1(string&amp; data, int&amp; index) &#123; string ans; while (index &lt; data.size() &amp;&amp; data[index] != ',') &#123; ans.push_back(data[index++]); &#125; if (index &lt; data.size()) index ++; if (ans == "#") return NULL; int syn = 1; if (ans[0] == '-') &#123; ans.erase(ans.begin()); syn = -1; &#125; int val = 0; for (auto i : ans) &#123; val = val * 10 + (i - '0'); &#125; val *= syn; TreeNode* ret = new TreeNode(val); ret-&gt;left = helper1(data, index); ret-&gt;right = helper1(data, index); return ret; &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; int index = 0; return helper1(data, index); &#125;&#125;;// Your Codec object will be instantiated and called as such:// Codec codec;// codec.deserialize(codec.serialize(root)); 前缀树Implement Trie (Prefix Tree) Leetcode 208 Implement a trie with insert, search, and startsWith methods. 12345678910Example:Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;); // returns truetrie.search(&quot;app&quot;); // returns falsetrie.startsWith(&quot;app&quot;); // returns truetrie.insert(&quot;app&quot;); trie.search(&quot;app&quot;); // returns true 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556struct TrieNode &#123; TrieNode* child[26]; bool isKey; TrieNode() : isKey(false) &#123; memset(child, NULL, sizeof(child)); &#125;&#125;;class Trie &#123;public: TrieNode* root; /** Initialize your data structure here. */ Trie() &#123; root = new TrieNode(); &#125; /** Inserts a word into the trie. */ void insert(string word) &#123; TrieNode* cur = root; for (auto i : word) &#123; int c = i - 'a'; if (!cur-&gt;child[c]) cur-&gt;child[c] = new TrieNode(); cur = cur-&gt;child[c]; &#125; cur-&gt;isKey = true; &#125; /** Returns if the word is in the trie. */ bool search(string word) &#123; TrieNode* cur = root; for (auto i : word) &#123; int c = i - 'a'; if (!cur-&gt;child[c]) return false; cur = cur-&gt;child[c]; &#125; return cur-&gt;isKey; &#125; /** Returns if there is any word in the trie that starts with the given prefix. */ bool startsWith(string prefix) &#123; TrieNode* cur = root; for (auto i : prefix) &#123; int c = i - 'a'; if (!cur-&gt;child[c]) return false; cur = cur-&gt;child[c]; &#125; return true; &#125;&#125;;/** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * bool param_2 = obj.search(word); * bool param_3 = obj.startsWith(prefix); */ Maximum XOR of Two Numbers in an Array Leetcode 421 Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤ ai &lt; 231. Find the maximum result of ai XOR aj, where 0 ≤ i, j &lt; n. Could you do this in O(n) runtime? 1234567Example:Input: [3, 10, 5, 25, 2, 8]Output: 28Explanation: The maximum result is 5 ^ 25 = 28. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct TrieNode &#123; TrieNode* child[2]; TrieNode() &#123; memset(child, NULL, sizeof(child)); &#125;&#125;;class Solution &#123;public: int findMaximumXOR(vector&lt;int&gt;&amp; nums) &#123; TrieNode* root = new TrieNode(); for (auto n : nums) &#123; TrieNode* cur = root; // 必须是从左往右，因为不是这样的话就不是最大，这里用了贪心 for (int i = 31; i &gt;= 0; i--) &#123; int c = ((n &gt;&gt; i) &amp; 1); if (!cur-&gt;child[c]) cur-&gt;child[c] = new TrieNode(); cur = cur-&gt;child[c]; &#125; &#125; int ret = 0; for (auto n : nums) &#123; TrieNode* cur = root; int ans = 0; for (int i = 31; i &gt;= 0; i--) &#123; int c = ((n &gt;&gt; i) &amp; 1); if (cur-&gt;child[!c]) &#123; ans &lt;&lt;= 1; ans |= 1; cur = cur-&gt;child[!c]; &#125; // 只要有一条路肯定能走到底，所以不用判断为空的情况 else &#123; ans &lt;&lt;= 1; cur = cur-&gt;child[c]; &#125; &#125; for (int i = 0; i &lt; 32; i++) &#123; cout &lt;&lt; ((2147483648 &gt;&gt; i) &amp; 1); &#125; cout &lt;&lt; endl; ret = max(ret, ans); &#125; return ret; &#125;&#125;; Word Search II Leetcode 212 Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. 123456789101112Example:Input: words = [&quot;oath&quot;,&quot;pea&quot;,&quot;eat&quot;,&quot;rain&quot;] and board =[ [&apos;o&apos;,&apos;a&apos;,&apos;a&apos;,&apos;n&apos;], [&apos;e&apos;,&apos;t&apos;,&apos;a&apos;,&apos;e&apos;], [&apos;i&apos;,&apos;h&apos;,&apos;k&apos;,&apos;r&apos;], [&apos;i&apos;,&apos;f&apos;,&apos;l&apos;,&apos;v&apos;]]Output: [&quot;eat&quot;,&quot;oath&quot;] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354struct TrieNode &#123; TrieNode* child[26]; bool isKey; TrieNode() : isKey(false) &#123; memset(child, NULL, sizeof(child)); &#125;&#125;;class Solution &#123;public: void helper(TrieNode* root, vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, string ans, unordered_set&lt;string&gt;&amp; ret) &#123; ans = ans + board[x][y]; if (root-&gt;isKey) &#123; ret.insert(ans); &#125; board[x][y] = '\0'; int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; int m = board.size(), n = board[0].size(); for (int i = 0; i &lt; 4; i++) &#123; int X = x + a[i], Y = y + b[i]; if (X &gt;= 0 &amp;&amp; X &lt; m &amp;&amp; Y &gt;= 0 &amp;&amp; Y &lt; n &amp;&amp; board[X][Y] != '\0') &#123; int c = board[X][Y] - 'a'; if (root-&gt;child[c]) &#123; helper(root-&gt;child[c], board, X, Y, ans, ret); &#125; &#125; &#125; board[x][y] = ans.back(); &#125; vector&lt;string&gt; findWords(vector&lt;vector&lt;char&gt;&gt;&amp; board, vector&lt;string&gt;&amp; words) &#123; if (board.empty() || board[0].empty()) return vector&lt;string&gt;(); TrieNode* root = new TrieNode(); for (auto s : words) &#123; auto cur = root; for (auto i : s) &#123; int c = i - 'a'; if (!cur-&gt;child[c]) cur-&gt;child[c] = new TrieNode(); cur = cur-&gt;child[c]; &#125; cur-&gt;isKey = true; &#125; unordered_set&lt;string&gt; ret_set; for (int i = 0; i &lt; board.size(); i++) &#123; for (int j = 0; j &lt; board[0].size(); j++) &#123; int c = board[i][j] - 'a'; if (root-&gt;child[c]) helper(root-&gt;child[c], board, i, j, "", ret_set); &#125; &#125; vector&lt;string&gt; ret; for (auto s : ret_set) &#123; ret.push_back(s); &#125; return ret; &#125;&#125;; 堆TopKKth Largest Element in an Array Leetcode 215 Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.1234567Example 1:Input: [3,2,1,5,6,4] and k = 2Output: 5Example 2:Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4 123456789101112131415161718192021222324252627282930class Solution &#123;public: void heapfy(vector&lt;int&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; nums[smallest] &gt; nums[left]) smallest = left; if (right &lt; max &amp;&amp; nums[smallest] &gt; nums[right]) smallest = right; if (index != smallest) &#123; swap(nums[index], nums[smallest]); heapfy(nums, smallest, max); &#125; &#125; int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); if (len &lt; k) return -1; vector&lt;int&gt; ans; for (int i = 0; i &lt; k; i++) &#123; ans.push_back(nums[i]); &#125; for (int i = k / 2; i &gt;= 0; i--) heapfy(ans, i, k); for (int i = k; i &lt; len; i++) &#123; if (ans[0] &lt; nums[i]) &#123; ans[0] = nums[i]; for (int j = k / 2; j &gt;= 0; j--) heapfy(ans, j, k); &#125; &#125; return ans[0]; &#125;&#125;; Top K Frequent Elements Leetcode 347 Given a non-empty array of integers, return the k most frequent elements.1234567Example 1:Input: nums = [1,1,1,2,2,3], k = 2Output: [1,2]Example 2:Input: nums = [1], k = 1Output: [1] 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: void heapfy(vector&lt;int&gt;&amp; nums, int index, int max, unordered_map&lt;int, int&gt;&amp; m) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; m[nums[left]] &lt; m[nums[smallest]]) smallest = left; if (right &lt; max &amp;&amp; m[nums[right]] &lt; m[nums[smallest]]) smallest = right; if (smallest != index) &#123; swap(nums[smallest], nums[index]); heapfy(nums, smallest, max, m); &#125; &#125; vector&lt;int&gt; topKFrequent(vector&lt;int&gt;&amp; nums, int k) &#123; unordered_map&lt;int, int&gt; m; vector&lt;int&gt; ans; for (auto i : nums) &#123; m[i] ++; if (m[i] == 1) ans.push_back(i); &#125; int len = ans.size(); if (len &lt; k) return ans; vector&lt;int&gt; ret; for (int i = 0; i &lt; k; i++) ret.push_back(ans[i]); for (int i = k / 2 - 1; i &gt;= 0; i--) heapfy(ret, i, k, m); for (int i = k; i &lt; len; i++) &#123; if (m[ans[i]] &gt; m[ret[0]]) &#123; ret[0] = ans[i]; for (int j = k / 2 - 1; j &gt;= 0; j--) heapfy(ret, j, k, m); &#125; &#125; return ret; &#125;&#125;; Find K Pairs with Smallest Sums Leetcode 373 You are given two integer arrays nums1 and nums2 sorted in ascending order and an integer k. Define a pair (u,v) which consists of one element from the first array and one element from the second array. Find the k pairs (u1,v1),(u2,v2) …(uk,vk) with the smallest sums.1234567891011121314151617Example 1:Given nums1 = [1,7,11], nums2 = [2,4,6], k = 3Return: [1,2],[1,4],[1,6]The first 3 pairs are returned from the sequence:[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]Example 2:Given nums1 = [1,1,2], nums2 = [1,2,3], k = 2Return: [1,1],[1,1]The first 2 pairs are returned from the sequence:[1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]Example 3:Given nums1 = [1,2], nums2 = [3], k = 3 Return: [1,3],[2,3]All possible pairs are returned from the sequence:[1,3],[2,3] 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: void heapfy(vector&lt;pair&lt;int, int&gt;&gt;&amp; nums, vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; A[nums[left].first] + B[nums[left].second] &lt; A[nums[smallest].first] + B[nums[smallest].second]) smallest = left; if (right &lt; max &amp;&amp; A[nums[right].first] + B[nums[right].second] &lt; A[nums[smallest].first] + B[nums[smallest].second]) smallest = right; if (index != smallest) &#123; swap(nums[index], nums[smallest]); heapfy(nums, A, B, smallest, max); &#125; &#125; vector&lt;pair&lt;int, int&gt;&gt; kSmallestPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, int k) &#123; if (nums1.empty() || nums2.empty()) return vector&lt;pair&lt;int, int&gt;&gt;(); vector&lt;pair&lt;int, int&gt;&gt; ret; vector&lt;pair&lt;int, int&gt;&gt; ans; ans.push_back(make_pair(0, 0)); for (int i = 0; i &lt; k &amp;&amp; !ans.empty(); i++) &#123; auto t = ans[0]; ans.erase(ans.begin()); ret.push_back(make_pair(nums1[t.first], nums2[t.second])); if (t.first == 0 &amp;&amp; t.second + 1 &lt; nums2.size()) ans.push_back(make_pair(0, t.second + 1)); if (t.first + 1 &lt; nums1.size()) ans.push_back(make_pair(t.first + 1, t.second)); int len = ans.size(); for (int j = len / 2; j &gt;= 0; j--) heapfy(ans, nums1, nums2, j, len); &#125; return ret; &#125;&#125;; Find Median from Data Stream Leetcode 295 Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. For example,[2,3,4], the median is 3 [2,3], the median is (2 + 3) / 2 = 2.5 Design a data structure that supports the following two operations: void addNum(int num) - Add a integer number from the data stream to the data structure.double findMedian() - Return the median of all elements so far. 1234567Example:addNum(1)addNum(2)findMedian() -&gt; 1.5addNum(3) findMedian() -&gt; 2 12345678910111213141516171819202122232425262728293031class MedianFinder &#123;public: /** initialize your data structure here. */ priority_queue&lt;int&gt; small; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; large; MedianFinder() &#123; &#125; void addNum(int num) &#123; small.push(num); large.push(small.top()); small.pop(); if (small.size() &lt; large.size()) &#123; small.push(large.top()); large.pop(); &#125; &#125; double findMedian() &#123; if (large.size() == small.size()) return (large.top() + small.top()) / 2.0; return small.top(); &#125;&#125;;/** * Your MedianFinder object will be instantiated and called as such: * MedianFinder obj = new MedianFinder(); * obj.addNum(num); * double param_2 = obj.findMedian(); */ Sliding Window Median Leetcode 480 Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value. 12345678910111213141516171819Examples: [2,3,4] , the median is 3[2,3], the median is (2 + 3) / 2 = 2.5Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Your job is to output the median array for each window in the original array.For example,Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.Window position Median--------------- -----[1 3 -1] -3 5 3 6 7 1 1 [3 -1 -3] 5 3 6 7 -1 1 3 [-1 -3 5] 3 6 7 -1 1 3 -1 [-3 5 3] 6 7 3 1 3 -1 -3 [5 3 6] 7 5 1 3 -1 -3 5 [3 6 7] 6Therefore, return the median sliding window as [1,-1,-1,3,5,6]. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123;public: vector&lt;double&gt; medianSlidingWindow(vector&lt;int&gt;&amp; nums, int k) &#123; int len = nums.size(); if (len &lt; k) return vector&lt;double&gt;(); vector&lt;double&gt; ret; unordered_map&lt;int, int&gt; m; priority_queue&lt;int&gt; small; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; large; for (int i = 0; i &lt; k; i++) &#123; small.push(nums[i]); &#125; for (int i = 0; i &lt; k / 2; i++) &#123; large.push(small.top()); small.pop(); &#125; for (int i = k; i &lt;= len; i++) &#123; if (k &amp; 1) ret.push_back(small.top()); // 这里要用double，否则可能会溢出 else ret.push_back(((double)small.top() + (double)large.top()) / 2.0); if (i == len) continue; int blance = 0; int ans = nums[i]; if (ans &gt; small.top()) &#123; large.push(ans); blance ++; &#125; else &#123; small.push(ans); blance --; &#125; ans = nums[i - k]; if (ans &gt; small.top()) &#123; if (large.top() == ans) large.pop(); else m[ans]++; blance --; &#125; else &#123; if (small.top() == ans) small.pop(); else m[ans]++; blance ++; &#125; if (blance &gt; 0) &#123; small.push(large.top()); large.pop(); &#125; if (blance &lt; 0) &#123; large.push(small.top()); small.pop(); &#125; while (!small.empty() &amp;&amp; m[small.top()]) &#123; m[small.top()] --; small.pop(); &#125; while (!large.empty() &amp;&amp; m[large.top()]) &#123; m[large.top()] --; large.pop(); &#125; &#125; return ret; &#125;&#125;; Design Twitter Leetcode 355 Design a simplified version of Twitter where users can post tweets, follow/unfollow another user and is able to see the 10 most recent tweets in the user’s news feed. Your design should support the following methods: postTweet(userId, tweetId): Compose a new tweet.getNewsFeed(userId): Retrieve the 10 most recent tweet ids in the user’s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.follow(followerId, followeeId): Follower follows a followee.unfollow(followerId, followeeId): Follower unfollows a followee.1234567891011121314151617181920212223242526Example:Twitter twitter = new Twitter();// User 1 posts a new tweet (id = 5).twitter.postTweet(1, 5);// User 1&apos;s news feed should return a list with 1 tweet id -&gt; [5].twitter.getNewsFeed(1);// User 1 follows user 2.twitter.follow(1, 2);// User 2 posts a new tweet (id = 6).twitter.postTweet(2, 6);// User 1&apos;s news feed should return a list with 2 tweet ids -&gt; [6, 5].// Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.twitter.getNewsFeed(1);// User 1 unfollows user 2.twitter.unfollow(1, 2);// User 1&apos;s news feed should return a list with 1 tweet id -&gt; [5],// since user 1 is no longer following user 2.twitter.getNewsFeed(1); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677struct tweet &#123; int id; int time; tweet(int id, int time) : id(id), time(time) &#123;&#125;;&#125;;class Twitter &#123;public: unordered_map&lt;int, unordered_set&lt;int&gt;&gt; fo; unordered_map&lt;int, vector&lt;tweet&gt;&gt; po; int current; /** Initialize your data structure here. */ Twitter() &#123; current = 0; &#125; /** Compose a new tweet. */ void postTweet(int userId, int tweetId) &#123; current ++; po[userId].push_back(tweet(tweetId, current)); &#125; void heapfy(vector&lt;tweet&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; nums[left].time &gt; nums[smallest].time) smallest = left; if (right &lt; max &amp;&amp; nums[right].time &gt; nums[smallest].time) smallest = right; if (smallest != index) &#123; swap(nums[smallest], nums[index]); heapfy(nums, smallest, max); &#125; &#125; /** Retrieve the 10 most recent tweet ids in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent. */ vector&lt;int&gt; getNewsFeed(int userId) &#123; // 此处在实际使用中应该使用多路归并的思路，但是这里为了简便就将所有数据放到堆中然后选出top10 vector&lt;tweet&gt; ans; for (auto i : fo[userId]) &#123; for (auto j : po[i]) &#123; ans.push_back(j); &#125; &#125; for (auto i : po[userId]) &#123; ans.push_back(i); &#125; int len = ans.size(); for (int i = len / 2 - 1; i &gt;= 0; i--) heapfy(ans, i, len); vector&lt;int&gt; ret; for (int i = len - 1; i &gt;= 0 &amp;&amp; ret.size() &lt; 10; i--) &#123; ret.push_back(ans[0].id); swap(ans[i], ans[0]); // 此处注意堆排序调整只需要调整一个路径就可以 heapfy(ans, 0, i); &#125; return ret; &#125; /** Follower follows a followee. If the operation is invalid, it should be a no-op. */ void follow(int followerId, int followeeId) &#123; if (followerId == followeeId) return; fo[followerId].insert(followeeId); &#125; /** Follower unfollows a followee. If the operation is invalid, it should be a no-op. */ void unfollow(int followerId, int followeeId) &#123; fo[followerId].erase(followeeId); &#125;&#125;;/** * Your Twitter object will be instantiated and called as such: * Twitter obj = new Twitter(); * obj.postTweet(userId,tweetId); * vector&lt;int&gt; param_2 = obj.getNewsFeed(userId); * obj.follow(followerId,followeeId); * obj.unfollow(followerId,followeeId); */ 实际中应该使用的是对已经排序了的数组使用多路归并，思路是堆中存放的是路角标和列角标的pair： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;iostream&gt;using namespace std;void heapfy(vector&lt;pair&lt;int, int&gt;&gt;&amp; ans, vector&lt;vector&lt;int&gt;&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int smallest = index; if (left &lt; max &amp;&amp; nums[ans[left].first][ans[left].second] &lt; nums[ans[smallest].first][ans[smallest].second]) smallest = left; if (right &lt; max &amp;&amp; nums[ans[right].first][ans[right].second] &lt; nums[ans[smallest].first][ans[smallest].second]) smallest = right; if (index != smallest) &#123; swap(ans[index], ans[smallest]); heapfy(ans, nums, smallest, max); &#125;&#125;vector&lt;int&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;int&gt; ret; vector&lt;pair&lt;int, int&gt;&gt; ans; int N = 0; for (int i = 0; i &lt; n; i++) &#123; N += nums[i].size(); ans.push_back(make_pair(i, 0)); &#125; for (int i = n /2; i &gt;= 0; i--) &#123; heapfy(ans, nums, i, n); &#125; while (ret.size() &lt; N) &#123; auto temp = ans[0]; ret.push_back(nums[temp.first][temp.second]); cout &lt;&lt; temp.first &lt;&lt; ":" &lt;&lt; temp.second &lt;&lt; ": "&lt;&lt; ret.back() &lt;&lt; endl; ans.erase(ans.begin()); if (temp.second + 1 &lt; nums[temp.first].size()) &#123; ans.push_back(make_pair(temp.first, temp.second + 1)); &#125; int len = ans.size(); for (int i = len / 2; i &gt;= 0; i--) heapfy(ans, nums, i, len); &#125; return ret;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;vector&lt;int&gt;&gt; nums; for (int i = 0; i &lt; n; i++) &#123; int t; cin &gt;&gt; t; vector&lt;int&gt; ans(t, 0); for (int j = 0; j &lt; t; j++) &#123; cin &gt;&gt; ans[j]; &#125; nums.push_back(ans); &#125; auto ret = helper(nums); for (auto i : ret) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>OJ</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 位操作相关整理]]></title>
    <url>%2F2018%2F08%2F11%2Fleetcode-summary-bit-manipulation%2F</url>
    <content type="text"><![CDATA[这里总结一些leetcode上比较经典的位操作例题与思路，分类和题目正在更新… 四则运算Pow(x, n) Leetcode 50 Implement pow(x, n), which calculates x raised to the power n (xn). 12Input: 2.00000, 10Output: 1024.00000 代码1234567891011121314class Solution &#123;public: double myPow(double x, int n) &#123; double ret = 1.0; // 注意要整型溢出 long N = abs((long) n); while (N) &#123; if (N &amp; 1) ret *= x; N &gt;&gt;= 1; x *= x; &#125; return n &gt; 0 ? ret : 1 / ret; &#125;&#125;; Divide Two Integers Leetcode 29 Given two integers dividend and divisor, divide two integers without using multiplication, division and mod operator. Return the quotient after dividing dividend by divisor. The integer division should truncate toward zero. Example 1:12Input: dividend = 10, divisor = 3Output: 3 Example 2:12Input: dividend = 7, divisor = -3Output: -2 123456789101112// 第一种思路是使用logclass Solution &#123;public: int divide(int dividend, int divisor) &#123; if (!divisor || (dividend == INT_MIN &amp;&amp; divisor == -1)) return INT_MAX; double t1 = log(fabs(dividend)); double t2 = log(fabs(divisor)); long long ret = exp(t1 - t2); int syn = (dividend &gt; 0) ^ (divisor &gt; 0); return syn &gt; 0 ? -ret : ret; &#125;&#125;; 123456789101112131415161718192021// 第二种思路是dividend = 2^k1*divisor + 2^k2*divisor + ...class Solution &#123;public: int divide(int dividend, int divisor) &#123; if (!divisor || (dividend == INT_MIN &amp;&amp; divisor == -1)) return INT_MAX; long long ret = 0; long long m = abs((long long)dividend); long long n = abs((long long)divisor); int syn = (dividend &gt; 0) ^ (divisor &gt; 0) ? -1 : 1; while (m &gt;= n) &#123; long long s = n, ans = 1; while (m &gt;= (s &lt;&lt; 1)) &#123; s &lt;&lt;= 1; ans &lt;&lt;= 1; &#125; m -= s; ret += ans; &#125; return syn * ret; &#125;&#125;; Sum of Two Integers Leetcode 371 Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -. Given a = 1 and b = 2, return 3. 代码123456789101112class Solution &#123;public: int getSum(int a, int b) &#123; while (b) &#123; // 加法器原理 int temp = a ^ b; b = (a &amp; b) &lt;&lt; 1; a = temp; &#125; return a; &#125;&#125;; 前缀相关Power of Two Leetcode 231 Given an integer, write a function to determine if it is a power of two.123Input: 1Output: true Explanation: 20 = 1 代码1234567class Solution &#123;public: bool isPowerOfTwo(int n) &#123; if (n &lt;= 0) return false; return !(n &amp; (n - 1)); &#125;&#125;; Bitwise AND of Numbers Range Leetcode 201 Given a range [m, n] where 0 &lt;= m &lt;= n &lt;= 2147483647, return the bitwise AND of all numbers in this range, inclusive. 12345Input: [5,7]Output: 4Input: [0,1]Output: 0 代码1234567class Solution &#123;public: int rangeBitwiseAnd(int m, int n) &#123; // 看相同的前缀 return n == m ? m : (rangeBitwiseAnd(m / 2, n / 2) &lt;&lt; 1); &#125;&#125;; Number Complement Leetcode 476 Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation. 123Input: 5Output: 2Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2. 代码123456class Solution &#123;public: int findComplement(int num) &#123; return ~num &amp; ((1 &lt;&lt; (int)log2(num)) - 1); &#125;&#125;; 位个数和位移动操作Number of 1 Bits Leetcode 191 Write a function that takes an unsigned integer and returns the number of ‘1’ bits it has (also known as the Hamming weight). 代码123456789101112class Solution &#123;public: int hammingWeight(uint32_t n) &#123; // 此题在剑指offer也有 n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) + (n &amp; 0x55555555); n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) + (n &amp; 0x33333333); n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) + (n &amp; 0x0F0F0F0F); n = ((n &amp; 0xFF00FF00) &gt;&gt; 8) + (n &amp; 0x00FF00FF); n = ((n &amp; 0xFFFF0000) &gt;&gt; 16) + (n &amp; 0x0000FFFF); return n; &#125;&#125;; Reverse Bits Leetcode 190 Reverse bits of a given 32 bits unsigned integer. 1234Input: 43261596Output: 964176192Explanation: 43261596 represented in binary as 00000010100101000001111010011100, return 964176192 represented in binary as 00111001011110000010100101000000. 1234567891011class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) | ((n &amp; 0x55555555) &lt;&lt; 1); n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) | ((n &amp; 0x33333333) &lt;&lt; 2); n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) | ((n &amp; 0x0F0F0F0F) &lt;&lt; 4); n = ((n &amp; 0xFF00FF00) &gt;&gt; 8) | ((n &amp; 0x00FF00FF) &lt;&lt; 8); n = ((n &amp; 0xFFFF0000) &gt;&gt; 16) | ((n &amp; 0x0000FFFF) &lt;&lt; 16); return n; &#125;&#125;; Total Hamming Distance Leetcode 477 The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Now your job is to find the total Hamming distance between all pairs of the given numbers. 1234567Input: 4, 14, 2Output: 6Explanation: In binary representation, the 4 is 0100, 14 is 1110, and 2 is 0010 (justshowing the four bits relevant in this case). So the answer will be:HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6. 代码123456789101112131415class Solution &#123;public: int totalHammingDistance(vector&lt;int&gt;&amp; nums) &#123; // 此题主要思想是将每一位分开计算 int ret = 0, n = nums.size(); for (int i = 0; i &lt; 31; i++) &#123; int cnt = 0; for (auto j : nums) &#123; cnt += (j &gt;&gt; i) &amp; 1; &#125; ret += cnt * (n - cnt); &#125; return ret; &#125;&#125;; 重复使用抑或操作在同一个整型上重复偶数次抑或同一个数会导致该数消失，可以使用抑或操作进行一些变化或引导一些变化 Missing Number Leetcode 268 Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.1234567Example 1:Input: [3,0,1]Output: 2Example 2:Input: [9,6,4,2,3,5,7,0,1]Output: 8 代码12345678910111213class Solution &#123;public: // 从1到n都被抑或一遍，然后再被覆盖一遍就会消失，被抑或一遍的就会剩下。 int missingNumber(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int ans = n; for (int i = 0; i &lt; n; i++) &#123; ans ^= i; ans ^= nums[i]; &#125; return ans; &#125;&#125;; Single Number Leetcode 136 Given a non-empty array of integers, every element appears twice except for one. Find that single one.1234567Example 1:Input: [2,2,1]Output: 1Example 2:Input: [4,1,2,1,2]Output: 4 代码12345678910class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for (auto i : nums) &#123; ans ^= i; &#125; return ans; &#125;&#125;; Single Number II Leetcode 137 Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. 1234567Example 1:Input: [2,2,3,2]Output: 3Example 2:Input: [0,1,0,1,0,1,99]Output: 99 代码1234567891011121314151617181920212223class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; /* 此题比较难理解，核心思想是利用状态机将每一位经过抑或操作后按照一定的条件变化 例如用三位数表示一位数分别经过1,2,3次抑或后的状态，即001-&gt;010-&gt;100 因为除了一个数都出现三次，所以只需要用两个数保存状态即可 通过总结规律发现，[0][1]-&gt;[1][0]-&gt;[0][0]， two保存所有经过两次抑或后的数的结果，one保存经过一次抑或操作后的数的结果 two一次由抑或之后和~one做与就可以完成状态的转换，one也是一样的 因为只有一个数出现一次，所以one就是最终结果。 */ int one = 0, two = 0; for (auto i : nums) &#123; one = ~two &amp; (i ^ one); two = ~one &amp; (i ^ two); &#125; return one; &#125;&#125;; Single Number III Leetcode 260 Given an array of numbers nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. 1234Example:Input: [1,2,1,3,2,5]Output: [3,5] 代码1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ans = 0; for (auto i : nums) &#123; ans ^= i; &#125; // 此步比较重要，选取一位为1的数，说明该位出现过一次 int m = (ans &amp; (ans - 1)) ^ ans; int a = 0, b = 0; for (auto i : nums) &#123; if (i &amp; m) a ^= i; else b ^= i; &#125; return vector&lt;int&gt;&#123;a, b&#125;; &#125;&#125;; 与位操作相关的数学题与位操作相关的数学题通常需要找规律或者先证明，此部分也会不断补充… Integer Replacement Leetcode 397 1234567891011121314151617181920212223Given a positive integer n and you can do operations as follow:If n is even, replace n with n/2.If n is odd, you can replace n with either n + 1 or n - 1.What is the minimum number of replacements needed for n to become 1?Example 1:Input:8Output:3Explanation:8 -&gt; 4 -&gt; 2 -&gt; 1Example 2:Input:7Output:4Explanation:7 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1or7 -&gt; 6 -&gt; 3 -&gt; 2 -&gt; 1 代码12345678910111213141516class Solution &#123;public: int integerReplacement(int N) &#123; long long n = N; int ret = 0; while (n != 1) &#123; ret ++; if (n &amp; 1) &#123; if (n &amp; 2 &amp;&amp; n != 3) n++; else n --; &#125; else n &gt;&gt;= 1; &#125; return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>OJ</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图相关内容总结]]></title>
    <url>%2F2018%2F06%2F21%2FgrGraph-Theory-Algorithm%2F</url>
    <content type="text"><![CDATA[此部分是遇到的图论相关算法总结，正在不断更新….关于图论的相关基础知识和每个算法的具体推导，可以参考演算法笔记中的Graph Theory和Combinatorial Optimization部分。 路径相关算法欧拉回路和欧拉路径欧拉回路是指不令笔离开纸面，可画过图中每条边仅一次，且可以回到起点的一条回路。同样，欧拉路径就是从一点出发，能遍历所有图中的边，从而形成的路径。 判断欧拉回路的条件从图论里面可以知道，是整个图连通，然后每个点的入度等于出度就可以确定从任何一点出发都可遍历所有图。 寻找欧拉回路和路径的算法，也是一种贪心，每次尽量选择出度未走路径多的点作为下一个遍历的点，否则如果选择了该点，则无法再回来。因为这个算法是一种贪心，又保证连通，所以可以用栈保存行走的路径，如果不能再走向其他点，则说明不能再走到别的点，此时说明路径无法再扩展路径已经形成，所以。 因此如果用dfs回溯也是可以一边迭代完成。 欧拉路径的算法验证可以参考leetcode332 这里给出leetcode332的算法解答，也可以看做模板：12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; findItinerary(vector&lt;pair&lt;string, string&gt;&gt; tickets) &#123; vector&lt;string&gt; ret; unordered_map&lt;string, vector&lt;string&gt;&gt; map; for (auto i : tickets) &#123; map[i.first].push_back(i.second); &#125; for (auto &amp;i : map) &#123; sort(i.second.begin(), i.second.end()); &#125; stack&lt;string&gt; s; s.push("JFK"); while (!s.empty()) &#123; auto temp = s.top(); if (map[temp].empty()) &#123; ret.push_back(temp); s.pop(); &#125; else &#123; s.push(map[temp][0]); map[temp].erase(map[temp].begin()); &#125; &#125; reverse(ret.begin(), ret.end()); return ret; &#125;&#125;; 单源最短路径算法单元最短路径的意思为给定七点，求出起点到图上每个点的最短路径，一对多。 通常求最短路径的思路有两种 第一种是逐步确定每个点的最短路径长度，一旦确定后就不会再更改了，负边不适用。 第二种是某点确定最短路径长度之后，还要不断修正，整个过程就是不断修正的过程，负边也适用。 Dijkstra算法 最短路径最经典的算法，是贪心发的一种应用，对于处理非负权的图比较有效。 同样，此算法也可以用于计算最长路，但是需要把所有的权值都改成负数。 Dijkstra算法模板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;climits&gt;using namespace std;vector&lt;int&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;int&gt;&amp; parents, vector&lt;unordered_set&lt;int&gt;&gt;&amp; adj) &#123; int n = parents.size(); unordered_set&lt;int&gt; s; // 没有访问的点 vector&lt;int&gt; dp(n, INT_MAX); // 保存当前每个点最短距离 for (int i = 0; i &lt; n; i++) &#123; s.insert(i); &#125; // 初始化 dp[0] = 0; parents[0] = 0; while (!s.empty()) &#123; int index, ans = INT_MAX; // 查找当前距离起点最近的未访问点 for (auto i : s) &#123; if (ans &gt; dp[i]) &#123; ans = dp[i]; index = i; &#125; &#125; // 访问该节点 s.erase(index); // 根据已经访问的节点更新距离 relaxation for (auto j : adj[index]) &#123; if (matrix[index][j] + dp[index] &lt; dp[j]) &#123; // 这里不需要判断是不是已经访问过了，因为根据贪心保存过得一定是最小的 dp[j] = matrix[index][j] + dp[index]; parents[j] = index; &#125; &#125; &#125; return dp;&#125;void find_path(vector&lt;int&gt;&amp; parents, int x) &#123; if (x != parents[x]) find_path(parents, parents[x]); cout &lt;&lt; x &lt;&lt; " ";&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, INT_MAX)); vector&lt;unordered_set&lt;int&gt;&gt; edges(n, unordered_set&lt;int&gt;()); for (int i = 0; i &lt; k; i++) &#123; int x, y, d; cin &gt;&gt; x &gt;&gt; y &gt;&gt; d; matrix[x][y] = d; matrix[y][x] = d; edges[x].insert(y); edges[y].insert(x); &#125; vector&lt;int&gt; parents(n, 0); vector&lt;int&gt; dp = helper(matrix, parents, edges); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; dp[i] &lt;&lt; endl; find_path(parents, i); cout &lt;&lt; endl; &#125; return 0;&#125;/*5 70 1 1000 2 300 4 102 1 602 3 603 1 104 3 50*/ Dijkstra看图论书容易陷入误区，会以为每次保存最新纳入的节点作为下次搜索的起始节点，然后进行下次搜索最小值并更新。然而这搞错了步骤，首先，更新过距离的未访问点已经是该点当前距离起点最近的距离了，从其中选择最短路然后访问，再通过当前最短路更新其余点的最短路，这样稳定的进行贪心算法。 当前代码的时间复杂度是O(V2)，但是如果使用V个元素的斐波那契堆，用decrease key函数来进行relaxtion，使用extract min来找下一个点，就可以将时间简化到O(E+VlgV)，所以理论上Dijkstra算法为O(E+VlgV)，此处的代码之后更新。 关于单源最短路径还可以有更多优化，由于面试中可能涉及的较少这里不做总结，感兴趣的同学可以参考最短路径的优化。 Dijkstra算法扩展给定起始点，寻找其间第K小的路径。 参考文献为csdn 代码模板参考链接 SPFA算法 这部分内容参考资料台湾师范大学的推算法笔记，这里只做算法实现的总结。 主题思想是用BFS的思想，不断访问已经访问的点并扩展到邻节点，并更新节点距离，同时要检测负环，防止负环边数大于V-1而循环到负无穷。如果路径中有负环，那么负环无限循环路径权值就为负无穷，也就不存在最短路径，算法结束。 SPFA算法模板：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;#include &lt;queue&gt;#include &lt;climits&gt;using namespace std;void find_negative_cycle(int index, vector&lt;int&gt;&amp; parents, int n) &#123; cout &lt;&lt; "负环:" &lt;&lt; endl; int x = parents[index]; while (index != parents[x]) &#123; cout &lt;&lt; x &lt;&lt; endl; x = parents[x]; &#125;&#125;vector&lt;int&gt; helper(vector&lt;vector&lt;int&gt;&gt;&amp; matrix, vector&lt;int&gt;&amp; parents, vector&lt;unordered_set&lt;int&gt;&gt;&amp; adj) &#123; int n = parents.size(); vector&lt;bool&gt; inqueue(n, false); // 已经在队列中 vector&lt;int&gt; dp(n, INT_MAX); // 保存当前每个点最短距离 vector&lt;int&gt; cnt(n, 0); // 记录最短路径的边数 // 初始化 dp[0] = 0; parents[0] = 0; cnt[0] = 0; queue&lt;int&gt; q; q.push(0); while (!q.empty()) &#123; int index = q.front(); q.pop(); inqueue[index] = false; if (inqueue[parents[index]]) // 加速：queue中已经有了parents[index]，舍弃index继续，说明index已经稳定 continue; // 根据已经访问的节点更新距离 for (auto j : adj[index]) &#123; if (matrix[index][j] + dp[index] &lt; dp[j]) &#123; dp[j] = matrix[index][j] + dp[index]; parents[j] = index; cnt[j] = cnt[index] + 1; // 边数增加 if (cnt[j] &gt;= n) &#123; // 有负环 find_negative_cycle(j, parents, n); return dp; &#125; if (!inqueue[j]) &#123; // 如果队列中没有就加入 inqueue[j] = true; q.push(j); &#125; &#125; &#125; &#125; return dp;&#125;void find_path(vector&lt;int&gt;&amp; parents, int x) &#123; if (x != parents[x]) find_path(parents, parents[x]); cout &lt;&lt; x &lt;&lt; " ";&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, INT_MAX)); vector&lt;unordered_set&lt;int&gt;&gt; edges(n, unordered_set&lt;int&gt;()); for (int i = 0; i &lt; k; i++) &#123; int x, y, d; cin &gt;&gt; x &gt;&gt; y &gt;&gt; d; matrix[x][y] = d; matrix[y][x] = d; edges[x].insert(y); edges[y].insert(x); &#125; vector&lt;int&gt; parents(n, 0); vector&lt;int&gt; dp = helper(matrix, parents, edges); for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; i &lt;&lt; ":" &lt;&lt; dp[i] &lt;&lt; endl; find_path(parents, i); cout &lt;&lt; endl; &#125; return 0;&#125; 图的直径树形图的直径 这个算法也是较为经典的算法，使用BFS从所有悬挂点出发，并把悬挂点剥离，最后根据BFS迭代的次数判断无向图的最长路，也就是图的直径。注意此算法的前提是保证无向图为连通图，如果不是连通图首先要判断一下连通性。 验证地址leetcode 310 从方法无法处理有环图，因为有环存在只有一个叶子节点的情况。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_set&gt;#include &lt;utility&gt;using namespace std;int helper(int n, vector&lt;pair&lt;int, int&gt;&gt;&amp; grap) &#123; if (n == 1) return 0; vector&lt;unordered_set&lt;int&gt;&gt; count(n, unordered_set&lt;int&gt;()); for (auto i : grap) &#123; if (i.first == i.second) continue; // 去掉环 count[i.first].insert(i.second); count[i.second].insert(i.first); &#125; int ret = 0; vector&lt;int&gt; current; for (int i = 0; i &lt; n; i++) &#123; int len = count[i].size(); if (len == 1) current.push_back(i); &#125; while (true) &#123; vector&lt;int&gt; next; ret ++; for (auto i : current) &#123; // 默认所有current中的点都是悬挂点 // 所以遍历叶子节点的相邻点并去掉与之相连的边，这些边就不能被访问到。 for (auto j : count[i]) &#123; count[j].erase(i); if (count[j].size() == 1) next.push_back(j); &#125; &#125; if (next.empty()) break; current = next; &#125; // 终止集合是单点是迭代次数的二倍，集合为两个点还要多算连接这两个点的边 // 因为终止条件是next为空，所以会将终止集合也多算一次迭代，所以需要减去。 return current.size() == 1 ? ret * 2 - 2: ret * 2 - 1;&#125;int main() &#123; int n, k; cin &gt;&gt; k &gt;&gt; n; vector&lt;pair&lt;int, int&gt;&gt; grap; for (int i = 0; i &lt; k; i ++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; grap.push_back(make_pair(x, y)); &#125; cout &lt;&lt; helper(n, grap) &lt;&lt; endl; return 0;&#125;/*5 40 11 22 30 23 3*/ 无向图的直径如果是要求非树形连通图，就需要定义几个概念： 偏心距 ：以最短路径长度作为距离，一张无向图中距离一点最远的距离被称为该点的偏心距。 直径与半径 : 一张无向图的直径是所有偏心距中最大的一个，半径是途中所有偏心距离中最小的一个。直径也可以直接认为是图上最长的一条最短路径的长度。 直径与半径代码模板（Floyd-Warshall算法）:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;climits&gt;#include &lt;cmath&gt;using namespace std;void helper(int n, vector&lt;vector&lt;int&gt;&gt;&amp; matrix, int&amp; d, int&amp; r) &#123; // Floyd-Warshall Algorithm for (int k = 0; k &lt; n; k++) &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; // 注意溢出 matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]); &#125; &#125; &#125; // 计算偏心距 vector&lt;int&gt; ecc(n, 0); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (matrix[i][j] != 1E9) &#123; ecc[i] = max(ecc[i], matrix[i][j]); &#125; &#125; &#125; // 半径与直径 d = 0, r = 1E9; for (int i = 0; i &lt; n; i++) &#123; d = max(d, ecc[i]); r = min(r, ecc[i]); &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;vector&lt;int&gt;&gt; matrix(n, vector&lt;int&gt;(n, 1E9)); for (int i = 0; i &lt; k; i++) &#123; int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; matrix[x][y] = v; matrix[y][x] = v; &#125; int d, r; helper(n, matrix, d, r); cout &lt;&lt; "diameter: " &lt;&lt; d &lt;&lt; endl; cout &lt;&lt; "radius: " &lt;&lt; r &lt;&lt; endl; return 0;&#125; 图的连通性 使用并查集，测试样例可以参考cnblog 这里先给出并查集的模板：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int find(int x, vector&lt;int&gt;&amp; set) &#123; int y = x; while (set[x] != x) &#123; x = set[x]; &#125; while (x != y) &#123; int t = set[y]; set[y] = x; y = t; &#125; return x;&#125;void merge(int x, int y, vector&lt;int&gt;&amp; set) &#123; int p1 = find(x, set); int p2 = find(y, set); if (p1 != p2) &#123; set[p1] = p2; &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;int&gt; set(n + 1, 0); for (int i = 1; i &lt;= n; i++) &#123; set[i] = i; &#125; for (int i = 0; i &lt; k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; merge(x, y, set); &#125; int ret = 0; for (int i = 1; i &lt;= n; i++) &#123; if (set[i] == i) ret ++; &#125; cout &lt;&lt; ret &lt;&lt; endl; return 0;&#125; 使用图结构后计算并查集并计算连通分量：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;#include &lt;unordered_set&gt;using namespace std;int find(int x, vector&lt;int&gt;&amp; set) &#123; int y = x; while (x != set[x]) &#123; x = set[x]; &#125; while (y != x) &#123; int t = set[y]; set[y] = x; y = t; &#125; return x;&#125;void merge(int x, int y, vector&lt;int&gt;&amp; set) &#123; int p1 = find(x, set); int p2 = find(y, set); if (p1 != p2) &#123; set[p1] = p2; &#125;&#125;void helper(vector&lt;unordered_set&lt;int&gt;&gt;&amp; edges) &#123; int n = edges.size(); vector&lt;int&gt; set(n, 0); for (int i = 0; i &lt; n; i++) &#123; set[i] = i; &#125; for (int i = 0; i &lt; n; i++) &#123; for (auto j : edges[i]) &#123; merge(i, j, set); &#125; &#125; vector&lt;unordered_set&lt;int&gt;&gt; ret(n, unordered_set&lt;int&gt;()); for (int i = 0; i &lt; n; i++) &#123; ret[set[i]].insert(i); &#125; for (auto i : ret) &#123; if (i.empty()) continue; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;unordered_set&lt;int&gt;&gt; edges(n, unordered_set&lt;int&gt;()); for (int i = 0; i &lt; k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt; y; edges[x].insert(y); edges[y].insert(x); &#125; helper(edges); return 0;&#125;/*4 50 10 21 21 13 3*/ 拓扑排序拓扑排序的要点是要注意加入队列的条件，需要入度为0的时候才可以加入。可以使用leetcode的Reconstruct Itinerary进行验证。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;unordered_set&gt;#include &lt;unordered_set&gt;using namespace std;void helper(int n, vector&lt;pair&lt;int, int&gt;&gt;&amp; edges) &#123; vector&lt;int&gt; degree(n, 0); vector&lt;unordered_set&lt;int&gt;&gt; count(n, unordered_set&lt;int&gt;()); for (auto i : edges) &#123; degree[i.second]++; count[i.first].insert(i.second); &#125; vector&lt;int&gt; cur; for (int i = 0; i &lt; n; i++) &#123; if (degree[i] == 0) &#123; cur.push_back(i); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; ret; while (!cur.empty()) &#123; vector&lt;int&gt; ans; for (auto i : cur) &#123; for (auto j : count[i]) &#123; degree[j] --; if (degree[j] == 0) ans.push_back(j); &#125; &#125; ret.push_back(cur); cur = ans; &#125; for (auto i : ret) &#123; for (auto j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; vector&lt;pair&lt;int, int&gt;&gt; edges; for (int i = 0; i &lt; k; i++) &#123; int x, y; cin &gt;&gt; x &gt;&gt;y; edges.push_back(make_pair(x, y)); &#125; helper(n, edges); return 0;&#125; 网络流相关算法最大流 本文的参考文献是最大流（网络流基础概念+三个算法），可以用POJ1273验证。 EK（Edmond—Karp）算法第一种算法EK（Edmond—Karp）算法，主要的要去是每做一次更新都会建立一条反向的边，从而建立返回的渠道减少替代回溯的高消耗。模板如下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;int BFS(vector&lt;int&gt;&amp; pre, int start, int end, vector&lt;vector&lt;int&gt;&gt;&amp; cap) &#123; queue&lt;int&gt; q; int n = cap.size(); for (int i = 0; i &lt; n; i++) &#123; pre[i] = -1; &#125; vector&lt;int&gt; flow(n, 0); // 保存流 // 初始化 pre[start] = start; flow[start] = 0x7FFFFFFF; q.push(start); while (!q.empty()) &#123; // 用bfs搜索整个路 int index = q.front(); q.pop(); if (index == end) break; // 到达终点为可增路 for (int i = 0; i &lt; n; i++) &#123; if (i != start &amp;&amp; cap[index][i] &gt; 0 &amp;&amp; pre[i] == -1) &#123; // 更新流 pre[i] = index; flow[i] = min(flow[index], cap[index][i]); q.push(i); &#125; &#125; &#125; // 可增路无法到达终点 if (pre[end] == -1) return -1; else return flow[end];&#125;int helper(int n, vector&lt;vector&lt;int&gt;&gt;&amp; cap, vector&lt;int&gt;&amp; pre, int start, int end) &#123; int ret = 0; int increase = 0; // 单次可增路的增大流容量 while ((increase = BFS(pre, start, end, cap)) != -1) &#123; // 返回-1代表没有可增路 int temp = end; while (temp != start) &#123; // 更新可增路上的容量 int last = pre[temp]; cap[last][temp] -= increase; // 反向也要增加 cap[temp][last] += increase; temp = last; &#125; ret += increase; &#125; return ret;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; cap(n, vector&lt;int&gt;(n, 0)); vector&lt;int&gt; pre(n, -1); // 用来标记可增路的路径 for (int i = 0; i &lt; m; i++) &#123; int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; if (x == y) continue; cap[x][y] = v; &#125; cout &lt;&lt; helper(n, cap, pre, 0, n - 1) &lt;&lt; endl;; return 0;&#125;/*4 50 1 401 2 301 3 200 3 202 3 10*/ Ford-Fulkerson算法Ford-Fulkerson算法可认为是DFS版本的EK，由于是递归，会带来空间消耗。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;using namespace std;int dfs(int start, int end, vector&lt;vector&lt;int&gt;&gt;&amp; cap, vector&lt;bool&gt;&amp; visited, int flow) &#123; int n = visited.size(); if (start == end) &#123; return flow; &#125; for (int i = 0; i &lt; n; i++) &#123; if (cap[start][i] &gt; 0 &amp;&amp; !visited[i]) &#123; visited[i] = true; int f = dfs(i, end, cap, visited, min(flow, cap[start][i])); if (f &gt; 0) &#123; cap[start][i] -= f; cap[i][start] += f; return f; &#125; &#125; &#125; // 没有可增路返回0 return 0;&#125;int helper(int n, vector&lt;vector&lt;int&gt;&gt;&amp; cap, int start, int end) &#123; int ret = 0; while (true) &#123; vector&lt;bool&gt; visited(n, false); int flow = dfs(start, end, cap, visited, 0x7FFFFFFF); if (flow == 0) break; ret += flow; &#125; return ret;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; cap(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; cap[x][y] = v; &#125; cout &lt;&lt; helper(n, cap, 0, n - 1) &lt;&lt; endl; return 0;&#125;/*4 50 1 401 2 301 3 200 3 202 3 10*/ Dinic算法Dinic算法是网络流最大流的优化算法之一，每一步对原图进行分层，然后用DFS求增广路。时间复杂度是O(n^2*m)，Dinic算法最多被分为n个阶段，每个阶段包括建层次网络和寻找增广路两部分。 Dinic算法的思想是分阶段地在层次网络中增广。它与最短增广路算法不同之处是：最短增广路每个阶段执行完一次BFS增广后，要重新启动BFS从源点Vs开始寻找另一条增广路;而在Dinic算法中，只需一次BFS过程就可以实现多次增广。 观察前面的dfs算法，对于层次相同的边，会经过多次重复运算，很浪费时间，那么，可以考虑先对原图分好层产生新的层次图，即保存了每个点的层次，注意，很多人会把这里的边的最大容量跟以前算最短路时的那个权值混淆，其实这里每个点之间的距离都可以看作单位距离，然后对新图进行dfs，这时的dfs就非常有层次感，有筛选感了，同层次的点不可能在同一跳路径中，直接排除。那么运行速度就会快很多了。 Dinic算法模板：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;cstdlib&gt;using namespace std;int bfs(int start, int end, vector&lt;vector&lt;int&gt;&gt;&amp; cap, vector&lt;int&gt;&amp; dep) &#123; queue&lt;int&gt; q; q.push(start); int n = dep.size(); for (int i = 0; i &lt; n; i++) &#123; dep[i] = -1; &#125; dep[start] = 0; while (!q.empty()) &#123; int index = q.front(); q.pop(); for (int i = 0; i &lt; n; i++) &#123; if (cap[index][i] &gt; 0 &amp;&amp; dep[i] == -1) &#123; dep[i] = dep[index] + 1; q.push(i); &#125; &#125; &#125; return dep[end] != -1;&#125;int dfs(int start, int end, vector&lt;vector&lt;int&gt;&gt;&amp; cap, vector&lt;int&gt;&amp; dep, int flow) &#123; if (start == end) return flow; int n = dep.size(); for (int i = 0; i &lt; n; i++) &#123; if (cap[start][i] &gt; 0 &amp;&amp; dep[i] == dep[start] + 1) &#123; int temp = dfs(i, end, cap, dep, min(flow, cap[start][i])); if (temp != 0) &#123; cap[start][i] -= temp; cap[i][start] += temp; return temp; &#125; &#125; &#125; return 0;&#125;int helper(int n, int start, int end, vector&lt;vector&lt;int&gt;&gt;&amp; cap) &#123; int ret = 0; vector&lt;int&gt; dep(n, -1); while (bfs(start, end, cap, dep)) &#123; while (true) &#123; int temp = dfs(start, end, cap, dep, 0x7FFFFFFF); if (!temp) break; ret += temp; &#125; &#125; return ret;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;vector&lt;int&gt;&gt; cap(n, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt; m; i++) &#123; int x, y, v; cin &gt;&gt; x &gt;&gt; y &gt;&gt; v; cap[x][y] = v; &#125; cout &lt;&lt; helper(n, 0, n - 1, cap) &lt;&lt; endl; return 0;&#125;/*4 50 1 401 2 301 3 200 3 202 3 10*/ 最大流问题还有很多种变种，因为本身面试中涉及基础图论比较少，不做涉及，更多了解可以参考资料 最小割SW（Stoer-Wagner）算法最小割算法有很多算法，这里只提供一种模板，就是比较常用的Stoer-Wagner Algorithm，其中的推导和更多算法可以访问资料 这个算法的验证地址是POJ2914模板如下（代码参考自cnblog）：123456789101112131415161718192021222324252627282930313233343536373839404142434445const int maxn = 550;const int inf = 1000000000;int n, r;int edge[maxn][maxn], dist[maxn];bool vis[maxn], bin[maxn];void init()&#123; memset(edge, 0, sizeof(edge)); memset(bin, false, sizeof(bin));&#125;int contract( int &amp;s, int &amp;t ) // 寻找 s,t&#123; memset(dist, 0, sizeof(dist)); memset(vis, false, sizeof(vis)); int i, j, k, mincut, maxc; for(i = 1; i &lt;= n; i++) &#123; k = -1; maxc = -1; for(j = 1; j &lt;= n; j++)if(!bin[j] &amp;&amp; !vis[j] &amp;&amp; dist[j] &gt; maxc) &#123; k = j; maxc = dist[j]; &#125; if(k == -1)return mincut; s = t; t = k; mincut = maxc; vis[k] = true; for(j = 1; j &lt;= n; j++)if(!bin[j] &amp;&amp; !vis[j]) dist[j] += edge[k][j]; &#125; return mincut;&#125;int Stoer_Wagner()&#123; int mincut, i, j, s, t, ans; for(mincut = inf, i = 1; i &lt; n; i++) &#123; ans = contract( s, t ); bin[t] = true; if(mincut &gt; ans)mincut = ans; if(mincut == 0)return 0; for(j = 1; j &lt;= n; j++)if(!bin[j]) edge[s][j] = (edge[j][s] += edge[j][t]); &#125; return mincut;&#125; BFS/DFS待更新…]]></content>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer部分题目思路总结]]></title>
    <url>%2F2018%2F06%2F13%2Ftargeting-offer-in-nowcoder%2F</url>
    <content type="text"><![CDATA[这部分主要是在牛客网上进行的验证，部分简单的题目没有进行总结，如果有别的思路，欢迎联系我进行交流。 变态跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 可以发现：则f(1)=1,f(2)=2,f(3)=4,f(4)=8,我们隐约感觉到f(n)=2^(n-1)，但是需要证明下，同样根据我们根据上篇文章中跳台阶的思路，可以得到f(n)=f(n-1)+f(n-2)+….+f(1)+1,而f(n-1)=f(n-2)+….+f(1)+1,两个式子相减，得到f(n) = 2f(n-1),很明显可以得到f(n)=2^(n-1)。 123456class Solution &#123;public: int jumpFloorII(int number) &#123; return 1 &lt;&lt; (number - 1); &#125;&#125;; 矩形覆盖 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 123456789101112class Solution &#123;public: int rectCover(int number) &#123; if (number &lt;= 2) return number; int pre = 1, cur = 2; for (int i = 3; i &lt;= number; i++) &#123; cur += pre; pre = cur - pre; &#125; return cur; &#125;&#125;; 二进制中1的个数 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 1234567891011class Solution &#123;public: int NumberOf1(int n) &#123; n = ((n &amp; 0xAAAAAAAA) &gt;&gt; 1) + (n &amp; 0x55555555); n = ((n &amp; 0xCCCCCCCC) &gt;&gt; 2) + (n &amp; 0x33333333); n = ((n &amp; 0xF0F0F0F0) &gt;&gt; 4) + (n &amp; 0x0F0F0F0F); n = ((n &amp; 0xFF00FF00) &gt;&gt; 8) + (n &amp; 0x00FF00FF); n = ((n &amp; 0xFFFF0000) &gt;&gt; 16) + (n &amp; 0x0000FFFF); return n; &#125;&#125;; 浮点数快速幂 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 1234567891011121314class Solution &#123;public: double Power(double base, int exponent) &#123; int syn = exponent &gt; 0 ? 1 : -1; double ret = 1.0; long long N = abs((long long) exponent); // 注意可能取负溢出 while (N) &#123; if (N &amp; 1) ret *= base; base *= base; N &gt;&gt;= 1; &#125; return syn == 1 ? ret : 1/ ret; &#125;&#125;; 调整数组顺序使奇数位于偶数前面（冒泡排序相关） 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 123456789101112131415161718192021222324252627282930class Solution &#123;public: // 排序算法的另外一种运用，因为要使用稳定的排序，所以可以利用冒泡排序 // 冒泡排序的两种写法：https://blog.csdn.net/shuaizai88/article/details/73250615 // 第一种： /* // 向下沉 void reOrderArray(vector&lt;int&gt; &amp;nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = 0;j &lt; n - 1 - i; j++) &#123; if (nums[j] % 2 == 0 &amp;&amp; nums[j + 1] % 2) swap(nums[j], nums[j + 1]); &#125; &#125; &#125; */ // 第二种：向上飘 void reOrderArray(vector&lt;int&gt; &amp;nums) &#123; int n = nums.size(); for (int i = 0; i &lt; n; i ++) &#123; for (int j = n - 1;j &gt; i; j --) &#123; if (nums[j] % 2 &amp;&amp; nums[j - 1] % 2 == 0) swap(nums[j], nums[j - 1]); &#125; &#125; &#125;&#125;; 如果要是不要求保证原始顺序不变，就用双指针1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void helper(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int left = 0, right = n - 1; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; nums[left] % 2) left++; while (left &lt; right &amp;&amp; nums[right] % 2 == 0) right --; if (left &lt; right) &#123; swap(nums[left], nums[right]); left ++, right --; &#125; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; vector&lt;int&gt; nums(n, 0); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; nums[i]; &#125; helper(nums); for (auto i : nums) &#123; cout &lt;&lt; i &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; 翻转单链表 输入一个链表，反转链表后，输出链表的所有元素。 123456789101112131415161718192021222324252627282930313233/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: // 递归方法 空间O(n) ListNode* ReverseList(ListNode* pHead) &#123; if (!pHead || !pHead-&gt;next) return pHead; ListNode* ret = ReverseList(pHead-&gt;next); pHead-&gt;next-&gt;next = pHead; pHead-&gt;next = NULL; return ret; &#125; // 迭代 空间O(1) ListNode* ReverseList(ListNode* pHead) &#123; if (!pHead || !pHead-&gt;next) return pHead; ListNode* cur = pHead; ListNode* ret = NULL; while (cur) &#123; ListNode* temp = cur-&gt;next; cur-&gt;next = ret; ret = cur; cur = temp; &#125; pHead-&gt;next = NULL; return ret; &#125;&#125;; 树的子结构 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 12345678910111213141516171819202122232425/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool helper(TreeNode* A, TreeNode* B) &#123; if (B == NULL) return true; if (A == NULL) return false; if (A-&gt;val == B-&gt;val) &#123; return helper(A-&gt;left, B-&gt;left) &amp;&amp; helper(A-&gt;right, B-&gt;right); &#125; else return false; &#125; bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; if (pRoot1 == NULL || pRoot2 == NULL) return false; return helper(pRoot1, pRoot2) || HasSubtree(pRoot1-&gt;left, pRoot2) || HasSubtree(pRoot1-&gt;right, pRoot2); &#125;&#125;; 二叉树中和为某个值的路径 输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 12345678910111213141516171819202122232425262728/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void helper(vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt; ans, int sum, TreeNode* root, int target) &#123; if (!root) return; sum += root-&gt;val; ans.push_back(root-&gt;val); if (!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; sum == target) &#123; ret.push_back(ans); &#125; helper(ret, ans, sum, root-&gt;left, target); helper(ret, ans, sum, root-&gt;right, target); &#125; vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123; vector&lt;vector&lt;int&gt;&gt; ret; vector&lt;int&gt; ans; helper(ret, ans, 0, root, expectNumber); return ret; &#125;&#125;; 复杂链表的复制 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead)&#123; if (!pHead) return NULL; RandomListNode* cur = pHead; while (cur) &#123; RandomListNode* temp = new RandomListNode(cur-&gt;label); temp-&gt;next = cur-&gt;next; cur-&gt;next = temp; cur = temp-&gt;next; &#125; cur = pHead; while (cur) &#123; RandomListNode* temp = cur-&gt;next; if (cur-&gt;random) &#123; temp-&gt;random = cur-&gt;random-&gt;next; &#125; cur = temp-&gt;next; &#125; RandomListNode* ret = pHead-&gt;next; cur = pHead; RandomListNode* c1 = NULL, *c2 = NULL; while (cur) &#123; if (!c1) &#123; c1 = cur; c2 = cur-&gt;next; &#125; else &#123; c1-&gt;next = cur; c2-&gt;next = cur-&gt;next; c1 = c1-&gt;next; c2 = c2-&gt;next; &#125; cur = cur-&gt;next-&gt;next; c1-&gt;next = NULL; c2-&gt;next = NULL; &#125; return ret; &#125;&#125;; 二叉树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 12345678910111213141516171819202122232425262728293031323334353637/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void helper(TreeNode* root, TreeNode* &amp;left, TreeNode* &amp;right) &#123; left = right = NULL; TreeNode* l, *r; if (root-&gt;left) &#123; helper(root-&gt;left, l, r); left = l, r-&gt;right = root, root-&gt;left = r; &#125; else &#123; left = root; &#125; if (root-&gt;right) &#123; helper(root-&gt;right, l, r); right = r, root-&gt;right = l, l-&gt;left = root; &#125; else &#123; right = root; &#125; &#125; TreeNode* Convert(TreeNode* pRootOfTree) &#123; if (!pRootOfTree) return NULL; TreeNode* left, *right; helper(pRootOfTree, left, right); return left; &#125;&#125;; 字符串的排列 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 12345678910111213141516171819202122class Solution &#123;public: void helper(string ans, int index, vector&lt;string&gt;&amp; ret) &#123; int len = ans.size(); if (index == len - 1) ret.push_back(ans); // 因为是有顺序的，所以等于是依次把后面的数提到前面来 // 比如：1234,2134,3124,4123 // 所以保证了后面的有序性，从而保证了唯一性，充分利用了递归的思想，每一层只做每一层的事情，不回溯 for (int i = index; i &lt; len; i++) &#123; if (i != index &amp;&amp; ans[index] == ans[i]) continue; swap(ans[i], ans[index]); helper(ans, index + 1, ret); &#125; &#125; vector&lt;string&gt; Permutation(string str) &#123; vector&lt;string&gt; ret; if (str.empty()) return ret; sort(str.begin(), str.end()); helper(str, 0, ret); return ret; &#125;&#125;; 数字中出现次数超过一半 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 123456789101112131415161718192021class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if (numbers.empty()) return 0; int ans = numbers[0]; int count = 0; for (auto i : numbers) &#123; if (ans == i) count ++; else count --; if (count &lt; 0) &#123; count = 0; ans = i; &#125; &#125; count = 0; for (auto i : numbers) &#123; if (ans == i) count ++; &#125; return count &gt; numbers.size() / 2 ? ans : 0; &#125;&#125;; 最小的k个数 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 12345678910111213141516171819202122232425262728293031// 堆排序思路class Solution &#123;public: void heapfy(vector&lt;int&gt;&amp; nums, int index, int max) &#123; int left = index * 2 + 1; int right = left + 1; int small = index; if (left &lt; max &amp;&amp; nums[left] &lt; nums[small]) small = left; if (right &lt; max &amp;&amp; nums[right] &lt; nums[small]) small = right; if (small != index) &#123; swap(nums[index], nums[small]); heapfy(nums, small, max); &#125; &#125; void helper(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; ret, int k) &#123; int len = nums.size(); for (int i = len / 2; i &gt;= 0; i--) heapfy(nums, i, len); for (int i = len - 1; i &gt;= 0 &amp;&amp; ret.size() &lt; k; i--) &#123; ret.push_back(nums[0]); swap(nums[0], nums[i]); heapfy(nums, 0, i); &#125; &#125; vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; int len = input.size(); vector&lt;int&gt; ret; if (k &gt; len) return ret; helper(input, ret, k); return ret; &#125;&#125;; 连续子数组的最大和 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。你会不会被他忽悠住？(子向量的长度至少是1) 思路：dp[i] = dp[i - 1] + a[i] (&gt;=0), 0 (&lt;0) 12345678910111213class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if (array.empty()) return 0; int ret = array[0], ans = array[0]; for (int i = 1; i &lt; array.size(); i++) &#123; ans += array[i]; ret = max(ret, ans); if (ans &lt; 0) ans = 0; &#125; return ret; &#125;&#125;; 整数中1出现的次数(*) 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数。 1234567891011121314151617181920class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; int count = 0; int len = floor(log10(n)) + 1; char str[100]; sprintf(str, "%d", n); for (int i = 0; i &lt; len; i++) &#123; int temp = str[len - 1 - i] - '0'; // 每次加的是该位为1的一共有多少个数 if (temp == 0) count += n / (int)pow(10, i + 1) * pow(10, i); // 比如123'0'1, 就有123*10个十位为1的数, 从00010到12210一共有123*10个数 else if (temp == 1) count += n / (int)pow(10, i + 1) * pow(10, i) + n % (int)pow(10, i) + 1; // 比如123'1'1, 从0到12210就有123*10个数，大于12310就有12311 % 10 = 1个数，再加上12311这一个 else count += (n / (int)pow(10, i + 1) + 1) * pow(10, i); // 比如123'4'1, 就有124*10个十位为1的数，例如0-12341共124*10十位为1的数 &#125; return count; &#125;&#125;; 把数组排成最小的数 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 123456789101112131415class Solution &#123;public: bool static cmp(const int&amp; a, const int&amp; b) &#123; return to_string(a) + to_string(b) &lt; to_string(b) + to_string(a); &#125; string PrintMinNumber(vector&lt;int&gt; numbers) &#123; string ret; if (numbers.empty()) return ret; sort(numbers.begin(), numbers.end(), cmp); for (auto i : numbers) &#123; ret += to_string(i); &#125; return ret; &#125;&#125;; 丑数 把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 1234567891011121314151617class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if (index &lt;= 0) return false; if (index == 1) return true; vector&lt;int&gt; dp(index, 1); int t2 = 0, t3 = 0, t5 = 0; for (int i = 1; i &lt; index; i++) &#123; dp[i] = min(dp[t2] * 2, min(dp[t3] * 3, dp[t5] * 5)); // 这里就是标明没有放入数组的最小的乘以(2,3,5)数的角标 if (dp[i] == dp[t2] * 2) t2 ++; if (dp[i] == dp[t3] * 3) t3 ++; if (dp[i] == dp[t5] * 5) t5 ++; &#125; return dp[index - 1]; &#125;&#125;; 数组中的逆序对(*) 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 思路1：字典树和二叉搜索树的思路，记录左右子树分别有多少节点和自己落了多少个数，落到左子树说明右边和根节点都是自己的逆序对，最差情况下是O(n^2)。 123456789101112131415161718192021222324252627282930313233343536373839struct Node &#123; int val; struct Node* left; struct Node* right; int lcount; int rcount; int cnt; Node(int x): val(x), left(NULL), right(NULL), lcount(0), rcount(0), cnt(1) &#123;&#125;&#125;;class Solution &#123;public: long long MOD = 1000000007; long long ret = 0; void helper(Node* root, int val) &#123; if (!root) return; int temp = root-&gt;val; if (temp == val) root-&gt;cnt ++; else if (temp &gt; val) &#123; ret = (((ret % MOD + root-&gt;rcount) % MOD) + root-&gt;cnt) % MOD; root-&gt;lcount ++; if (root-&gt;left) helper(root-&gt;left, val); else root-&gt;left = new Node(val); &#125; else &#123; root-&gt; rcount ++; if (root-&gt;right) helper(root-&gt;right, val); else root-&gt;right = new Node(val); &#125; &#125; int InversePairs(vector&lt;int&gt; data) &#123; if(data.size()&lt;=1) return 0; Node* root = new Node(data[0]); for (int i = 1; i &lt; data.size(); i++) helper(root, data[i]); return ret; &#125;&#125;; 思路2：归并排 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: long long MOD = 1000000007; int InversePairs(vector&lt;int&gt; data) &#123; if(data.size()&lt;=1) return 0; vector&lt;int&gt; copy(data); return InversePairsCore(data,copy,0,data.size()-1); &#125;private: int InversePairsCore(vector&lt;int&gt; &amp;data,vector&lt;int&gt; &amp;copy, int begin, int end) &#123;//合并data的两半段到辅助数组copy中有序 if(begin==end) &#123; copy[end]=data[end]; return 0; &#125; else &#123; int mid=begin+(end-begin)/2; int left=InversePairsCore(copy,data,begin,mid);//使data的左半段有序 int right=InversePairsCore(copy,data,mid+1,end);//使data的右半段有序 int cnt=0; int cpIndex=end; int pre=mid; int post=end; //合并两个有序段，到copy数组 while(pre&gt;=begin &amp;&amp; post&gt;=mid+1) &#123; if(data[pre]&gt;data[post])//每次比较的是两个有序序列 &#123; cnt=(cnt+(post-mid-1+1)) % MOD; copy[cpIndex--]=data[pre]; pre--; &#125; else &#123; copy[cpIndex--]=data[post]; post--; &#125; &#125; for(;pre&gt;=begin;--pre) copy[cpIndex--]=data[pre]; for(;post&gt;=mid+1;--post) copy[cpIndex--]=data[post]; return ((left+right)%MOD+cnt) % MOD; &#125; &#125;&#125;; 数字在排序数组中的次数 统计一个数字在排序数组中出现的次数。 leetcode中的search for a range牛客网的判定稍微有问题, 最后的返回值改成left - low + 1可以过，但是实际是有错误的。 12345678910111213141516171819202122232425262728class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; int len = data.size(); if (len == 0) return 0; int left = 0, right = len - 1; while (left &lt; right) &#123; int mid = left + ((right - left) &gt;&gt; 1); // 手推，左端不相等向右移 if (data[mid] &lt; k) left = mid + 1; // 小于等于更新右边界 else right = mid; // 因为有left = mid + 1，所以不会出现left = right - 1的时候left不更新的情况。 &#125; if (data[left] != k) return 0; right = len - 1; int low = left, ret; while (left &lt; right) &#123; // 手推，大于的时候右边界向左移 // 等于的时候保存当前值，然后将左值向右移 int mid = left + ((right - left) &gt;&gt; 1); if (data[mid] &gt; k) right = mid - 1, ret = mid; else left = mid + 1; &#125; return ret - low + 1; &#125;&#125;; singel number iii 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 12345678910111213141516class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int ans = 0; for (auto i : data) &#123; ans ^= i; &#125; // 此处位操作比较关键 int c = ans ^ (ans &amp; (ans - 1)); *num1 = 0, * num2 = 0; for (auto i : data) &#123; if (i &amp; c) *num1 ^= i; else *num2 ^= i; &#125; &#125;&#125;; 和为s的连续正数序列 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 这道题的思路可以参考leetcode 523，也可以参考 12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt;&gt; ret; // 双指针法 if (sum &lt; 3) return ret; int ans = 3; int left = 1, right = 2; while (left &lt; ((sum + 1) &gt;&gt; 1) &amp;&amp; right &lt; sum) &#123; while (ans &gt; sum) &#123; ans -= left; left ++; &#125; if (ans == sum) &#123; vector&lt;int&gt; temp; for (int i = left; i &lt;= right; i++) temp.push_back(i); ret.push_back(temp); &#125; right ++; ans += right; &#125; return ret; &#125;&#125;; 我的思路比较数理一点，用sum表示要求的和，比如sum为15的时候，7，8满足条件，7，8之所以满足，是因为 15/2 = 7.5，所以正好左右各取一个数：7和8，就使得和为15。 4,5,6 之所以满足条件，是因为15/3 = 5，正好5可以放在中间，左右再拿一个4和6，所以满足。 因此，对于sum，如果我们想确定它有没有长度为n的连续序列使得这个序列的和等于sum，我们只要算算sum%n，若n是奇数，sum%n == 0，那么就意味着存在这样的序列。而且这个序列的中间那个数就是 sum/n；若n是偶数，sum%n == n/2，也就是说sum除以n的结果是一个以 .5 结尾的数，余数是除数的一半, 那么就意味着这样的序列存在，向两边各延伸n/2就是答案。 这种思路的代码会更简单，但是适用范围很窄，如果把可选的数字换成只能从一个递增数组中选择，就只能用窗口思想了。 12345678910111213141516171819202122class Solution &#123;public: void helper(int left, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; vector&lt;int&gt; temp; for (int i = 0; i &lt; n; i++) &#123; temp.push_back(i + left); &#125; ret.push_back(temp); &#125; vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (sum &lt; 3) return ret; for(int i = 2;i * i &lt;= sum * 2; i++)&#123; if (((i &amp; 1) &amp;&amp; sum % i == 0) || (sum % i) * 2 == i) &#123; int start = (sum / i) - (i - 1) / 2; helper(start, i, ret); &#125; &#125; reverse(ret.begin(), ret.end()); return ret; &#125;&#125;; 左旋转字符串 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 123456789101112class Solution &#123;public: string LeftRotateString(string str, int n) &#123; int len = str.size(); if (!len) return ""; n = (n + len) % len; reverse(str.begin(), str.begin() + n); reverse(str.begin() + n, str.end()); reverse(str.begin(), str.end()); return str; &#125;&#125;; 翻转单词顺序 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 12345678910111213141516171819202122class Solution &#123;public: string ReverseSentence(string str) &#123; if (str.empty()) return str; reverse(str.begin(), str.end()); int index = 0, len = str.size(); for (int i = 0; i &lt; len; i++) &#123; if (str[i] != ' ') &#123; if (index != 0) str[index++] = ' '; // 在单词前面加一个空格 int j = i; while (j &lt; len &amp;&amp; str[j] != ' ') str[index ++] = str[j++]; reverse(str.begin() + index - (j - i), str.begin() + index); i = j; // 加一之后就是空格后一个 &#125; &#125; // str.erase(str.begin() + storeIndex, str.end()); // leetcode还要加上这句 return str; &#125;&#125;; 扑克牌顺子 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何。为了方便起见,你可以认为大小王是0。 123456789101112131415161718class Solution &#123;public: bool IsContinuous( vector&lt;int&gt; numbers ) &#123; if (numbers.empty()) return false; int zeros = 0; int gap = 0; int len = numbers.size(); sort(numbers.begin(), numbers.end()); for (int i = 0; i &lt; len; i++) &#123; if (numbers[i] == 0) zeros ++; if (i != 0 &amp;&amp; numbers[i] != numbers[i - 1] + 1 &amp;&amp; numbers[i - 1] != 0) gap += numbers[i] - numbers[i - 1] - 1; if (i != 0 &amp;&amp; numbers[i] != 0 &amp;&amp; numbers[i] == numbers[i - 1]) return false; &#125; return zeros &gt;= gap; &#125;&#125;; 孩子们的游戏(约瑟夫环)【着重看推导】 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 推导过程约瑟夫环详解 1234567891011class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if (!n) return -1; int ret = 0; for (int i = 2; i &lt;= n; i++) &#123; ret = (ret + m) % i; &#125; return ret; &#125;&#125;; 1+2+3+..+n 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 123456789class Solution &#123;public: int Sum_Solution(int n) &#123; int ans = n; // 与的短路作用，如果n==0就结束 ans &amp;&amp; (ans += Sum_Solution(n - 1)); return ans; &#125;&#125;; 不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 首先看十进制是如何做的： 5+7=12，三步走第一步：相加各位的值，不算进位，得到2。第二步：计算进位值，得到10. 如果这一步的进位值为0，那么第一步得到的值就是最终结果。 第三步：重复上述两步，只是相加的值变成上述两步的得到的结果2和10，得到12。 1234567891011class Solution &#123;public: int Add(int num1, int num2) &#123; while (num2) &#123; int temp = num1 ^ num2; num2 = (num1 &amp; num2) &lt;&lt; 1; num1 = temp; &#125; return num1; &#125;&#125;; 数组中重复的数字 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 12345678910111213141516171819class Solution &#123;public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate(int numbers[], int length, int* duplication) &#123; for (int i = 0; i &lt; length; i++) &#123; if (numbers[abs(numbers[i])] &lt; 0) &#123; *duplication = abs(numbers[i]); return true; &#125; numbers[numbers[i]] *= -1; &#125; return false; &#125;&#125;; 构建乘积数组 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。 1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123; int len = A.size(); if (len == 0) return vector&lt;int&gt;(); vector&lt;int&gt; ret(len, 1); for (int i = 1; i &lt; len; i++) &#123; ret[i] = ret[i - 1] * A[i - 1]; &#125; int temp = 1; for (int i = len - 1; i &gt;= 0; i--) &#123; ret[i] *= temp; temp *= A[i]; &#125; return ret; &#125;&#125;; 删除链表中重复的节点 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 123456789101112131415161718192021222324252627/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if (!pHead) return NULL; int val = pHead-&gt;val; if (pHead-&gt;next) &#123; if (pHead-&gt;next-&gt;val == val) &#123; while (pHead &amp;&amp; pHead-&gt;val == val) pHead = pHead-&gt;next; return deleteDuplication(pHead); &#125; else &#123; pHead-&gt;next = deleteDuplication(pHead-&gt;next); return pHead; &#125; &#125; else return pHead; &#125;&#125;; 正则匹配(重要) 请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool match(char* s, char* p) &#123; int m = 0, n = 0; for (; s[m] != '\0'; m++); for (; p[n] != '\0'; n++); bool dp[m + 1][n + 1]; for (int i = 0; i &lt;= m; i++) &#123; for (int j = 0; j &lt;= n; j++) dp[i][j] = false; &#125; dp[0][0] = true; for (int i = 1; i &lt;= n; i++) // 默认所有p都合法的，所以不会越界，不然要首先检查一下pattern是否满足 if (p[i-1] == '*' &amp;&amp; dp[0][i-2]) dp[0][i] = true; for (int i = 1; i &lt;= m; i++) &#123; for (int j = 1; j &lt;= n; j++) &#123; // 第j个字符为'*' if (p[j-1] == '*') &#123; // 获得第j-1字符 char ch = p[j-2]; if (ch != '.' &amp;&amp; ch != s[i-1]) dp[i][j] = dp[i][j-2]; // 如果出现无法追加的情况（不相等），只能不匹配ch* else dp[i][j] = (dp[i][j - 2] || dp[i - 1][j] || dp[i - 1][j - 2]); // 剩下或者相等或者是.都可以追加成功 // 前两种为相等的情况：不匹配ch*; 继续追加； // 然后只剩下.*的情况了，这种只需要看前面符不符合就可以 &#125; else &#123; if (p[j-1] == '.' || p[j-1] == s[i-1]) dp[i][j] = dp[i-1][j-1]; &#125; &#125; &#125; return dp[m][n]; &#125;&#125;; 表示数值的字符串 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980// 方法一class Solution &#123;public: bool isNumeric(char* string) &#123; int len = 0; while (string[len] != '\0') len ++; if (!len) return false; int m1 = 0, m2 = 0, m3 = 0; for (int i = 0; i &lt; len; i++) &#123; if (m3) &#123; if (string[i] &gt; '9' || string[i] &lt; '0') return false; &#125; else if (m2) &#123; if (string[i] == 'e' || string[i] == 'E') &#123; if (i == len - 1) return false; char temp = string[i + 1]; if (temp != '+' &amp;&amp; temp != '-' &amp;&amp; temp &lt; '0' &amp;&amp; temp &gt; '9') return false; if (temp == '+' || temp == '-') i ++; m3 = 1; &#125; else if (string[i] &gt; '9' || string[i] &lt; '0') &#123; return false; &#125; &#125; else if (m1) &#123; if (string[i] == 'e' || string[i] == 'E') &#123; if (i == len - 1) return false; char temp = string[i + 1]; if (temp != '+' &amp;&amp; temp != '-' &amp;&amp; temp &lt; '0' &amp;&amp; temp &gt; '9') return false; if (temp == '+' || temp == '-') i ++; m3 = 1; &#125; else if ((string[i] &gt; '9' || string[i] &lt; '0') &amp;&amp; string[i] != '.') &#123; return false; &#125; else if (string[i] == '.') m2 = 1; &#125; else &#123; char temp = string[i]; if (temp != '+' &amp;&amp; temp != '-' &amp;&amp; temp &lt; '0' &amp;&amp; temp &gt; '9') return false; m1 = 1; &#125; &#125; return true; &#125;&#125;;// 方法二class Solution &#123;public: bool isNumeric(char* str) &#123; // 标记符号、小数点、e是否出现过 bool sign = false, decimal = false, hasE = false; for (int i = 0; i &lt; strlen(str); i++) &#123; if (str[i] == 'e' || str[i] == 'E') &#123; if (i == strlen(str)-1) return false; // e后面一定要接数字 if (hasE) return false; // 不能同时存在两个e hasE = true; &#125; else if (str[i] == '+' || str[i] == '-') &#123; // 第二次出现+-符号，则必须紧接在e之后 if (sign &amp;&amp; str[i-1] != 'e' &amp;&amp; str[i-1] != 'E') return false; // 第一次出现+-符号，且不是在字符串开头，则也必须紧接在e之后 if (!sign &amp;&amp; i &gt; 0 &amp;&amp; str[i-1] != 'e' &amp;&amp; str[i-1] != 'E') return false; sign = true; &#125; else if (str[i] == '.') &#123; // e后面不能接小数点，小数点不能出现两次 if (hasE || decimal) return false; decimal = true; &#125; else if (str[i] &lt; '0' || str[i] &gt; '9') // 不合法字符 return false; &#125; return true; &#125;&#125;; 字符流中第一个出现的不重复的字符 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 1234567891011121314151617181920212223242526272829class Solution&#123;public: int store[256]; int index = 0; Solution() &#123; memset(store, -1, sizeof(store)); &#125; //Insert one char from stringstream void Insert(char ch) &#123; if (store[ch] == -1) store[ch] = index; else store[ch] = -2; index ++; &#125; //return the first appearence once char in current stringstream char FirstAppearingOnce() &#123; int ret_index = INT_MAX; char ret = '\0'; for (int i = 0; i &lt; 256; i++) &#123; if (store[i] &gt;= 0 &amp;&amp; ret_index &gt; store[i]) &#123; ret_index = store[i]; ret = (char) i; &#125; &#125; if (ret == '\0') return '#'; else return ret; &#125;&#125;; 链表中的入口节点 一个链表中包含环，请找出该链表的环的入口结点。 12345678910111213141516171819202122232425262728293031/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if (!pHead) return NULL; if (!pHead-&gt;next) return NULL; ListNode* p1 = pHead; ListNode* p2 = pHead; while (p2 != NULL &amp;&amp; p2-&gt;next != NULL) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next-&gt;next; if (p1 == p2) &#123; p1 = pHead; while (p1 != p2) &#123; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; return p1; &#125; &#125; return NULL; &#125;&#125;; 二叉树的下一个节点 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 12345678910111213141516171819202122232425262728293031323334353637383940414243/*struct TreeLinkNode &#123; int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeLinkNode* GetNext(TreeLinkNode* pNode) &#123; if (pNode == NULL) return NULL; TreeLinkNode* pre = pNode-&gt;next; if (pre == NULL) &#123; // 根节点 TreeLinkNode* temp = pNode-&gt;right; if (!temp) return temp; while (temp-&gt;left) &#123; temp = temp-&gt;left; &#125; return temp; &#125; if (pre-&gt;left == pNode) &#123; // 自己是左节点 if (pNode-&gt;right == NULL) return pre; return pNode-&gt;right; &#125; else &#123; // 自己是右节点 if (pNode-&gt;right != NULL) return pNode-&gt;right; while (pre-&gt;next != NULL) &#123; TreeLinkNode* temp = pre-&gt;next; if (temp-&gt;left == pre) return temp; pre = temp; &#125; &#125; return NULL; &#125;&#125;; 按之字形顺序打印二叉树 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;// 用栈而不是队列做bfspublic: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if (!pRoot) return ret; stack&lt;TreeNode*&gt; cur; int dir = 1; cur.push(pRoot); while (true) &#123; vector&lt;int&gt; ans; stack&lt;TreeNode*&gt; next; while (!cur.empty()) &#123; ans.push_back(cur.top()-&gt;val); auto temp = cur.top(); cur.pop(); if (dir) &#123; if (temp-&gt;left) next.push(temp-&gt;left); if (temp-&gt;right) next.push(temp-&gt;right); &#125; else &#123; if (temp-&gt;right) next.push(temp-&gt;right); if (temp-&gt;left) next.push(temp-&gt;left); &#125; &#125; ret.push_back(ans); if (next.empty()) break; dir ^= 1; cur = next; &#125; return ret; &#125; &#125;; 序列化二叉树 请实现两个函数，分别用来序列化和反序列化二叉树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void helper(TreeNode* root, vector&lt;int&gt;&amp; buf) &#123; if (!root) &#123; buf.push_back(INT_MAX); return; &#125; buf.push_back(root-&gt;val); helper(root-&gt;left, buf); helper(root-&gt;right, buf); &#125; char* Serialize(TreeNode *root) &#123; vector&lt;int&gt; buf; helper(root, buf); int len = buf.size(); int* temp = new int[len]; for (int i = 0; i &lt; len; i++) &#123; temp[i] = buf[i]; &#125; return (char*) temp; &#125; TreeNode* helper1(int*&amp; s) &#123; if (*s == INT_MAX) &#123; s++; return NULL; &#125; TreeNode* ret = new TreeNode(*s); s ++; ret-&gt;left = helper1(s); ret-&gt;right = helper1(s); return ret; &#125; TreeNode* Deserialize(char *str) &#123; int *p = (int*) str; return helper1(p); &#125;&#125;; 二叉搜索树的第k个节点 给定一颗二叉搜索树，请找出其中的第k大的结点。例如， 5 / 3 7 / / 2 4 6 8 中，按结点数值大小顺序第三个结点的值为4。 1234567891011121314151617181920212223242526/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* helper(TreeNode* root, int&amp; ans) &#123; if (root) &#123; auto temp = helper(root-&gt;left, ans); return !ans ? temp : (ans -- == 1 ? root : helper(root-&gt;right, ans)); &#125; return NULL; &#125; TreeNode* KthNode(TreeNode* pRoot, int k) &#123; return helper(pRoot, k); &#125; &#125;; 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。 12345678910111213141516171819class Solution &#123;public: priority_queue&lt;int&gt; small, large; // 优先级队列 void Insert(int num) &#123; small.push(num); large.push(-small.top()); small.pop(); if (small.size() &lt; large.size()) &#123; small.push(-large.top()); large.pop(); &#125; &#125; double GetMedian() &#123; return small.size() &gt; large.size() ? small.top() : (small.top() - large.top()) / 2.0; &#125;&#125;; 滑动窗口最大值 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) &#123; int len = (long long)size; int n = num.size(); if (!len) return vector&lt;int&gt;(); deque&lt;int&gt; d; vector&lt;int&gt; ret; for (int i = 0; i &lt; n; i++) &#123; while (!d.empty() &amp;&amp; num[d.back()] &lt;= num[i]) d.pop_back(); d.push_back(i); while (!d.empty() &amp;&amp; d.front() &lt;= i - len) d.pop_front(); if (i &gt;= len - 1) ret.push_back(num[d.front()]); &#125; return ret; &#125;&#125;; 矩阵中的路径 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如 a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 123456789101112131415161718192021222324252627282930class Solution &#123;public: int m, n; bool helper(char* matrix, const char* s, int x, int y) &#123; if (*s == '\0') return true; if (x &lt; 0 || x &gt;= m || y &gt;= n || y &lt; 0) return false; char temp = matrix[x * n + y]; if (*s != temp) return false; matrix[x * n + y] = '\0'; if (helper(matrix, s + 1, x + 1, y) || helper(matrix, s + 1, x, y + 1) || helper(matrix, s + 1, x - 1, y) || helper(matrix, s + 1, x, y - 1)) return true; matrix[x * n + y] = temp; return false; &#125; bool hasPath(char* matrix, int rows, int cols, char* str) &#123; m = rows, n = cols; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (helper(matrix, str, i, j)) return true; &#125; &#125; return false; &#125;&#125;; 机器人的运动范围 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int m, n, k; bool check(int x, int y) &#123; int ans = 0; while (x) &#123; ans += x % 10; x /= 10; &#125; while (y) &#123; ans += y % 10; y /=10; &#125; return ans &gt; k; &#125; void helper(int x, int y, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int&amp; ret) &#123; if (x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n || visited[x][y] || check(x, y)) return; ret ++; visited[x][y] = true; int a[4] = &#123;0, 0, -1, 1&#125;, b[4] = &#123;-1, 1, 0, 0&#125;; for (int i = 0; i &lt; 4; i++) &#123; helper(x + a[i], y + b[i], visited, ret); &#125; &#125; int movingCount(int threshold, int rows, int cols) &#123; m = rows, n = cols, k = threshold; if (m &lt; 0 || n &lt; 0) &#123; return 0; &#125; vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false)); int ret = 0; helper(0, 0, visited, ret); return ret; &#125;&#125;;]]></content>
      <tags>
        <tag>总结</tag>
        <tag>算法</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CodeM 2018 资格赛]]></title>
    <url>%2F2018%2F06%2F09%2FcodeM-2018-qualify%2F</url>
    <content type="text"><![CDATA[去年没参加，今年抽空参加一下，因为没什么时间，六道题中就做了4题，剩下两题出来有空再更新具体详情可以参考参赛地址 2018-6-12官方更新了解题方法，如果想验证请尝试验证地址 A 下单题目：美团在吃喝玩乐等很多方面都给大家提供了便利。最近又增加了一项新业务：小象生鲜。这是新零售超市，你既可以在线下超市门店选购生鲜食品，也可以在手机App上下单，最快30分钟就配送到家。 新店开张免不了大优惠。我们要在小象生鲜超市里采购n个物品，每个物品价格为ai，有一些物品可以选择八折优惠（称为特价优惠）。 有m种满减优惠方式，满减优惠方式只有在所有物品都不选择特价优惠时才能使用，且最多只可以选择最多一款。 每种满减优惠描述为(bi,ci)，即满bi减ci（当消费&gt;=bi时优惠ci）。 求要买齐这n个物品（必须一单买齐），至少需要多少钱（保留两位小数）。 输入描述: 第一行，两个整数n,m。接下来n行，每行一个正整数ai，以及一个0/1表示是否可以选择特价优惠（1表示可以）。接下来m行，每行两个正整数bi,ci，描述一款满减优惠。 1 &lt;= n,m &lt;=101 &lt;= ai &lt;= 1001 &lt;= ci &lt; bi &lt;= 1000 输出描述:一行一个实数，表示至少需要消耗的钱数（保留恰好两位小数）。 示例1输入 12342 1 6 1 10 1 12 2 输出112.80 示例2输入123452 2 6 1 10 1 5 1 16 6 输出110.00 思路暴力枚举…. 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;stdio.h&gt;using namespace std;double helper(vector&lt;pair&lt;double, double&gt;&gt;&amp; nums, vector&lt;pair&lt;double, double&gt;&gt;&amp; rule) &#123; double ans = 0; double ret = 0; for (auto i : nums) &#123; ans += i.first; ret += i.second == 1.0 ? i.first * 0.8 : i.first; &#125; for (auto i : rule) &#123; if (i.first &lt;= ans) &#123; ret = ret &gt; (ans - i.second) ? (ans - i.second) : ret; &#125; &#125; return ret;&#125;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;pair&lt;double, double&gt;&gt; nums, rule; for (int i = 0; i &lt; n; i++) &#123; double a, b; cin &gt;&gt; a &gt;&gt; b; nums.push_back(make_pair(a, b)); &#125; for (int i = 0; i &lt; m; i++) &#123; double a, b; cin &gt;&gt; a &gt;&gt; b; rule.push_back(make_pair(a, b)); &#125; printf("%.2f\n", helper(nums, rule)); return 0;&#125; B 可乐题目描述小美和小团最近沉迷可乐。可供TA们选择的可乐共有k种，比如可口可乐、零度可乐等等，每种可乐会带给小美和小团不同的快乐程度。TA们一共要买n瓶可乐，每种可乐可以买无限多瓶，小美会随机挑选其中的m瓶喝，剩下的n-m瓶小团喝。请问应该如何购买可乐，使得小美和小团得到的快乐程度的和的期望值最大？现在请求出购买可乐的方案。 输入描述: 第一行三个整数n，m，k分别表示要买的可乐数、小美喝的可乐数以及可供选择的可乐种数。接下来k行，每行两个整数a，b分别表示某种可乐分别给予小美和小团的快乐程度。对于所有数据，1 &lt;= n &lt;= 10,000, 0 &lt;= m &lt;= n, 1 &lt;= k &lt;= 10,000, -10,000 &lt;= a, b &lt;= 10,000 输出描述: 一行k个整数，第i个整数表示购买第i种可乐的数目。如果有多解，请输出字典序最小的那个。对于两个序列 a1, a2, …, ak, b1, b2, …, bk，a的字典序小于b，当且仅当存在一个位置i &lt;= k满足：ai &lt; bi且对于所有的位置 j &lt; i，aj = bj； 思路：根据快乐程度的公式可以知道 $$\sum\limits_{i=1}^{n} (a_{i} w_{a} / w) n_{i} + (b_{i} w_{b} / w) n_{i} = A n_{i} + B n_{i} = (A + B) n_{i}$$ 所以这是个线性关系，要求全买其中一瓶可乐哪个最大。 官方解答： 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;utility&gt;using namespace std;void helper(vector&lt;pair&lt;double, double&gt;&gt;&amp; nums, int n, int m) &#123; double ret = -10E9; int index = -1; int len = nums.size(); for (int i = 0; i &lt; len; i++) &#123; auto temp = nums[i]; double ans = temp.first * m / n + temp.second * (n - m) / n; if (ret &lt;= ans) &#123; ret = ans; index = i; &#125; &#125; if (nums.empty()) return; if (index == 0) cout &lt;&lt; n; else cout &lt;&lt; "0"; for (int i = 1; i &lt; len; i++) &#123; if (i == index) &#123; cout &lt;&lt; " " &lt;&lt; n; &#125; else cout &lt;&lt; " 0"; &#125; cout &lt;&lt; endl;&#125;int main () &#123; int n, m, k; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; vector&lt;pair&lt;double, double&gt;&gt; nums; for (int i = 0; i &lt; k; i++) &#123; double a, b; cin &gt;&gt; a &gt;&gt; b; nums.push_back(make_pair(a, b)); &#125; helper(nums, n, m); return 0;&#125; C 世界杯 题意：给16支球队互相胜利的概率，问每支球队获胜的概率。 题目描述世界杯就要开始啦！真真正正的战斗从淘汰赛开始，现在我们给出球队之间的胜负概率，来预测每支球队夺冠的可能性。在接下来的篇幅中，我们将简单介绍淘汰赛阶段的规则。淘汰赛阶段的90分钟常规时间内（含补时阶段）进球多的球队取胜，如果参赛双方在90分钟内（含补时阶段）无法决出胜负，将进行上下半场各15分钟的加时赛。加时赛阶段，如果两队仍未分出胜负，则通过点球大战决出胜者。也就是说，每场比赛，有且仅有一个队能够晋级到下一轮。淘汰赛共有16支球队参加（小组赛阶段共分8个小组，每组前两名晋级），对阵安排如下。1/8决赛A组第一对阵B组第二=胜者1B组第一对阵A组第二=胜者2C组第一对阵D组第二=胜者3D组第一对阵C组第二=胜者4E组第一对阵F组第二=胜者5F组第一对阵E组第二=胜者6G组第一对阵H组第二=胜者7H组第一对阵G组第二=胜者8获胜的8个队进入1/4决赛，即所谓“8强”1/4决赛胜者1对阵胜者3=胜者A胜者2对阵胜者4=胜者B胜者5对阵胜者7=胜者C胜者6对阵胜者8=胜者D1/4决赛的4个获胜队进入“4强”半决赛胜者A对阵胜者C胜者B对阵胜者D半决赛获胜两队进入决赛，失利的两队争夺三名决赛获胜的队伍就是最后的冠军！ 输入描述:球队会被以1..16进行标号，其分别表示：1 A组第一；2 B组第二；3 C组第一；4 D组第二；5 E组第一；6 F组第二；7 G组第一；8 H组第二；9 B组第一；10 A组第二；11 D组第一；12 C组第二；13 F组第一；14 E组第二；15 H组第一；16 G组第二。 数据共有16行，每行16个浮点数，第i行第j列的数Fi,j表示i和j进行比赛时i获胜（包括常规时间获胜、加时赛获胜以及点球大战获胜）的概率。对于1 &lt;= i, j &lt;= 16 且 i != j, 满足0 &lt;= Fi,j &lt;= 1, Fi,j + Fj,i = 1；对于1 &lt;= i &lt;= 16, 满足 Fi,i = 0。 输出描述:输出一行16个浮点数，用空格隔开，分别表示每只球队获得世界杯的概率，结尾无空格。绝对误差或相对误差在1e-5之内的解会被判为正确。 输入123456789101112131415160.000 0.133 0.210 0.292 0.670 0.270 0.953 0.353 0.328 0.128 0.873 0.082 0.771 0.300 0.405 0.4550.867 0.000 0.621 0.384 0.934 0.847 0.328 0.488 0.785 0.308 0.158 0.774 0.923 0.261 0.872 0.9240.790 0.379 0.000 0.335 0.389 0.856 0.344 0.998 0.747 0.895 0.967 0.383 0.576 0.943 0.836 0.5370.708 0.616 0.665 0.000 0.146 0.362 0.757 0.942 0.596 0.903 0.381 0.281 0.294 0.788 0.804 0.6550.330 0.066 0.611 0.854 0.000 0.687 0.983 0.217 0.565 0.293 0.256 0.938 0.851 0.487 0.190 0.6800.730 0.153 0.144 0.638 0.313 0.000 0.832 0.526 0.429 0.707 0.414 0.617 0.925 0.638 0.526 0.5450.047 0.672 0.656 0.243 0.017 0.168 0.000 0.357 0.125 0.307 0.879 0.551 0.641 0.959 0.981 0.4650.647 0.512 0.002 0.058 0.783 0.474 0.643 0.000 0.325 0.494 0.893 0.064 0.563 0.429 0.501 0.8720.672 0.215 0.253 0.404 0.435 0.571 0.875 0.675 0.000 0.940 0.053 0.329 0.232 0.280 0.359 0.4740.872 0.692 0.105 0.097 0.707 0.293 0.693 0.506 0.060 0.000 0.040 0.776 0.589 0.704 0.018 0.9680.127 0.842 0.033 0.619 0.744 0.586 0.121 0.107 0.947 0.960 0.000 0.486 0.266 0.662 0.374 0.6980.918 0.226 0.617 0.719 0.062 0.383 0.449 0.936 0.671 0.224 0.514 0.000 0.821 0.027 0.415 0.2270.229 0.077 0.424 0.706 0.149 0.075 0.359 0.437 0.768 0.411 0.734 0.179 0.000 0.841 0.409 0.1580.700 0.739 0.057 0.212 0.513 0.362 0.041 0.571 0.720 0.296 0.338 0.973 0.159 0.000 0.935 0.7650.595 0.128 0.164 0.196 0.810 0.474 0.019 0.499 0.641 0.982 0.626 0.585 0.591 0.065 0.000 0.7610.545 0.076 0.463 0.345 0.320 0.455 0.535 0.128 0.526 0.032 0.302 0.773 0.842 0.235 0.239 0.000 输出10.0080193239 0.1871963989 0.0797523190 0.1233859685 0.0836167329 0.0438390981 0.0079035829 0.0604644891 0.0237087902 0.0050549016 0.1149551151 0.0679247259 0.0511307364 0.0395744604 0.0800843771 0.0233889799 思路16支球队组成一颗4层的二叉树，求每支球队到达根的概率。 官方思路 代码123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;double nums[17][17];double dp[37][17];void helper(int n) &#123; if (n &gt;= 16) &#123; dp[n][n - 16] = 1.0; &#125; else &#123; helper(n &lt;&lt; 1); helper(n &lt;&lt; 1 | 1); for (int i = 0; i &lt; 16; i++) &#123; for (int j = 0; j &lt; 16; j++) &#123; dp[n][i] += nums[i][j] * dp[n &lt;&lt; 1][i] * dp[n &lt;&lt; 1 | 1][j]; dp[n][j] += nums[j][i] * dp[n &lt;&lt; 1][i] * dp[n &lt;&lt; 1 | 1][j]; &#125; &#125; &#125;&#125;int main() &#123; memset(dp, 0.0, sizeof(dp)); for (int i = 0; i &lt; 16; i++) &#123; for (int j = 0; j &lt; 16; j++) &#123; cin &gt;&gt; nums[i][j]; &#125; &#125; helper(1); cout &lt;&lt; dp[1][0]; for (int i = 0; i &lt; 16; i++) &#123; cout &lt;&lt; " " &lt;&lt; dp[1][i]; &#125; cout &lt;&lt; endl; return 0;&#125; D 出线题目描述小胖参加了人生中最重要的比赛——MedoC 资格赛。MedoC 的资格赛由 m 轮构成，使用常见的 “加权标准分” 的规则。每位选手需要参加所有的 m 轮的比赛。在一轮中，能取得的分数为自己的成绩除掉最高分的成绩。每个选手的总分为每一轮获得的分数乘上这一轮比赛占得比重。如果在某一轮比赛中所有人获得了零分，那么所有选手在这一轮获得的分数都为 0 分。比如说，资格赛一共 3 轮，三轮的权重分别为 30%, 30%, 40%。在第一轮中，小胖获得了 300 分，最高分也为 300 分。在第二轮中，小胖获得了 0 分，最高分也为 0 分。在第三轮中，小胖获得了 150 分，最高分为 300 分，那么小胖的总分为 (300/300)30%+030%+(150/300)*40%=0.5。一共有 n 位选手参加了比赛，其中成绩最高的 k 位选手能够晋级到初赛。如果有多人在分数线上同分，那么系统会随机在这些同分的人中选取，选满 k 个晋级为止。小胖现在知道了每个选手每场比赛的成绩，但是由于他的疏忽，其中的某个人某场比赛的成绩消失了。所以更多人出线的情况变得未知起来。现在只知道成绩一定是 0 到 C 之间的一个整数（包含 0 和 C）。小胖想知道对于每个人的出线情况是怎么样的，也就是一定能出线，一定不能出线还是有可能出线。 输入描述:第一行四个正整数 n,m,k,C (m &lt;= 6, k &lt;= n &lt;= 500, C &lt;= 500)。接下来一行 m 个整数 w1, w2, …, wm，表示每场比赛的权重，第 i 场比赛的权重为 wi/(w1+w2+…+wm)，保证 wi &gt;= 0 且 1 &lt;= w1 + w2 + … + wm &lt;= 1000。接下来 n 行每行 m 个整数，第 i 个整数表示这个选手在第 i 场比赛中获得的成绩。如果这个数字为 - 1 表示这个数据丢失，保证恰好有一个 - 1。 输出描述:n 行每行输出一个 1 到 3 之间的整数。1 表示一定出线，2 表示一定不出线，3 表示可能出线。 思路这题如果看清楚题意与数据范围真的不难, 因为 - 1 只有一个, 从 0~C 枚举即可 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;void helper(vector&lt;vector&lt;long long&gt;&gt;&amp; nums, vector&lt;long long&gt; w, const int n, const int m, const int k, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; vector&lt;long long&gt; score(n, 0); vector&lt;long long&gt; mark(n, 0); vector&lt;long long&gt; max_score(m, 0); vector&lt;long long&gt; ans(m, 1); for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; max_score[i] = max_score[i] &lt; nums[j][i] ? nums[j][i] : max_score[i]; &#125; if (max_score[i] == 0) &#123; max_score[i] = 1; &#125; &#125; // 直接将所有max_score连称会溢出 for (int i = 0; i &lt; m; i++) &#123; ans[i] = w[i]; for (int j = 0; j &lt; m; j++) &#123; if (j != i) ans[i] *= max_score[j]; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; score[i] += nums[i][j] * ans[j]; &#125; mark[i] = score[i]; &#125; sort(mark.begin(), mark.end(), greater&lt;long long&gt;()); for (int i = 0; i &lt; n; i++) &#123; if (mark[k-1] &lt;= score[i]) ret[0][i] ++; // 胜利的局数 if (k != n &amp;&amp; mark[k] &gt;= score[i]) ret[1][i] ++; // 失败的局数 &#125;&#125;int main() &#123; int n, m, k, C; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; C; vector&lt;long long&gt; w(m, 0); for (int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; w[i]; &#125; int x, y; vector&lt;vector&lt;long long&gt;&gt; nums(n, vector&lt;long long&gt;(m, 0)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; nums[i][j]; if (nums[i][j] == -1) x = i, y = j; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; ret(2, vector&lt;int&gt;(n, 0)); for (int i = 0; i &lt;= C; i++) &#123; nums[x][y] = i; helper(nums, w, n, m, k, ret); &#125; for (int i = 0; i &lt; n; i++) &#123; if (ret[1][i] == 0) cout &lt;&lt; 1 &lt;&lt; endl; else if (ret[0][i] == 0) cout &lt;&lt; 2 &lt;&lt; endl; else cout &lt;&lt; 3 &lt;&lt; endl; &#125; return 0;&#125; E 你的城市题目描述2018年第一季度，美团旅行的酒店业务以5770万的订单总量，成为行业第一名。与此同时，美团旅行也提供机票、火车票、船票等各种服务，不断开辟新的目的旅游城市。最近新开的目的地，就包括对小A有特殊意义的偏僻小城C。“我来到 你的城市 熟悉的那一条街。”小A哼着歌，从北京出发，要去C城。这对他非常重要，必须当天到达，虽然交通并不是非常方便。但是，错过火车并不是一个小概率事件。为了保险起见，小A决定选择一个即使错过火车也存在补救措施的交通方案。（即假使未赶上原方案中的任何一班火车，依然可以改乘其他的车次能够在当天到达C城，但同时小A是一个乐观主义者，所以他认为改乘以后的所有车次都不会延误。）当然了，在满足上述条件的情况下，小A希望花费的钱越少越好（只考虑计划中的，不考虑发生意外时换乘带来的代价）。城市及交通网可以看做一张n个点m条边的有向图。每个点代表一个城市（1号点代表北京，n号点代表C城）。每条边由一个五元组&lt;x, y, c, ts, td&gt;组成，表示存在一个车次，由ts时刻从城市x出发，在td时刻到达城市y，且花费为c元。为了简化问题，ts，td均为以半小时为基本单位（具体格式见样例及Hint）。并假设每次中转最少需要花费半个小时，且中转只能发生在同一城市（即到达一个城市距离再次从这个城市出发至少需要间隔半个小时），注意，小 A 如果因为没赶上车次需要改乘，也需要半个小时的时间。问小A到达C城最少需要花费多少钱（行程必须在这一天内完成，可以在0:00上车，也可以在24:00到达）。 输入描述:第一行，两个正整数n, m。n表示城市数量，m表示当天不同班次的火车数量。接下来m行，每行3个整数x, y, c加两个字符串ts, td，均以空格作为分隔，表示当天的某一班火车。其中x, y, c, ts, td的含义如前描述。所有的车次都是当天的，没有隔夜的票。2 &lt;= n &lt;= 500, m &lt;= 15000, c &lt;= 1000, ts &lt; td，所有数均为正整数。车次保证不过夜，时间范围0:00, 0:30, 1:00, … , 23:00, 23:30, 24:00，可能存在重复车次。 输出描述:一个整数，表示存在补救措施的前提下，小A到达C城的最小花费。如果不存在这样的路径，则输出-1。 示例1输入1234563 51 3 800 18:00 21:001 2 650 13:30 14:002 3 100 14:00 18:002 3 300 14:30 19:002 3 200 15:00 19:30 输出1950 说明选择第二个和第四个车次。第三个车次由于中转时间太短无法选择。第五个车次由于没有可改乘的航班无法选择。如果错过第二个车次，可以改乘第一个车次。如果错过第四个车次，可以改乘第五个车次。 示例2输入1234563 51 2 1000 0:00 12:001 2 100 0:30 14:001 2 100 0:30 15:002 3 300 16:00 24:002 3 200 16:30 24:00 输出11300 说明选择第一个和第四个车次。不能选择第二个车次是因为，如果错过了0:30的车次2，那么同样在0:30出发的车次3也是来不及改乘的。 示例3输入123453 41 2 100 0:30 14:001 2 200 0:30 15:002 3 300 16:00 24:002 3 200 16:30 24:00 输出1-1 说明和样例二类似，但是缺少了原先的车次一，所以没有换乘方案。 示例4输入123453 41 2 100 0:30 14:001 2 200 1:00 16:002 3 300 16:00 24:002 3 200 16:30 24:00 输出1400 说明选择第一个和第三个车次。 示例5输入123453 41 2 100 0:30 14:001 2 200 1:00 16:302 3 300 16:00 24:002 3 200 16:30 24:00 输出1-1 说明和样例四类似，但假如错过了第一个车次，改乘车次二在16:30到达城市2是不足以赶上16:30出发的车次四的。 D 匹配##题目描述美团外卖日订单已经超过2000万，背后有一个非常复杂的智能调度系统。我们考虑一个简化的情形，有n个外卖小哥要去 n 家商店取货，第 i 个外卖小哥到达商店 j 需要时间 e[i][j] 。现在有 m 对外卖小哥和商店的合作关系。假定每个外卖小哥只能取到一个货物，每个商店只需要一位外卖小哥取货。询问最少多少时间，能有 k 位外卖小哥到达 k 个商店取到货物？对于每个 k ，都输出一个数表示最少使用时间，如果无解输出 -1。 输入描述:第一行输入两个整数 n , m （1 &lt;= n &lt;= 1000 , 1 &lt;= m &lt;= 100000）。接下来 m 行，每行输入 3 个整数 i , j , e[i][j] (1 &lt;= i, j &lt;= n , 0 &lt;= e[i][j] &lt;= 10^9)，定义如题所述。注：本题测试用例较多，请耐心等待判题结果，也可以去排行榜刷新查看自己的提交结果。 输出描述:输出一行n个整数，第 i 个整数，表示当 k=i 时，需要的最少时间，如果无解输出-1，结尾无空格。 示例1输入123456783 71 3 52 3 23 1 71 2 02 3 23 2 02 1 5 输出0 2 5]]></content>
      <tags>
        <tag>算法</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deeplearning.ai 笔记作业（二）week1]]></title>
    <url>%2F2018%2F05%2F28%2Fdeeplearning-ai-nn-and-dl-chapter-2-week1%2F</url>
    <content type="text"><![CDATA[第二章 改善深层神经网络 week1 笔记设定机器学习模型作为深度学习的机器学习模型，其中包含很多超参数，包括层数，每层单元个数，学习速率，激活函数等等。另外，机器学习还包括深度神经网络以外的方法和内容，下面将主要介绍。 设定不同的数据集（训练/验证/测试数据集）通常情况下，为了充分的利用和检验已有的数据集，将数据集分成三个部分，分别为 训练集，验证集以及 测试集，验证集是将数据分成已有的数据进行验证（当实际场景中要求实时性，没有测试数据时特别有用，否则无法验证模型的有效性），通常将数据分成6:2:2。 验证集只是起到验证模型有效性的作用，如果数据量特别大时，验证集没有必要设置的特别大，只需要选取一万或几万条数据就可以起到验证效果。 我们在进行数据划分的时候，必须要有训练集与验证集和测试集相同的数据分布的假设，比如在离线数据中最好采用均匀采样的方式划分数据集。如果数据分布不同的话，会产生很大的问题，例如在识别汽车的场景中，训练数据通常是比较高清的照片，但是如果测试集采用的是手机拍摄的低像素照片的话，很明显无法在测试集中起到很好的效果。所以， 机器学习的所有假设都是在测试集和训练集在统一数据分布的条件下进行的，虽然在实际场景中无法严格满足，但是要做到尽量的接近无偏估计。 在实际场景中，我们的数据模型往往是没有现有的测试集进行测试的（常常是不断更新的），但是如果训练之后的模型效果不好就上线往往会产生比较严重的后果。所以，通常将数据集先分成训练集和验证集，用验证集去验证现有的模型效果，从而直接跳过测试步骤，因为在 无偏估计的前提下，验证过程以及完成了测试过程，如果数据量很大不会产生很大偏差。 Bias / VariianceBias（偏差），Variance（方差），Error（误差）是机器学习中的基本概念。Bias表示模型对于数据表现出的整体分布的拟合偏差，Variance表现模型预估的结果与数据分布的实际期望的偏离程度（事实上不可能有对所有数据都能完美拟合的模型，因为数据取值空间太大），而error可以表示为模型预测结果与真实结果的偏差。可以用一下图表示其中的关系： 所以根据奥卡姆剃刀原理，如果模型在训练数据集中拟合效果特别好的话，其泛化能力往往很差。 针对于深度学习而言，通常用以下图来应对high bias和high variance:对于普通的机器学习模型而言，通常要做”Bias Variance trade off”，但是深度学习就不需要做这个取舍，这也是深度学习的优势之一。 正则化因为模型的目的是减小损失，所以对于以下单层网络逻辑回归而言： 对于神经网络而言，有以下讲解： 通常神经网络用L2范式进行正则化，通过在参数后面增加正则化项，可以使得每个参数的权重衰减，减小每个输入的作用，从而起到减小网络结构的作用，提高模型的泛化能力。 为什么正则化能减小过拟合首先来说明什么情况下会导致过拟合，从下图可以看出来，最右边的非线性太强，使得每个训练集都拟合，这样再来了一个随机样本可能就不能准确的预估。但是左边的又线性过强，无法准确涵盖大部分训练数据。所以引入正则系数$\lambda$，$\lambda$越大，W越接近0，网络中一些隐藏的神经单元作用越低，线性表现越强烈。 对于常用的tanh激活函数而言，参数越接近0，激活函数表现的线性越强，所以正则化效果也就越好。当z接近于0的时候，整个神经网络实际上就更趋近于一个线性的感知机了。 Dropout正则化将神经网络中的神经元随机失活，首先以一定的概率选择删除的节点，然后使用反向传播对精简后的网络进行权值更新，然后恢复被删除的节点，循环往复以上的过程，直至得到我们想要的结果。 以下代码实现之后，50个神经单元会变成40个从而减少单次训练带来的数据过拟合：123456keepProb = 0.8 # 80% 留存# randn使用的是高斯分布，rand使用的是均匀分布，因为这里每个权值都是同样机会的，所以使用均匀随机数。d3 = np.random.rand(a3.shape[0], a3.shape[1]) &lt; keepProb# 在相乘运算时，python会自动将True转化为1，False转化为0a3 = np.multiply(a3, d3)a3 /= keepProb 但是对于正在处于测试阶段（测试梯度是否正确）的程序，我们不能使用Dropout，因为Dropout会使损失和迭代次数的关系不是递减关系，从而影响对于梯度的检验。 同时，根据每一层的结构变化，需要设置不同的保存门限，例如下图的形式，对于不可能过拟合的点就用1.0，对于叠加层数比较多的店，保存门限取值可以小一些。 理解Dropout 直接可以参考marsggbo的博客 除去marsggbo所提到的内容，还有一些补充： 因为计算机视觉通常涉及的维度比较大，所以是比较常用Dropout的领域。 Dropout的缺点是损失J不明确，所以用J/Iteration调试的时候就不能使用Dropout了 通常机器学习可以分成优化和判断模型是否最优两个步骤，但是Early Stopping是将这两个步骤合并了，一定程度上增大了模型的不确定性，但是，对于要搜索巨大空间的$\lambda$而言，还是能够在时间上做了合理的折中。 输入正则化正则化数据前后的数据分布特点正则化前后梯度下降的区别没有规格化之前，各个输入维度的尺度不尽相同，而且不够均匀导致学习时间比较长，梯度下降过程缓慢。 梯度消失和梯度爆炸对于以下深度学习网络：假设所有激活函数都为线性函数，yhat=W[l]W[l-1]…W[0]X，如果W比单位矩阵I大时，随着L的增大，yhat会变得非常大，相应的，如果W比单位矩阵I小时，yhat会变得非常小，而且，激活函数也会指数性的减小。 通过神经网络初始化解决梯度问题本节主要介绍通过参数方法解决梯度问题，对于ReLU的参数初始化，可以参考神经网络权重初始化问题 同时，对于tanh激活函数，也有Xavier初始化。 通常，参数初始化有三种初始化方式，可以参考三种权重的初始化方法 梯度检验利用双侧求导的方式进行梯度验证，保证梯度求导的没问题，这里一定要进行训练前的验证，否则训练的时候会非常痛苦。一般采用的方法是计算欧氏距离，判决的门限可以设为10-7，然后计算每一层的误差，如果差的很多，就需要找W和b的代码bug了。 梯度检验小贴士 梯度检验只需要用在debug的时候，用来检验反向传播算法是不是正确的，但是在训练模型的时候，就要把它关了，因为训练速度会非常慢。 如果梯度检测出现问题，需要定位到它所在那一层的W和b的组成进行debug（玄学debug） 如果损失函数使用了正则化项，那么计算梯度验证的时候也必须加上梯度的导数 不要和dropout一起用，因为dropout会使运算结果随机变化，无法使得J/iteration函数严格递减，所以检测过程中要把keep_prob设为1.0 这一点有点玄学，在初始检验之后，迭代一段时间，再进行一次梯度检验，以为可能在W接近0的时候算法是有效的，W变大之后由于bug的原因算法就会出现问题。 作业课堂小quiz下载并查看 InitializationWelcome to the first assignment of “Improving Deep Neural Networks”. Training your neural network requires specifying an initial value of the weights. A well chosen initialization method will help learning. If you completed the previous course of this specialization, you probably followed our instructions for weight initialization, and it has worked out so far. But how do you choose the initialization for a new neural network? In this notebook, you will see how different initializations lead to different results. A well chosen initialization can: Speed up the convergence of gradient descent Increase the odds of gradient descent converging to a lower training (and generalization) error To get started, run the following cell to load the packages and the planar dataset you will try to classify. 1234567891011121314import numpy as npimport matplotlib.pyplot as pltimport sklearnimport sklearn.datasetsfrom init_utils import sigmoid, relu, compute_loss, forward_propagation, backward_propagationfrom init_utils import update_parameters, predict, load_dataset, plot_decision_boundary, predict_dec%matplotlib inlineplt.rcParams['figure.figsize'] = (7.0, 4.0) # set default size of plotsplt.rcParams['image.interpolation'] = 'nearest'plt.rcParams['image.cmap'] = 'gray'# load image dataset: blue/red dots in circlestrain_X, train_Y, test_X, test_Y = load_dataset() You would like a classifier to separate the blue dots from the red dots. 1 - Neural Network modelYou will use a 3-layer neural network (already implemented for you). Here are the initialization methods you will experiment with: Zeros initialization – setting initialization = &quot;zeros&quot; in the input argument. Random initialization – setting initialization = &quot;random&quot; in the input argument. This initializes the weights to large random values. He initialization – setting initialization = &quot;he&quot; in the input argument. This initializes the weights to random values scaled according to a paper by He et al., 2015. Instructions: Please quickly read over the code below, and run it. In the next part you will implement the three initialization methods that this model() calls. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758def model(X, Y, learning_rate = 0.01, num_iterations = 15000, print_cost = True, initialization = "he"): """ Implements a three-layer neural network: LINEAR-&gt;RELU-&gt;LINEAR-&gt;RELU-&gt;LINEAR-&gt;SIGMOID. Arguments: X -- input data, of shape (2, number of examples) Y -- true "label" vector (containing 0 for red dots; 1 for blue dots), of shape (1, number of examples) learning_rate -- learning rate for gradient descent num_iterations -- number of iterations to run gradient descent print_cost -- if True, print the cost every 1000 iterations initialization -- flag to choose which initialization to use ("zeros","random" or "he") Returns: parameters -- parameters learnt by the model """ grads = &#123;&#125; costs = [] # to keep track of the loss m = X.shape[1] # number of examples layers_dims = [X.shape[0], 10, 5, 1] # Initialize parameters dictionary. if initialization == "zeros": parameters = initialize_parameters_zeros(layers_dims) elif initialization == "random": parameters = initialize_parameters_random(layers_dims) elif initialization == "he": parameters = initialize_parameters_he(layers_dims) # Loop (gradient descent) for i in range(0, num_iterations): # Forward propagation: LINEAR -&gt; RELU -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID. a3, cache = forward_propagation(X, parameters) # Loss cost = compute_loss(a3, Y) # Backward propagation. grads = backward_propagation(X, Y, cache) # Update parameters. parameters = update_parameters(parameters, grads, learning_rate) # Print the loss every 1000 iterations if print_cost and i % 1000 == 0: print("Cost after iteration &#123;&#125;: &#123;&#125;".format(i, cost)) costs.append(cost) # plot the loss plt.plot(costs) plt.ylabel('cost') plt.xlabel('iterations (per hundreds)') plt.title("Learning rate =" + str(learning_rate)) plt.show() return parameters 2 - Zero initializationThere are two types of parameters to initialize in a neural network: the weight matrices $(W^{[1]}, W^{[2]}, W^{[3]}, …, W^{[L-1]}, W^{[L]})$ the bias vectors $(b^{[1]}, b^{[2]}, b^{[3]}, …, b^{[L-1]}, b^{[L]})$ Exercise: Implement the following function to initialize all parameters to zeros. You’ll see later that this does not work well since it fails to “break symmetry”, but lets try it anyway and see what happens. Use np.zeros((..,..)) with the correct shapes. 12345678910111213141516171819202122232425# GRADED FUNCTION: initialize_parameters_zeros def initialize_parameters_zeros(layers_dims): """ Arguments: layer_dims -- python array (list) containing the size of each layer. Returns: parameters -- python dictionary containing your parameters "W1", "b1", ..., "WL", "bL": W1 -- weight matrix of shape (layers_dims[1], layers_dims[0]) b1 -- bias vector of shape (layers_dims[1], 1) ... WL -- weight matrix of shape (layers_dims[L], layers_dims[L-1]) bL -- bias vector of shape (layers_dims[L], 1) """ parameters = &#123;&#125; L = len(layers_dims) # number of layers in the network for l in range(1, L): ### START CODE HERE ### (≈ 2 lines of code) parameters['W' + str(l)] = np.zeros((layers_dims[l], layers_dims[l - 1])) parameters['b' + str(l)] = np.zeros((layers_dims[l], 1)) ### END CODE HERE ### return parameters 12345parameters = initialize_parameters_zeros([3,2,1])print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) W1 = [[ 0. 0. 0.] [ 0. 0. 0.]] b1 = [[ 0.] [ 0.]] W2 = [[ 0. 0.]] b2 = [[ 0.]] Expected Output: W1 [[ 0. 0. 0.] [ 0. 0. 0.]] b1 [[ 0.] [ 0.]] W2 [[ 0. 0.]] b2 [[ 0.]] Run the following code to train your model on 15,000 iterations using zeros initialization. 12345parameters = model(train_X, train_Y, initialization = "zeros")print ("On the train set:")predictions_train = predict(train_X, train_Y, parameters)print ("On the test set:")predictions_test = predict(test_X, test_Y, parameters) Cost after iteration 0: 0.6931471805599453 Cost after iteration 1000: 0.6931471805599453 Cost after iteration 2000: 0.6931471805599453 Cost after iteration 3000: 0.6931471805599453 Cost after iteration 4000: 0.6931471805599453 Cost after iteration 5000: 0.6931471805599453 Cost after iteration 6000: 0.6931471805599453 Cost after iteration 7000: 0.6931471805599453 Cost after iteration 8000: 0.6931471805599453 Cost after iteration 9000: 0.6931471805599453 Cost after iteration 10000: 0.6931471805599455 Cost after iteration 11000: 0.6931471805599453 Cost after iteration 12000: 0.6931471805599453 Cost after iteration 13000: 0.6931471805599453 Cost after iteration 14000: 0.6931471805599453 On the train set: Accuracy: 0.5 On the test set: Accuracy: 0.5 The performance is really bad, and the cost does not really decrease, and the algorithm performs no better than random guessing. Why? Lets look at the details of the predictions and the decision boundary: 12print ("predictions_train = " + str(predictions_train))print ("predictions_test = " + str(predictions_test)) predictions_train = [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]] predictions_test = [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]] 12345plt.title("Model with Zeros initialization")axes = plt.gca()axes.set_xlim([-1.5,1.5])axes.set_ylim([-1.5,1.5])plot_decision_boundary(lambda x: predict_dec(parameters, x.T), train_X, train_Y) The model is predicting 0 for every example. In general, initializing all the weights to zero results in the network failing to break symmetry. This means that every neuron in each layer will learn the same thing, and you might as well be training a neural network with $n^{[l]}=1$ for every layer, and the network is no more powerful than a linear classifier such as logistic regression. What you should remember: The weights $W^{[l]}$ should be initialized randomly to break symmetry. It is however okay to initialize the biases $b^{[l]}$ to zeros. Symmetry is still broken so long as $W^{[l]}$ is initialized randomly. 3 - Random initializationTo break symmetry, lets intialize the weights randomly. Following random initialization, each neuron can then proceed to learn a different function of its inputs. In this exercise, you will see what happens if the weights are intialized randomly, but to very large values. Exercise: Implement the following function to initialize your weights to large random values (scaled by *10) and your biases to zeros. Use np.random.randn(..,..) * 10 for weights and np.zeros((.., ..)) for biases. We are using a fixed np.random.seed(..) to make sure your “random” weights match ours, so don’t worry if running several times your code gives you always the same initial values for the parameters. 123456789101112131415161718192021222324252627# GRADED FUNCTION: initialize_parameters_randomdef initialize_parameters_random(layers_dims): """ Arguments: layer_dims -- python array (list) containing the size of each layer. Returns: parameters -- python dictionary containing your parameters "W1", "b1", ..., "WL", "bL": W1 -- weight matrix of shape (layers_dims[1], layers_dims[0]) b1 -- bias vector of shape (layers_dims[1], 1) ... WL -- weight matrix of shape (layers_dims[L], layers_dims[L-1]) bL -- bias vector of shape (layers_dims[L], 1) """ np.random.seed(3) # This seed makes sure your "random" numbers will be the as ours parameters = &#123;&#125; L = len(layers_dims) # integer representing the number of layers for l in range(1, L): ### START CODE HERE ### (≈ 2 lines of code) parameters['W' + str(l)] = np.random.randn(layers_dims[l], layers_dims[l - 1]) * 10 parameters['b' + str(l)] = np.zeros((layers_dims[l], 1)) ### END CODE HERE ### return parameters 12345parameters = initialize_parameters_random([3, 2, 1])print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) W1 = [[ 17.88628473 4.36509851 0.96497468] [-18.63492703 -2.77388203 -3.54758979]] b1 = [[ 0.] [ 0.]] W2 = [[-0.82741481 -6.27000677]] b2 = [[ 0.]] Expected Output: W1 [[ 17.88628473 4.36509851 0.96497468] [-18.63492703 -2.77388203 -3.54758979]] b1 [[ 0.] [ 0.]] W2 [[-0.82741481 -6.27000677]] b2 [[ 0.]] Run the following code to train your model on 15,000 iterations using random initialization. 12345parameters = model(train_X, train_Y, initialization = "random")print ("On the train set:")predictions_train = predict(train_X, train_Y, parameters)print ("On the test set:")predictions_test = predict(test_X, test_Y, parameters) /home/jovyan/work/week5/Initialization/init_utils.py:145: RuntimeWarning: divide by zero encountered in log logprobs = np.multiply(-np.log(a3),Y) + np.multiply(-np.log(1 - a3), 1 - Y) /home/jovyan/work/week5/Initialization/init_utils.py:145: RuntimeWarning: invalid value encountered in multiply logprobs = np.multiply(-np.log(a3),Y) + np.multiply(-np.log(1 - a3), 1 - Y) Cost after iteration 0: inf Cost after iteration 1000: 0.6237287551108738 Cost after iteration 2000: 0.5981106708339466 Cost after iteration 3000: 0.5638353726276827 Cost after iteration 4000: 0.550152614449184 Cost after iteration 5000: 0.5444235275228304 Cost after iteration 6000: 0.5374184054630083 Cost after iteration 7000: 0.47357131493578297 Cost after iteration 8000: 0.39775634899580387 Cost after iteration 9000: 0.3934632865981078 Cost after iteration 10000: 0.39202525076484457 Cost after iteration 11000: 0.38921493051297673 Cost after iteration 12000: 0.38614221789840486 Cost after iteration 13000: 0.38497849983013926 Cost after iteration 14000: 0.38278397192120406 On the train set: Accuracy: 0.83 On the test set: Accuracy: 0.86 If you see “inf” as the cost after the iteration 0, this is because of numerical roundoff; a more numerically sophisticated implementation would fix this. But this isn’t worth worrying about for our purposes. Anyway, it looks like you have broken symmetry, and this gives better results. than before. The model is no longer outputting all 0s. 12print (predictions_train)print (predictions_test) [[1 0 1 1 0 0 1 1 1 1 1 0 1 0 0 1 0 1 1 0 0 0 1 0 1 1 1 1 1 1 0 1 1 0 0 1 1 1 1 1 1 1 1 0 1 1 1 1 0 1 0 1 1 1 1 0 0 1 1 1 1 0 1 1 0 1 0 1 1 1 1 0 0 0 0 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 0 0 1 1 1 0 1 1 0 1 0 1 1 0 1 1 0 1 0 1 1 0 0 1 0 0 1 1 0 1 1 1 0 1 0 0 1 0 1 1 1 1 1 1 1 0 1 1 0 0 1 1 0 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 0 1 1 0 1 0 1 1 0 1 0 1 1 1 1 0 1 1 1 1 0 1 0 1 0 1 1 1 1 0 1 1 0 1 1 0 1 1 0 1 0 1 1 1 0 1 1 1 0 1 0 1 0 0 1 0 1 1 0 1 1 0 1 1 0 1 1 1 0 1 1 1 1 0 1 0 0 1 1 0 1 1 1 0 0 0 1 1 0 1 1 1 1 0 1 1 0 1 1 1 0 0 1 0 0 0 1 0 0 0 1 1 1 1 0 0 0 0 1 1 1 1 0 0 1 1 1 1 1 1 1 0 0 0 1 1 1 1 0]] [[1 1 1 1 0 1 0 1 1 0 1 1 1 0 0 0 0 1 0 1 0 0 1 0 1 0 1 1 1 1 1 0 0 0 0 1 0 1 1 0 0 1 1 1 1 1 0 1 1 1 0 1 0 1 1 0 1 0 1 0 1 1 1 1 1 1 1 1 1 0 1 0 1 1 1 1 1 0 1 0 0 1 0 0 0 1 1 0 1 1 0 0 0 1 1 0 1 1 0 0]] 12345plt.title("Model with large random initialization")axes = plt.gca()axes.set_xlim([-1.5,1.5])axes.set_ylim([-1.5,1.5])plot_decision_boundary(lambda x: predict_dec(parameters, x.T), train_X, train_Y) Observations: The cost starts very high. This is because with large random-valued weights, the last activation (sigmoid) outputs results that are very close to 0 or 1 for some examples, and when it gets that example wrong it incurs a very high loss for that example. Indeed, when $\log(a^{[3]}) = \log(0)$, the loss goes to infinity. Poor initialization can lead to vanishing/exploding gradients, which also slows down the optimization algorithm. If you train this network longer you will see better results, but initializing with overly large random numbers slows down the optimization. In summary: Initializing weights to very large random values does not work well. Hopefully intializing with small random values does better. The important question is: how small should be these random values be? Lets find out in the next part! 4 - He initializationFinally, try “He Initialization”; this is named for the first author of He et al., 2015. (If you have heard of “Xavier initialization”, this is similar except Xavier initialization uses a scaling factor for the weights $W^{[l]}$ of sqrt(1./layers_dims[l-1]) where He initialization would use sqrt(2./layers_dims[l-1]).) Exercise: Implement the following function to initialize your parameters with He initialization. Hint: This function is similar to the previous initialize_parameters_random(...). The only difference is that instead of multiplying np.random.randn(..,..) by 10, you will multiply it by $\sqrt{\frac{2}{\text{dimension of the previous layer}}}$, which is what He initialization recommends for layers with a ReLU activation. 123456789101112131415161718192021222324252627# GRADED FUNCTION: initialize_parameters_hedef initialize_parameters_he(layers_dims): """ Arguments: layer_dims -- python array (list) containing the size of each layer. Returns: parameters -- python dictionary containing your parameters "W1", "b1", ..., "WL", "bL": W1 -- weight matrix of shape (layers_dims[1], layers_dims[0]) b1 -- bias vector of shape (layers_dims[1], 1) ... WL -- weight matrix of shape (layers_dims[L], layers_dims[L-1]) bL -- bias vector of shape (layers_dims[L], 1) """ np.random.seed(3) parameters = &#123;&#125; L = len(layers_dims) - 1 # integer representing the number of layers for l in range(1, L + 1): ### START CODE HERE ### (≈ 2 lines of code) parameters['W' + str(l)] = np.random.randn(layers_dims[l], layers_dims[l - 1]) * np.sqrt(2. / layers_dims[l - 1]) parameters['b' + str(l)] = np.zeros((layers_dims[l], 1)) ### END CODE HERE ### return parameters 12345parameters = initialize_parameters_he([2, 4, 1])print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) W1 = [[ 1.78862847 0.43650985] [ 0.09649747 -1.8634927 ] [-0.2773882 -0.35475898] [-0.08274148 -0.62700068]] b1 = [[ 0.] [ 0.] [ 0.] [ 0.]] W2 = [[-0.03098412 -0.33744411 -0.92904268 0.62552248]] b2 = [[ 0.]] Expected Output: W1 [[ 1.78862847 0.43650985] [ 0.09649747 -1.8634927 ] [-0.2773882 -0.35475898] [-0.08274148 -0.62700068]] b1 [[ 0.] [ 0.] [ 0.] [ 0.]] W2 [[-0.03098412 -0.33744411 -0.92904268 0.62552248]] b2 [[ 0.]] Run the following code to train your model on 15,000 iterations using He initialization. 12345parameters = model(train_X, train_Y, initialization = "he")print ("On the train set:")predictions_train = predict(train_X, train_Y, parameters)print ("On the test set:")predictions_test = predict(test_X, test_Y, parameters) Cost after iteration 0: 0.8830537463419761 Cost after iteration 1000: 0.6879825919728063 Cost after iteration 2000: 0.6751286264523371 Cost after iteration 3000: 0.6526117768893807 Cost after iteration 4000: 0.6082958970572938 Cost after iteration 5000: 0.5304944491717495 Cost after iteration 6000: 0.4138645817071794 Cost after iteration 7000: 0.3117803464844441 Cost after iteration 8000: 0.23696215330322562 Cost after iteration 9000: 0.18597287209206836 Cost after iteration 10000: 0.1501555628037182 Cost after iteration 11000: 0.12325079292273548 Cost after iteration 12000: 0.09917746546525937 Cost after iteration 13000: 0.0845705595402428 Cost after iteration 14000: 0.07357895962677366 On the train set: Accuracy: 0.993333333333 On the test set: Accuracy: 0.96 12345plt.title("Model with He initialization")axes = plt.gca()axes.set_xlim([-1.5,1.5])axes.set_ylim([-1.5,1.5])plot_decision_boundary(lambda x: predict_dec(parameters, x.T), train_X, train_Y) Observations: The model with He initialization separates the blue and the red dots very well in a small number of iterations. 5 - ConclusionsYou have seen three different types of initializations. For the same number of iterations and same hyperparameters the comparison is: Model Train accuracy Problem/Comment 3-layer NN with zeros initialization 50% fails to break symmetry 3-layer NN with large random initialization 83% too large weights 3-layer NN with He initialization 99% recommended method What you should remember from this notebook: Different initializations lead to different results Random initialization is used to break symmetry and make sure different hidden units can learn different things Don’t intialize to values that are too large He initialization works well for networks with ReLU activations. RegularizationWelcome to the second assignment of this week. Deep Learning models have so much flexibility and capacity that overfitting can be a serious problem, if the training dataset is not big enough. Sure it does well on the training set, but the learned network doesn’t generalize to new examples that it has never seen! You will learn to: Use regularization in your deep learning models. Let’s first import the packages you are going to use. 1234567891011121314# import packagesimport numpy as npimport matplotlib.pyplot as pltfrom reg_utils import sigmoid, relu, plot_decision_boundary, initialize_parameters, load_2D_dataset, predict_decfrom reg_utils import compute_cost, predict, forward_propagation, backward_propagation, update_parametersimport sklearnimport sklearn.datasetsimport scipy.iofrom testCases import *%matplotlib inlineplt.rcParams['figure.figsize'] = (7.0, 4.0) # set default size of plotsplt.rcParams['image.interpolation'] = 'nearest'plt.rcParams['image.cmap'] = 'gray' Problem Statement: You have just been hired as an AI expert by the French Football Corporation. They would like you to recommend positions where France’s goal keeper should kick the ball so that the French team’s players can then hit it with their head. Figure 1 : Football field The goal keeper kicks the ball in the air, the players of each team are fighting to hit the ball with their head They give you the following 2D dataset from France’s past 10 games. 1train_X, train_Y, test_X, test_Y = load_2D_dataset() Each dot corresponds to a position on the football field where a football player has hit the ball with his/her head after the French goal keeper has shot the ball from the left side of the football field. If the dot is blue, it means the French player managed to hit the ball with his/her head If the dot is red, it means the other team’s player hit the ball with their head Your goal: Use a deep learning model to find the positions on the field where the goalkeeper should kick the ball. Analysis of the dataset: This dataset is a little noisy, but it looks like a diagonal line separating the upper left half (blue) from the lower right half (red) would work well. You will first try a non-regularized model. Then you’ll learn how to regularize it and decide which model you will choose to solve the French Football Corporation’s problem. 1 - Non-regularized modelYou will use the following neural network (already implemented for you below). This model can be used: in regularization mode – by setting the lambd input to a non-zero value. We use “lambd“ instead of “lambda“ because “lambda“ is a reserved keyword in Python. in dropout mode – by setting the keep_prob to a value less than one You will first try the model without any regularization. Then, you will implement: L2 regularization – functions: “compute_cost_with_regularization()“ and “backward_propagation_with_regularization()“ Dropout – functions: “forward_propagation_with_dropout()“ and “backward_propagation_with_dropout()“ In each part, you will run this model with the correct inputs so that it calls the functions you’ve implemented. Take a look at the code below to familiarize yourself with the model. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768def model(X, Y, learning_rate = 0.3, num_iterations = 30000, print_cost = True, lambd = 0, keep_prob = 1): """ Implements a three-layer neural network: LINEAR-&gt;RELU-&gt;LINEAR-&gt;RELU-&gt;LINEAR-&gt;SIGMOID. Arguments: X -- input data, of shape (input size, number of examples) Y -- true "label" vector (1 for blue dot / 0 for red dot), of shape (output size, number of examples) learning_rate -- learning rate of the optimization num_iterations -- number of iterations of the optimization loop print_cost -- If True, print the cost every 10000 iterations lambd -- regularization hyperparameter, scalar keep_prob - probability of keeping a neuron active during drop-out, scalar. Returns: parameters -- parameters learned by the model. They can then be used to predict. """ grads = &#123;&#125; costs = [] # to keep track of the cost m = X.shape[1] # number of examples layers_dims = [X.shape[0], 20, 3, 1] # Initialize parameters dictionary. parameters = initialize_parameters(layers_dims) # Loop (gradient descent) for i in range(0, num_iterations): # Forward propagation: LINEAR -&gt; RELU -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID. if keep_prob == 1: a3, cache = forward_propagation(X, parameters) elif keep_prob &lt; 1: a3, cache = forward_propagation_with_dropout(X, parameters, keep_prob) # Cost function if lambd == 0: cost = compute_cost(a3, Y) else: cost = compute_cost_with_regularization(a3, Y, parameters, lambd) # Backward propagation. assert(lambd==0 or keep_prob==1) # it is possible to use both L2 regularization and dropout, # but this assignment will only explore one at a time if lambd == 0 and keep_prob == 1: grads = backward_propagation(X, Y, cache) elif lambd != 0: grads = backward_propagation_with_regularization(X, Y, cache, lambd) elif keep_prob &lt; 1: grads = backward_propagation_with_dropout(X, Y, cache, keep_prob) # Update parameters. parameters = update_parameters(parameters, grads, learning_rate) # Print the loss every 10000 iterations if print_cost and i % 10000 == 0: print("Cost after iteration &#123;&#125;: &#123;&#125;".format(i, cost)) if print_cost and i % 1000 == 0: costs.append(cost) # plot the cost plt.plot(costs) plt.ylabel('cost') plt.xlabel('iterations (x1,000)') plt.title("Learning rate =" + str(learning_rate)) plt.show() return parameters Let’s train the model without any regularization, and observe the accuracy on the train/test sets. 12345parameters = model(train_X, train_Y)print ("On the training set:")predictions_train = predict(train_X, train_Y, parameters)print ("On the test set:")predictions_test = predict(test_X, test_Y, parameters) Cost after iteration 0: 0.6557412523481002 Cost after iteration 10000: 0.16329987525724216 Cost after iteration 20000: 0.13851642423255986 On the training set: Accuracy: 0.947867298578 On the test set: Accuracy: 0.915 The train accuracy is 94.8% while the test accuracy is 91.5%. This is the baseline model (you will observe the impact of regularization on this model). Run the following code to plot the decision boundary of your model. 12345plt.title("Model without regularization")axes = plt.gca()axes.set_xlim([-0.75,0.40])axes.set_ylim([-0.75,0.65])plot_decision_boundary(lambda x: predict_dec(parameters, x.T), train_X, train_Y) The non-regularized model is obviously overfitting the training set. It is fitting the noisy points! Lets now look at two techniques to reduce overfitting. 2 - L2 RegularizationThe standard way to avoid overfitting is called L2 regularization. It consists of appropriately modifying your cost function, from:$$J = -\frac{1}{m} \sum\limits_{i = 1}^{m} \large{(}\small y^{(i)}\log\left(a^{L}\right) + (1-y^{(i)})\log\left(1- a^{L}\right) \large{)} \tag{1}$$To:$$J_{regularized} = \small \underbrace{-\frac{1}{m} \sum\limits_{i = 1}^{m} \large{(}\small y^{(i)}\log\left(a^{L}\right) + (1-y^{(i)})\log\left(1- a^{L}\right) \large{)} }_\text{cross-entropy cost} + \underbrace{\frac{1}{m} \frac{\lambda}{2} \sum\limits_l\sum\limits_k\sum\limits_j W_{k,j}^{[l]2} }_\text{L2 regularization cost} \tag{2}$$ Let’s modify your cost and observe the consequences. Exercise: Implement compute_cost_with_regularization() which computes the cost given by formula (2). To calculate $\sum\limits_k\sum\limits_j W_{k,j}^{[l]2}$ , use :1np.sum(np.square(Wl)) Note that you have to do this for $W^{[1]}$, $W^{[2]}$ and $W^{[3]}$, then sum the three terms and multiply by $ \frac{1}{m} \frac{\lambda}{2} $. 12345678910111213141516171819202122232425262728# GRADED FUNCTION: compute_cost_with_regularizationdef compute_cost_with_regularization(A3, Y, parameters, lambd): """ Implement the cost function with L2 regularization. See formula (2) above. Arguments: A3 -- post-activation, output of forward propagation, of shape (output size, number of examples) Y -- "true" labels vector, of shape (output size, number of examples) parameters -- python dictionary containing parameters of the model Returns: cost - value of the regularized loss function (formula (2)) """ m = Y.shape[1] W1 = parameters["W1"] W2 = parameters["W2"] W3 = parameters["W3"] cross_entropy_cost = compute_cost(A3, Y) # This gives you the cross-entropy part of the cost ### START CODE HERE ### (approx. 1 line) L2_regularization_cost = (np.sum(np.square(W1)) + np.sum(np.square(W2)) + np.sum(np.square(W3))) * lambd / (2.0 * m) ### END CODER HERE ### cost = cross_entropy_cost + L2_regularization_cost return cost 123A3, Y_assess, parameters = compute_cost_with_regularization_test_case()print("cost = " + str(compute_cost_with_regularization(A3, Y_assess, parameters, lambd = 0.1))) cost = 1.78648594516 Expected Output: cost 1.78648594516 Of course, because you changed the cost, you have to change backward propagation as well! All the gradients have to be computed with respect to this new cost. Exercise: Implement the changes needed in backward propagation to take into account regularization. The changes only concern dW1, dW2 and dW3. For each, you have to add the regularization term’s gradient ($\frac{d}{dW} ( \frac{1}{2}\frac{\lambda}{m} W^2) = \frac{\lambda}{m} W$). 123456789101112131415161718192021222324252627282930313233343536373839404142434445# GRADED FUNCTION: backward_propagation_with_regularizationdef backward_propagation_with_regularization(X, Y, cache, lambd): """ Implements the backward propagation of our baseline model to which we added an L2 regularization. Arguments: X -- input dataset, of shape (input size, number of examples) Y -- "true" labels vector, of shape (output size, number of examples) cache -- cache output from forward_propagation() lambd -- regularization hyperparameter, scalar Returns: gradients -- A dictionary with the gradients with respect to each parameter, activation and pre-activation variables """ m = X.shape[1] (Z1, A1, W1, b1, Z2, A2, W2, b2, Z3, A3, W3, b3) = cache dZ3 = A3 - Y ### START CODE HERE ### (approx. 1 line) dW3 = 1./m * np.dot(dZ3, A2.T) + np.dot(W3, lambd) / m ### END CODE HERE ### db3 = 1./m * np.sum(dZ3, axis=1, keepdims = True) dA2 = np.dot(W3.T, dZ3) dZ2 = np.multiply(dA2, np.int64(A2 &gt; 0)) ### START CODE HERE ### (approx. 1 line) dW2 = 1./m * np.dot(dZ2, A1.T) + np.dot(W2, lambd) / m ### END CODE HERE ### db2 = 1./m * np.sum(dZ2, axis=1, keepdims = True) dA1 = np.dot(W2.T, dZ2) dZ1 = np.multiply(dA1, np.int64(A1 &gt; 0)) ### START CODE HERE ### (approx. 1 line) dW1 = 1./m * np.dot(dZ1, X.T) + np.dot(W1, lambd) / m ### END CODE HERE ### db1 = 1./m * np.sum(dZ1, axis=1, keepdims = True) gradients = &#123;"dZ3": dZ3, "dW3": dW3, "db3": db3,"dA2": dA2, "dZ2": dZ2, "dW2": dW2, "db2": db2, "dA1": dA1, "dZ1": dZ1, "dW1": dW1, "db1": db1&#125; return gradients 123456X_assess, Y_assess, cache = backward_propagation_with_regularization_test_case()grads = backward_propagation_with_regularization(X_assess, Y_assess, cache, lambd = 0.7)print ("dW1 = "+ str(grads["dW1"]))print ("dW2 = "+ str(grads["dW2"]))print ("dW3 = "+ str(grads["dW3"])) dW1 = [[-0.25604646 0.12298827 -0.28297129] [-0.17706303 0.34536094 -0.4410571 ]] dW2 = [[ 0.79276486 0.85133918] [-0.0957219 -0.01720463] [-0.13100772 -0.03750433]] dW3 = [[-1.77691347 -0.11832879 -0.09397446]] Expected Output: dW1 [[-0.25604646 0.12298827 -0.28297129] [-0.17706303 0.34536094 -0.4410571 ]] dW2 [[ 0.79276486 0.85133918] [-0.0957219 -0.01720463] [-0.13100772 -0.03750433]] dW3 [[-1.77691347 -0.11832879 -0.09397446]] Let’s now run the model with L2 regularization $(\lambda = 0.7)$. The model() function will call: compute_cost_with_regularization instead of compute_cost backward_propagation_with_regularization instead of backward_propagation 12345parameters = model(train_X, train_Y, lambd = 0.7)print ("On the train set:")predictions_train = predict(train_X, train_Y, parameters)print ("On the test set:")predictions_test = predict(test_X, test_Y, parameters) Cost after iteration 0: 0.6974484493131264 Cost after iteration 10000: 0.2684918873282239 Cost after iteration 20000: 0.2680916337127301 On the train set: Accuracy: 0.938388625592 On the test set: Accuracy: 0.93 Congrats, the test set accuracy increased to 93%. You have saved the French football team! You are not overfitting the training data anymore. Let’s plot the decision boundary. 12345plt.title("Model with L2-regularization")axes = plt.gca()axes.set_xlim([-0.75,0.40])axes.set_ylim([-0.75,0.65])plot_decision_boundary(lambda x: predict_dec(parameters, x.T), train_X, train_Y) Observations: The value of $\lambda$ is a hyperparameter that you can tune using a dev set. L2 regularization makes your decision boundary smoother. If $\lambda$ is too large, it is also possible to “oversmooth”, resulting in a model with high bias. What is L2-regularization actually doing?: L2-regularization relies on the assumption that a model with small weights is simpler than a model with large weights. Thus, by penalizing the square values of the weights in the cost function you drive all the weights to smaller values. It becomes too costly for the cost to have large weights! This leads to a smoother model in which the output changes more slowly as the input changes. What you should remember – the implications of L2-regularization on: The cost computation: A regularization term is added to the cost The backpropagation function: There are extra terms in the gradients with respect to weight matrices Weights end up smaller (“weight decay”): Weights are pushed to smaller values. 3 - DropoutFinally, dropout is a widely used regularization technique that is specific to deep learning.It randomly shuts down some neurons in each iteration. Watch these two videos to see what this means! Figure 2 : Drop-out on the second hidden layer. At each iteration, you shut down (= set to zero) each neuron of a layer with probability $1 - keep_prob$ or keep it with probability $keep_prob$ (50% here). The dropped neurons don’t contribute to the training in both the forward and backward propagations of the iteration. Figure 3 : Drop-out on the first and third hidden layers. $1^{st}$ layer: we shut down on average 40% of the neurons. $3^{rd}$ layer: we shut down on average 20% of the neurons. When you shut some neurons down, you actually modify your model. The idea behind drop-out is that at each iteration, you train a different model that uses only a subset of your neurons. With dropout, your neurons thus become less sensitive to the activation of one other specific neuron, because that other neuron might be shut down at any time. 3.1 - Forward propagation with dropoutExercise: Implement the forward propagation with dropout. You are using a 3 layer neural network, and will add dropout to the first and second hidden layers. We will not apply dropout to the input layer or output layer. Instructions:You would like to shut down some neurons in the first and second layers. To do that, you are going to carry out 4 Steps: In lecture, we dicussed creating a variable $d^{[1]}$ with the same shape as $a^{[1]}$ using np.random.rand() to randomly get numbers between 0 and 1. Here, you will use a vectorized implementation, so create a random matrix $D^{[1]} = [d^{1} d^{1} … d^{1}] $ of the same dimension as $A^{[1]}$. Set each entry of $D^{[1]}$ to be 0 with probability (1-keep_prob) or 1 with probability (keep_prob), by thresholding values in $D^{[1]}$ appropriately. Hint: to set all the entries of a matrix X to 0 (if entry is less than 0.5) or 1 (if entry is more than 0.5) you would do: X = (X &lt; 0.5). Note that 0 and 1 are respectively equivalent to False and True. Set $A^{[1]}$ to $A^{[1]} * D^{[1]}$. (You are shutting down some neurons). You can think of $D^{[1]}$ as a mask, so that when it is multiplied with another matrix, it shuts down some of the values. Divide $A^{[1]}$ by keep_prob. By doing this you are assuring that the result of the cost will still have the same expected value as without drop-out. (This technique is also called inverted dropout.) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# GRADED FUNCTION: forward_propagation_with_dropoutdef forward_propagation_with_dropout(X, parameters, keep_prob = 0.5): """ Implements the forward propagation: LINEAR -&gt; RELU + DROPOUT -&gt; LINEAR -&gt; RELU + DROPOUT -&gt; LINEAR -&gt; SIGMOID. Arguments: X -- input dataset, of shape (2, number of examples) parameters -- python dictionary containing your parameters "W1", "b1", "W2", "b2", "W3", "b3": W1 -- weight matrix of shape (20, 2) b1 -- bias vector of shape (20, 1) W2 -- weight matrix of shape (3, 20) b2 -- bias vector of shape (3, 1) W3 -- weight matrix of shape (1, 3) b3 -- bias vector of shape (1, 1) keep_prob - probability of keeping a neuron active during drop-out, scalar Returns: A3 -- last activation value, output of the forward propagation, of shape (1,1) cache -- tuple, information stored for computing the backward propagation """ np.random.seed(1) # retrieve parameters W1 = parameters["W1"] b1 = parameters["b1"] W2 = parameters["W2"] b2 = parameters["b2"] W3 = parameters["W3"] b3 = parameters["b3"] # LINEAR -&gt; RELU -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID # randn生成的是高斯分布的随机数，rand生成的是均匀分布的随机数 Z1 = np.dot(W1, X) + b1 A1 = relu(Z1) ### START CODE HERE ### (approx. 4 lines) # Steps 1-4 below correspond to the Steps 1-4 described above. D1 = np.random.rand(A1.shape[0], A1.shape[1]) # Step 1: initialize matrix D1 = np.random.rand(..., ...) D1 = (D1 &lt; keep_prob) # Step 2: convert entries of D1 to 0 or 1 (using keep_prob as the threshold) A1 = np.multiply(A1, D1) # Step 3: shut down some neurons of A1 A1 = A1 / keep_prob # Step 4: scale the value of neurons that haven't been shut down ### END CODE HERE ### Z2 = np.dot(W2, A1) + b2 A2 = relu(Z2) ### START CODE HERE ### (approx. 4 lines) D2 = np.random.rand(A2.shape[0], A2.shape[1]) # Step 1: initialize matrix D2 = np.random.rand(..., ...) D2 = (D2 &lt; keep_prob) # Step 2: convert entries of D2 to 0 or 1 (using keep_prob as the threshold) A2 = np.multiply(A2, D2) # Step 3: shut down some neurons of A2 A2 = A2 / keep_prob # Step 4: scale the value of neurons that haven't been shut down ### END CODE HERE ### Z3 = np.dot(W3, A2) + b3 A3 = sigmoid(Z3) cache = (Z1, D1, A1, W1, b1, Z2, D2, A2, W2, b2, Z3, A3, W3, b3) return A3, cache 1234X_assess, parameters = forward_propagation_with_dropout_test_case()A3, cache = forward_propagation_with_dropout(X_assess, parameters, keep_prob = 0.7)print ("A3 = " + str(A3)) A3 = [[ 0.36974721 0.00305176 0.04565099 0.49683389 0.36974721]] Expected Output: A3 [[ 0.36974721 0.00305176 0.04565099 0.49683389 0.36974721]] 3.2 - Backward propagation with dropoutExercise: Implement the backward propagation with dropout. As before, you are training a 3 layer network. Add dropout to the first and second hidden layers, using the masks $D^{[1]}$ and $D^{[2]}$ stored in the cache. Instruction:Backpropagation with dropout is actually quite easy. You will have to carry out 2 Steps: You had previously shut down some neurons during forward propagation, by applying a mask $D^{[1]}$ to A1. In backpropagation, you will have to shut down the same neurons, by reapplying the same mask $D^{[1]}$ to dA1. During forward propagation, you had divided A1 by keep_prob. In backpropagation, you’ll therefore have to divide dA1 by keep_prob again (the calculus interpretation is that if $A^{[1]}$ is scaled by keep_prob, then its derivative $dA^{[1]}$ is also scaled by the same keep_prob). 123456789101112131415161718192021222324252627282930313233343536373839404142434445# GRADED FUNCTION: backward_propagation_with_dropoutdef backward_propagation_with_dropout(X, Y, cache, keep_prob): """ Implements the backward propagation of our baseline model to which we added dropout. Arguments: X -- input dataset, of shape (2, number of examples) Y -- "true" labels vector, of shape (output size, number of examples) cache -- cache output from forward_propagation_with_dropout() keep_prob - probability of keeping a neuron active during drop-out, scalar Returns: gradients -- A dictionary with the gradients with respect to each parameter, activation and pre-activation variables """ m = X.shape[1] (Z1, D1, A1, W1, b1, Z2, D2, A2, W2, b2, Z3, A3, W3, b3) = cache dZ3 = A3 - Y dW3 = 1./m * np.dot(dZ3, A2.T) db3 = 1./m * np.sum(dZ3, axis=1, keepdims = True) dA2 = np.dot(W3.T, dZ3) ### START CODE HERE ### (≈ 2 lines of code) dA2 = np.multiply(dA2, D2) # Step 1: Apply mask D2 to shut down the same neurons as during the forward propagation dA2 = dA2 / keep_prob # Step 2: Scale the value of neurons that haven't been shut down ### END CODE HERE ### dZ2 = np.multiply(dA2, np.int64(A2 &gt; 0)) dW2 = 1./m * np.dot(dZ2, A1.T) db2 = 1./m * np.sum(dZ2, axis=1, keepdims = True) dA1 = np.dot(W2.T, dZ2) ### START CODE HERE ### (≈ 2 lines of code) dA1 = np.multiply(dA1, D1) # Step 1: Apply mask D1 to shut down the same neurons as during the forward propagation dA1 = dA1 / keep_prob # Step 2: Scale the value of neurons that haven't been shut down ### END CODE HERE ### dZ1 = np.multiply(dA1, np.int64(A1 &gt; 0)) dW1 = 1./m * np.dot(dZ1, X.T) db1 = 1./m * np.sum(dZ1, axis=1, keepdims = True) gradients = &#123;"dZ3": dZ3, "dW3": dW3, "db3": db3,"dA2": dA2, "dZ2": dZ2, "dW2": dW2, "db2": db2, "dA1": dA1, "dZ1": dZ1, "dW1": dW1, "db1": db1&#125; return gradients 123456X_assess, Y_assess, cache = backward_propagation_with_dropout_test_case()gradients = backward_propagation_with_dropout(X_assess, Y_assess, cache, keep_prob = 0.8)print ("dA1 = " + str(gradients["dA1"]))print ("dA2 = " + str(gradients["dA2"])) dA1 = [[ 0.36544439 0. -0.00188233 0. -0.17408748] [ 0.65515713 0. -0.00337459 0. -0. ]] dA2 = [[ 0.58180856 0. -0.00299679 0. -0.27715731] [ 0. 0.53159854 -0. 0.53159854 -0.34089673] [ 0. 0. -0.00292733 0. -0. ]] Expected Output: dA1 [[ 0.36544439 0. -0.00188233 0. -0.17408748] [ 0.65515713 0. -0.00337459 0. -0. ]] dA2 [[ 0.58180856 0. -0.00299679 0. -0.27715731] [ 0. 0.53159854 -0. 0.53159854 -0.34089673] [ 0. 0. -0.00292733 0. -0. ]] Let’s now run the model with dropout (keep_prob = 0.86). It means at every iteration you shut down each neurons of layer 1 and 2 with 14% probability. The function model() will now call: forward_propagation_with_dropout instead of forward_propagation. backward_propagation_with_dropout instead of backward_propagation. 123456parameters = model(train_X, train_Y, keep_prob = 0.86, learning_rate = 0.3)print ("On the train set:")predictions_train = predict(train_X, train_Y, parameters)print ("On the test set:")predictions_test = predict(test_X, test_Y, parameters) Cost after iteration 0: 0.6543912405149825 /home/jovyan/work/week5/Regularization/reg_utils.py:236: RuntimeWarning: divide by zero encountered in log logprobs = np.multiply(-np.log(a3),Y) + np.multiply(-np.log(1 - a3), 1 - Y) /home/jovyan/work/week5/Regularization/reg_utils.py:236: RuntimeWarning: invalid value encountered in multiply logprobs = np.multiply(-np.log(a3),Y) + np.multiply(-np.log(1 - a3), 1 - Y) Cost after iteration 10000: 0.06101698657490559 Cost after iteration 20000: 0.060582435798513114 On the train set: Accuracy: 0.928909952607 On the test set: Accuracy: 0.95 Dropout works great! The test accuracy has increased again (to 95%)! Your model is not overfitting the training set and does a great job on the test set. The French football team will be forever grateful to you! Run the code below to plot the decision boundary. 12345plt.title("Model with dropout")axes = plt.gca()axes.set_xlim([-0.75,0.40])axes.set_ylim([-0.75,0.65])plot_decision_boundary(lambda x: predict_dec(parameters, x.T), train_X, train_Y) Note: A common mistake when using dropout is to use it both in training and testing. You should use dropout (randomly eliminate nodes) only in training. Deep learning frameworks like tensorflow, PaddlePaddle, keras or caffe come with a dropout layer implementation. Don’t stress - you will soon learn some of these frameworks. What you should remember about dropout: Dropout is a regularization technique. You only use dropout during training. Don’t use dropout (randomly eliminate nodes) during test time. Apply dropout both during forward and backward propagation. During training time, divide each dropout layer by keep_prob to keep the same expected value for the activations. For example, if keep_prob is 0.5, then we will on average shut down half the nodes, so the output will be scaled by 0.5 since only the remaining half are contributing to the solution. Dividing by 0.5 is equivalent to multiplying by 2. Hence, the output now has the same expected value. You can check that this works even when keep_prob is other values than 0.5. 4 - ConclusionsHere are the results of our three models: model train accuracy test accuracy 3-layer NN without regularization 95% 91.5% 3-layer NN with L2-regularization 94% 93% 3-layer NN with dropout 93% 95% Note that regularization hurts training set performance! This is because it limits the ability of the network to overfit to the training set. But since it ultimately gives better test accuracy, it is helping your system. Congratulations for finishing this assignment! And also for revolutionizing French football. :-) What we want you to remember from this notebook: Regularization will help you reduce overfitting. Regularization will drive your weights to lower values. L2 regularization and Dropout are two very effective regularization techniques. Gradient CheckingWelcome to the final assignment for this week! In this assignment you will learn to implement and use gradient checking. You are part of a team working to make mobile payments available globally, and are asked to build a deep learning model to detect fraud–whenever someone makes a payment, you want to see if the payment might be fraudulent, such as if the user’s account has been taken over by a hacker. But backpropagation is quite challenging to implement, and sometimes has bugs. Because this is a mission-critical application, your company’s CEO wants to be really certain that your implementation of backpropagation is correct. Your CEO says, “Give me a proof that your backpropagation is actually working!” To give this reassurance, you are going to use “gradient checking”. Let’s do it! 1234# Packagesimport numpy as npfrom testCases import *from gc_utils import sigmoid, relu, dictionary_to_vector, vector_to_dictionary, gradients_to_vector 1) How does gradient checking work?Backpropagation computes the gradients $\frac{\partial J}{\partial \theta}$, where $\theta$ denotes the parameters of the model. $J$ is computed using forward propagation and your loss function. Because forward propagation is relatively easy to implement, you’re confident you got that right, and so you’re almost 100% sure that you’re computing the cost $J$ correctly. Thus, you can use your code for computing $J$ to verify the code for computing $\frac{\partial J}{\partial \theta}$. Let’s look back at the definition of a derivative (or gradient):$$ \frac{\partial J}{\partial \theta} = \lim_{\varepsilon \to 0} \frac{J(\theta + \varepsilon) - J(\theta - \varepsilon)}{2 \varepsilon} \tag{1}$$ If you’re not familiar with the “$\displaystyle \lim_{\varepsilon \to 0}$” notation, it’s just a way of saying “when $\varepsilon$ is really really small.” We know the following: $\frac{\partial J}{\partial \theta}$ is what you want to make sure you’re computing correctly. You can compute $J(\theta + \varepsilon)$ and $J(\theta - \varepsilon)$ (in the case that $\theta$ is a real number), since you’re confident your implementation for $J$ is correct. Lets use equation (1) and a small value for $\varepsilon$ to convince your CEO that your code for computing $\frac{\partial J}{\partial \theta}$ is correct! 2) 1-dimensional gradient checkingConsider a 1D linear function $J(\theta) = \theta x$. The model contains only a single real-valued parameter $\theta$, and takes $x$ as input. You will implement code to compute $J(.)$ and its derivative $\frac{\partial J}{\partial \theta}$. You will then use gradient checking to make sure your derivative computation for $J$ is correct. Figure 1 : 1D linear model The diagram above shows the key computation steps: First start with $x$, then evaluate the function $J(x)$ (“forward propagation”). Then compute the derivative $\frac{\partial J}{\partial \theta}$ (“backward propagation”). Exercise: implement “forward propagation” and “backward propagation” for this simple function. I.e., compute both $J(.)$ (“forward propagation”) and its derivative with respect to $\theta$ (“backward propagation”), in two separate functions. 12345678910111213141516171819# GRADED FUNCTION: forward_propagationdef forward_propagation(x, theta): """ Implement the linear forward propagation (compute J) presented in Figure 1 (J(theta) = theta * x) Arguments: x -- a real-valued input theta -- our parameter, a real number as well Returns: J -- the value of function J, computed using the formula J(theta) = theta * x """ ### START CODE HERE ### (approx. 1 line) J = theta * x ### END CODE HERE ### return J 123x, theta = 2, 4J = forward_propagation(x, theta)print ("J = " + str(J)) J = 8 Expected Output: J 8 Exercise: Now, implement the backward propagation step (derivative computation) of Figure 1. That is, compute the derivative of $J(\theta) = \theta x$ with respect to $\theta$. To save you from doing the calculus, you should get $dtheta = \frac { \partial J }{ \partial \theta} = x$. 12345678910111213141516171819# GRADED FUNCTION: backward_propagationdef backward_propagation(x, theta): """ Computes the derivative of J with respect to theta (see Figure 1). Arguments: x -- a real-valued input theta -- our parameter, a real number as well Returns: dtheta -- the gradient of the cost with respect to theta """ ### START CODE HERE ### (approx. 1 line) dtheta = x ### END CODE HERE ### return dtheta 123x, theta = 2, 4dtheta = backward_propagation(x, theta)print ("dtheta = " + str(dtheta)) dtheta = 2 Expected Output: dtheta 2 Exercise: To show that the backward_propagation() function is correctly computing the gradient $\frac{\partial J}{\partial \theta}$, let’s implement gradient checking. Instructions: First compute “gradapprox” using the formula above (1) and a small value of $\varepsilon$. Here are the Steps to follow: $\theta^{+} = \theta + \varepsilon$ $\theta^{-} = \theta - \varepsilon$ $J^{+} = J(\theta^{+})$ $J^{-} = J(\theta^{-})$ $gradapprox = \frac{J^{+} - J^{-}}{2 \varepsilon}$ Then compute the gradient using backward propagation, and store the result in a variable “grad” Finally, compute the relative difference between “gradapprox” and the “grad” using the following formula:$$ difference = \frac {\mid\mid grad - gradapprox \mid\mid_2}{\mid\mid grad \mid\mid_2 + \mid\mid gradapprox \mid\mid_2} \tag{2}$$You will need 3 Steps to compute this formula: 1’. compute the numerator using np.linalg.norm(…) 2’. compute the denominator. You will need to call np.linalg.norm(…) twice. 3’. divide them. If this difference is small (say less than $10^{-7}$), you can be quite confident that you have computed your gradient correctly. Otherwise, there may be a mistake in the gradient computation. 1234567891011121314151617181920212223242526272829303132333435363738394041# GRADED FUNCTION: gradient_checkdef gradient_check(x, theta, epsilon = 1e-7): """ Implement the backward propagation presented in Figure 1. Arguments: x -- a real-valued input theta -- our parameter, a real number as well epsilon -- tiny shift to the input to compute approximated gradient with formula(1) Returns: difference -- difference (2) between the approximated gradient and the backward propagation gradient """ # Compute gradapprox using left side of formula (1). epsilon is small enough, you don't need to worry about the limit. ### START CODE HERE ### (approx. 5 lines) thetaplus = theta + epsilon # Step 1 thetaminus = theta - epsilon # Step 2 J_plus = forward_propagation(x, thetaplus) # Step 3 J_minus = forward_propagation(x, thetaminus) # Step 4 gradapprox = (J_plus - J_minus) / (2 * epsilon) # Step 5 ### END CODE HERE ### # Check if gradapprox is close enough to the output of backward_propagation() ### START CODE HERE ### (approx. 1 line) grad = backward_propagation(x, theta) ### END CODE HERE ### ### START CODE HERE ### (approx. 1 line) numerator = np.linalg.norm(grad - gradapprox) # Step 1' denominator = np.linalg.norm(grad) + np.linalg.norm(gradapprox) # Step 2' difference = numerator / denominator # Step 3' ### END CODE HERE ### if difference &lt; 1e-7: print ("The gradient is correct!") else: print ("The gradient is wrong!") return difference 123x, theta = 2, 4difference = gradient_check(x, theta)print("difference = " + str(difference)) The gradient is correct! difference = 2.91933588329e-10 Expected Output:The gradient is correct! difference 2.9193358103083e-10 Congrats, the difference is smaller than the $10^{-7}$ threshold. So you can have high confidence that you’ve correctly computed the gradient in backward_propagation(). Now, in the more general case, your cost function $J$ has more than a single 1D input. When you are training a neural network, $\theta$ actually consists of multiple matrices $W^{[l]}$ and biases $b^{[l]}$! It is important to know how to do a gradient check with higher-dimensional inputs. Let’s do it! 3) N-dimensional gradient checkingThe following figure describes the forward and backward propagation of your fraud detection model. Figure 2 : deep neural networkLINEAR -&gt; RELU -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID Let’s look at your implementations for forward propagation and backward propagation. 12345678910111213141516171819202122232425262728293031323334353637383940414243def forward_propagation_n(X, Y, parameters): """ Implements the forward propagation (and computes the cost) presented in Figure 3. Arguments: X -- training set for m examples Y -- labels for m examples parameters -- python dictionary containing your parameters "W1", "b1", "W2", "b2", "W3", "b3": W1 -- weight matrix of shape (5, 4) b1 -- bias vector of shape (5, 1) W2 -- weight matrix of shape (3, 5) b2 -- bias vector of shape (3, 1) W3 -- weight matrix of shape (1, 3) b3 -- bias vector of shape (1, 1) Returns: cost -- the cost function (logistic cost for one example) """ # retrieve parameters m = X.shape[1] W1 = parameters["W1"] b1 = parameters["b1"] W2 = parameters["W2"] b2 = parameters["b2"] W3 = parameters["W3"] b3 = parameters["b3"] # LINEAR -&gt; RELU -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID Z1 = np.dot(W1, X) + b1 A1 = relu(Z1) Z2 = np.dot(W2, A1) + b2 A2 = relu(Z2) Z3 = np.dot(W3, A2) + b3 A3 = sigmoid(Z3) # Cost logprobs = np.multiply(-np.log(A3),Y) + np.multiply(-np.log(1 - A3), 1 - Y) cost = 1./m * np.sum(logprobs) cache = (Z1, A1, W1, b1, Z2, A2, W2, b2, Z3, A3, W3, b3) return cost, cache Now, run backward propagation. 1234567891011121314151617181920212223242526272829303132333435def backward_propagation_n(X, Y, cache): """ Implement the backward propagation presented in figure 2. Arguments: X -- input datapoint, of shape (input size, 1) Y -- true "label" cache -- cache output from forward_propagation_n() Returns: gradients -- A dictionary with the gradients of the cost with respect to each parameter, activation and pre-activation variables. """ m = X.shape[1] (Z1, A1, W1, b1, Z2, A2, W2, b2, Z3, A3, W3, b3) = cache dZ3 = A3 - Y dW3 = 1./m * np.dot(dZ3, A2.T) db3 = 1./m * np.sum(dZ3, axis=1, keepdims = True) dA2 = np.dot(W3.T, dZ3) dZ2 = np.multiply(dA2, np.int64(A2 &gt; 0)) dW2 = 1./m * np.dot(dZ2, A1.T) * 2 db2 = 1./m * np.sum(dZ2, axis=1, keepdims = True) dA1 = np.dot(W2.T, dZ2) dZ1 = np.multiply(dA1, np.int64(A1 &gt; 0)) dW1 = 1./m * np.dot(dZ1, X.T) db1 = 4./m * np.sum(dZ1, axis=1, keepdims = True) gradients = &#123;"dZ3": dZ3, "dW3": dW3, "db3": db3, "dA2": dA2, "dZ2": dZ2, "dW2": dW2, "db2": db2, "dA1": dA1, "dZ1": dZ1, "dW1": dW1, "db1": db1&#125; return gradients You obtained some results on the fraud detection test set but you are not 100% sure of your model. Nobody’s perfect! Let’s implement gradient checking to verify if your gradients are correct. How does gradient checking work?. As in 1) and 2), you want to compare “gradapprox” to the gradient computed by backpropagation. The formula is still: $$ \frac{\partial J}{\partial \theta} = \lim_{\varepsilon \to 0} \frac{J(\theta + \varepsilon) - J(\theta - \varepsilon)}{2 \varepsilon} \tag{1}$$ However, $\theta$ is not a scalar anymore. It is a dictionary called “parameters”. We implemented a function “dictionary_to_vector()“ for you. It converts the “parameters” dictionary into a vector called “values”, obtained by reshaping all parameters (W1, b1, W2, b2, W3, b3) into vectors and concatenating them. The inverse function is “vector_to_dictionary“ which outputs back the “parameters” dictionary. Figure 2 : dictionary_to_vector() and vector_to_dictionary() You will need these functions in gradient_check_n() We have also converted the “gradients” dictionary into a vector “grad” using gradients_to_vector(). You don’t need to worry about that. Exercise: Implement gradient_check_n(). Instructions: Here is pseudo-code that will help you implement the gradient check. For each i in num_parameters: To compute J_plus[i]: Set $\theta^{+}$ to np.copy(parameters_values) Set $\theta^{+}_i$ to $\theta^{+}_i + \varepsilon$ Calculate $J^{+}_i$ using to forward_propagation_n(x, y, vector_to_dictionary($\theta^{+}$ )). To compute J_minus[i]: do the same thing with $\theta^{-}$ Compute $gradapprox[i] = \frac{J^{+}_i - J^{-}_i}{2 \varepsilon}$ Thus, you get a vector gradapprox, where gradapprox[i] is an approximation of the gradient with respect to parameter_values[i]. You can now compare this gradapprox vector to the gradients vector from backpropagation. Just like for the 1D case (Steps 1’, 2’, 3’), compute:$$ difference = \frac {| grad - gradapprox |_2}{| grad |_2 + | gradapprox |_2 } \tag{3}$$ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# GRADED FUNCTION: gradient_check_ndef gradient_check_n(parameters, gradients, X, Y, epsilon = 1e-7): """ Checks if backward_propagation_n computes correctly the gradient of the cost output by forward_propagation_n Arguments: parameters -- python dictionary containing your parameters "W1", "b1", "W2", "b2", "W3", "b3": grad -- output of backward_propagation_n, contains gradients of the cost with respect to the parameters. x -- input datapoint, of shape (input size, 1) y -- true "label" epsilon -- tiny shift to the input to compute approximated gradient with formula(1) Returns: difference -- difference (2) between the approximated gradient and the backward propagation gradient """ # Set-up variables parameters_values, _ = dictionary_to_vector(parameters) grad = gradients_to_vector(gradients) num_parameters = parameters_values.shape[0] J_plus = np.zeros((num_parameters, 1)) J_minus = np.zeros((num_parameters, 1)) gradapprox = np.zeros((num_parameters, 1)) # Compute gradapprox for i in range(num_parameters): # Compute J_plus[i]. Inputs: "parameters_values, epsilon". Output = "J_plus[i]". # "_" is used because the function you have to outputs two parameters but we only care about the first one ### START CODE HERE ### (approx. 3 lines) thetaplus = np.copy(parameters_values) # Step 1 thetaplus[i][0] = thetaplus[i][0] + epsilon # Step 2 J_plus[i], _ = forward_propagation_n(X, Y, vector_to_dictionary(thetaplus)) # Step 3 ### END CODE HERE ### # Compute J_minus[i]. Inputs: "parameters_values, epsilon". Output = "J_minus[i]". ### START CODE HERE ### (approx. 3 lines) thetaminus = np.copy(parameters_values) # Step 1 thetaminus[i][0] = thetaminus[i][0] - epsilon # Step 2 J_minus[i], _ = forward_propagation_n(X, Y, vector_to_dictionary(thetaminus)) # Step 3 ### END CODE HERE ### # Compute gradapprox[i] ### START CODE HERE ### (approx. 1 line) gradapprox[i] = gradapprox[i] = (J_plus[i] - J_minus[i]) / (2 * epsilon) ### END CODE HERE ### # Compare gradapprox to backward propagation gradients by computing difference. ### START CODE HERE ### (approx. 1 line) numerator = np.linalg.norm(grad - gradapprox, ord = 2) # Step 1' denominator = np.linalg.norm(grad, ord = 2) + np.linalg.norm(gradapprox, ord = 2) # Step 2' difference = numerator / denominator # Step 3' ### END CODE HERE ### if difference &gt; 2e-7: print ("\033[93m" + "There is a mistake in the backward propagation! difference = " + str(difference) + "\033[0m") else: print ("\033[92m" + "Your backward propagation works perfectly fine! difference = " + str(difference) + "\033[0m") return difference 12345X, Y, parameters = gradient_check_n_test_case()cost, cache = forward_propagation_n(X, Y, parameters)gradients = backward_propagation_n(X, Y, cache)difference = gradient_check_n(parameters, gradients, X, Y) [93mThere is a mistake in the backward propagation! difference = 0.285093156781[0m Expected output: There is a mistake in the backward propagation! difference = 0.285093156781 It seems that there were errors in the backward_propagation_n code we gave you! Good that you’ve implemented the gradient check. Go back to backward_propagation and try to find/correct the errors (Hint: check dW2 and db1). Rerun the gradient check when you think you’ve fixed it. Remember you’ll need to re-execute the cell defining backward_propagation_n() if you modify the code. Can you get gradient check to declare your derivative computation correct? Even though this part of the assignment isn’t graded, we strongly urge you to try to find the bug and re-run gradient check until you’re convinced backprop is now correctly implemented. Note Gradient Checking is slow! Approximating the gradient with $\frac{\partial J}{\partial \theta} \approx \frac{J(\theta + \varepsilon) - J(\theta - \varepsilon)}{2 \varepsilon}$ is computationally costly. For this reason, we don’t run gradient checking at every iteration during training. Just a few times to check if the gradient is correct. Gradient Checking, at least as we’ve presented it, doesn’t work with dropout. You would usually run the gradient check algorithm without dropout to make sure your backprop is correct, then add dropout. Congrats, you can be confident that your deep learning model for fraud detection is working correctly! You can even use this to convince your CEO. :) What you should remember from this notebook: Gradient checking verifies closeness between the gradients from backpropagation and the numerical approximation of the gradient (computed using forward propagation). Gradient checking is slow, so we don’t run it in every iteration of training. You would usually run it only to make sure your code is correct, then turn it off and use backprop for the actual learning process.]]></content>
      <tags>
        <tag>Deeplearning.ai</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deeplearning.ai 笔记作业（一）week4]]></title>
    <url>%2F2018%2F05%2F21%2Fdeeplearning-ai-nn-and-dl-week4%2F</url>
    <content type="text"><![CDATA[第一章 神经网络和深度学习 week4 笔记L层深层神经网络如下图就是一个深层神经网络，相比而言，逻辑回归就是一个浅层的神经网络。 L表示神经网络的层数，L=4，n[1]=5，n[2]=5，n[3]=3，n[4]=1 a[L] = activation in Layer La[L] = g[L](z[L])，W[L]= weight for Z[L] 神经网络的前向传播就如上图所示： Input: a[l-1]Output: a[l], z[l]notes: 通过神经网络训练过程可以发现，z[l]在反向传播的过程中也可以利用，所以输出的z[l]以cache(z[l])保存 单层计算：z[l]=W[l]a[l-1]+b[l]a[l]=g[l](z[l]) 矢量化计算：Z[l]=W[l]A[l-1]+b[l]A[l]=g[l](Z[l]) 矢量化时保证矩阵维度正确（重要）通过观察得出：W[l]: (n[l], n[l-1])b[l]: (n[l], 1)dW[l]: (n[l], n[l-1])db[l]: (n[l], 1)Z[l]: (n[l], m)A[l]: (n[l], m)dZ[l]: (n[l], m)dA[l]: (n[l], m) 前向传播与反向传播前向传播图示：反向传播图示： 为什么使用深层表示 以下内容的表达参考自cnblogs 直观理解深层网络。上图所示是一个人脸识别的过程，具体的实现步骤如下： 通过深层神经网络首先会选取一些边缘信息，例如脸形，眼框，总之是一些边框之类的信息(我自己的理解是之所以先找出边缘信息是为了将要观察的事物与周围环境分割开来)，这也就是第一层的作用。 找到边缘信息后，开始放大，将信息聚合在一起。例如找到眼睛轮廓信息后，通过往上一层汇聚从而得到眼睛的信息；同理通过汇聚脸的轮廓信息得到脸颊信息等等 在第二步的基础上将各个局部信息(眼睛、眉毛……)汇聚成一张人脸，最终达到人脸识别的效果。 同样的过程也可以用来表示声音识别过程：一个声音分割成一个一个的片段，然后再选取单个发音（例如C,A,T），然后再组合成单词（CAT），最后在聚合成一个句子或单词。 为什么用深层神经网络而不用浅层神经网络有一个电路原理，就是说由小的网络单元组成的深层电路往往比浅层电路需要更多的元器件。比如X1XOR X2XOR X3XOR…Xn如果是深层网络，只需要O(logn)的数量级，但是如果使用浅层网络的话，就需要遍历所有的情况设置真值表，需要O(2n-1)。转化成神经网络，要达到相同的目的，浅层网络需要比深层网络更多地神经元个数。 构建深层神经网络块前向传播：反向传播：标准流程： 参数与超参数参数：W[l]，b[l]超参数： 学习速率 迭代次数 隐藏层数 神经元个数 激活函数的选择 minibatch size 正则化方法 momentum 所以，对于资深的算法工程师，随着计算资源的不断迭代，适时调整自己的超参数可能会取得更好地结果。 作业课堂的小quiz可以点击下载 Building your Deep Neural Network: Step by StepWelcome to your week 4 assignment (part 1 of 2)! You have previously trained a 2-layer Neural Network (with a single hidden layer). This week, you will build a deep neural network, with as many layers as you want! In this notebook, you will implement all the functions required to build a deep neural network. In the next assignment, you will use these functions to build a deep neural network for image classification. After this assignment you will be able to: Use non-linear units like ReLU to improve your model Build a deeper neural network (with more than 1 hidden layer) Implement an easy-to-use neural network class Notation: Superscript $[l]$ denotes a quantity associated with the $l^&#123;th&#125;$ layer. Example: $a^&#123;[L]&#125;$ is the $L^&#123;th&#125;$ layer activation. $W^&#123;[L]&#125;$ and $b^&#123;[L]&#125;$ are the $L^&#123;th&#125;$ layer parameters. Superscript $(i)$ denotes a quantity associated with the $i^&#123;th&#125;$ example. Example: $x^&#123;(i)&#125;$ is the $i^&#123;th&#125;$ training example. Lowerscript $i$ denotes the $i^&#123;th&#125;$ entry of a vector. Example: $a^&#123;[l]&#125;_i$ denotes the $i^&#123;th&#125;$ entry of the $l^&#123;th&#125;$ layer’s activations). Let’s get started! 1 - PackagesLet’s first import all the packages that you will need during this assignment. numpy is the main package for scientific computing with Python. matplotlib is a library to plot graphs in Python. dnn_utils provides some necessary functions for this notebook. testCases provides some test cases to assess the correctness of your functions np.random.seed(1) is used to keep all the random function calls consistent. It will help us grade your work. Please don’t change the seed. 123456789101112131415import numpy as npimport h5pyimport matplotlib.pyplot as pltfrom testCases_v4 import *from dnn_utils_v2 import sigmoid, sigmoid_backward, relu, relu_backward%matplotlib inlineplt.rcParams['figure.figsize'] = (5.0, 4.0) # set default size of plotsplt.rcParams['image.interpolation'] = 'nearest'plt.rcParams['image.cmap'] = 'gray'%load_ext autoreload%autoreload 2np.random.seed(1) /opt/conda/lib/python3.5/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment. warnings.warn(&apos;Matplotlib is building the font cache using fc-list. This may take a moment.&apos;) /opt/conda/lib/python3.5/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment. warnings.warn(&apos;Matplotlib is building the font cache using fc-list. This may take a moment.&apos;) 2 - Outline of the AssignmentTo build your neural network, you will be implementing several “helper functions”. These helper functions will be used in the next assignment to build a two-layer neural network and an L-layer neural network. Each small helper function you will implement will have detailed instructions that will walk you through the necessary steps. Here is an outline of this assignment, you will: Initialize the parameters for a two-layer network and for an $L$-layer neural network. Implement the forward propagation module (shown in purple in the figure below). Complete the LINEAR part of a layer’s forward propagation step (resulting in $Z^&#123;[l]&#125;$). We give you the ACTIVATION function (relu/sigmoid). Combine the previous two steps into a new [LINEAR-&gt;ACTIVATION] forward function. Stack the [LINEAR-&gt;RELU] forward function L-1 time (for layers 1 through L-1) and add a [LINEAR-&gt;SIGMOID] at the end (for the final layer $L$). This gives you a new L_model_forward function. Compute the loss. Implement the backward propagation module (denoted in red in the figure below). Complete the LINEAR part of a layer’s backward propagation step. We give you the gradient of the ACTIVATE function (relu_backward/sigmoid_backward) Combine the previous two steps into a new [LINEAR-&gt;ACTIVATION] backward function. Stack [LINEAR-&gt;RELU] backward L-1 times and add [LINEAR-&gt;SIGMOID] backward in a new L_model_backward function Finally update the parameters. Figure 1Note that for every forward function, there is a corresponding backward function. That is why at every step of your forward module you will be storing some values in a cache. The cached values are useful for computing gradients. In the backpropagation module you will then use the cache to calculate the gradients. This assignment will show you exactly how to carry out each of these steps.#### 3 - InitializationYou will write two helper functions that will initialize the parameters for your model. The first function will be used to initialize parameters for a two layer model. The second one will generalize this initialization process to $L$ layers.##### 3.1 - 2-layer Neural NetworkExercise: Create and initialize the parameters of the 2-layer neural network.Instructions:- The model’s structure is: LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID.- Use random initialization for the weight matrices. Use np.random.randn(shape)*0.01 with the correct shape.- Use zero initialization for the biases. Use np.zeros(shape).1234567891011121314151617181920212223242526272829303132333435363738# GRADED FUNCTION: initialize_parametersdef initialize_parameters(n_x, n_h, n_y): """ Argument: n_x -- size of the input layer n_h -- size of the hidden layer n_y -- size of the output layer Returns: parameters -- python dictionary containing your parameters: W1 -- weight matrix of shape (n_h, n_x) b1 -- bias vector of shape (n_h, 1) W2 -- weight matrix of shape (n_y, n_h) b2 -- bias vector of shape (n_y, 1) """ np.random.seed(1) ### START CODE HERE ### (≈ 4 lines of code) # random不要用元组, zeros用元组 W1 = np.random.randn(n_h, n_x) * 0.01 b1 = np.zeros((n_h, 1)) W2 = np.random.randn(n_y, n_h) * 0.01 b2 = np.zeros((n_y, 1)) ### END CODE HERE ### assert(W1.shape == (n_h, n_x)) assert(b1.shape == (n_h, 1)) assert(W2.shape == (n_y, n_h)) assert(b2.shape == (n_y, 1)) parameters = &amp;#123;"W1": W1, "b1": b1, "W2": W2, "b2": b2&amp;#125; return parameters12345parameters = initialize_parameters(3,2,1)print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) W1 = [[ 0.01624345 -0.00611756 -0.00528172] [-0.01072969 0.00865408 -0.02301539]] b1 = [[ 0.] [ 0.]] W2 = [[ 0.01744812 -0.00761207]] b2 = [[ 0.]]Expected output: W1 [[ 0.01624345 -0.00611756 -0.00528172] [-0.01072969 0.00865408 -0.02301539]] b1 [[ 0.] [ 0.]] W2 [[ 0.01744812 -0.00761207]] b2 [[ 0.]] ##### 3.2 - L-layer Neural NetworkThe initialization for a deeper L-layer neural network is more complicated because there are many more weight matrices and bias vectors. When completing the initialize_parameters_deep, you should make sure that your dimensions match between each layer. Recall that $n^&#123;[l]&#125;$ is the number of units in layer $l$. Thus for example if the size of our input $X$ is $(12288, 209)$ (with $m=209$ examples) then: Shape of W Shape of b Activation Shape of Activation Layer 1 $(n^&#123;[1]&#125;,12288)$ $(n^&#123;[1]&#125;,1)$ $Z^&#123;[1]&#125; = W^&#123;[1]&#125; X + b^&#123;[1]&#125; $ $(n^&#123;[1]&#125;,209)$ Layer 2 $(n^&#123;[2]&#125;, n^&#123;[1]&#125;)$ $(n^&#123;[2]&#125;,1)$ $Z^&#123;[2]&#125; = W^&#123;[2]&#125; A^&#123;[1]&#125; + b^&#123;[2]&#125;$ $(n^&#123;[2]&#125;, 209)$ $\vdots$ $\vdots$ $\vdots$ $\vdots$ $\vdots$ Layer L-1 $(n^&#123;[L-1]&#125;, n^&#123;[L-2]&#125;)$ $(n^&#123;[L-1]&#125;, 1)$ $Z^&#123;[L-1]&#125; = W^&#123;[L-1]&#125; A^&#123;[L-2]&#125; + b^&#123;[L-1]&#125;$ $(n^&#123;[L-1]&#125;, 209)$ Layer L $(n^&#123;[L]&#125;, n^&#123;[L-1]&#125;)$ $(n^&#123;[L]&#125;, 1)$ $Z^&#123;[L]&#125; = W^&#123;[L]&#125; A^&#123;[L-1]&#125; + b^&#123;[L]&#125;$ $(n^&#123;[L]&#125;, 209)$ Remember that when we compute $W X + b$ in python, it carries out broadcasting. For example, if:$$ W = \begin&#123;bmatrix&#125; j &amp; k &amp; l\\ m &amp; n &amp; o \\ p &amp; q &amp; r\end&#123;bmatrix&#125;\;\;\; X = \begin&#123;bmatrix&#125; a &amp; b &amp; c\\ d &amp; e &amp; f \\ g &amp; h &amp; i\end&#123;bmatrix&#125; \;\;\; b =\begin&#123;bmatrix&#125; s \\ t \\ u\end&#123;bmatrix&#125;\tag&#123;2&#125;$$Then $WX + b$ will be:$$ WX + b = \begin&#123;bmatrix&#125; (ja + kd + lg) + s &amp; (jb + ke + lh) + s &amp; (jc + kf + li)+ s\\ (ma + nd + og) + t &amp; (mb + ne + oh) + t &amp; (mc + nf + oi) + t\\ (pa + qd + rg) + u &amp; (pb + qe + rh) + u &amp; (pc + qf + ri)+ u\end&#123;bmatrix&#125;\tag&#123;3&#125; $$Exercise: Implement initialization for an L-layer Neural Network.Instructions:- The model’s structure is [LINEAR -&gt; RELU] $ \times$ (L-1) -&gt; LINEAR -&gt; SIGMOID. I.e., it has $L-1$ layers using a ReLU activation function followed by an output layer with a sigmoid activation function.- Use random initialization for the weight matrices. Use np.random.randn(shape) * 0.01.- Use zeros initialization for the biases. Use np.zeros(shape).- We will store $n^&#123;[l]&#125;$, the number of units in different layers, in a variable layer_dims. For example, the layer_dims for the “Planar Data classification model” from last week would have been [2,4,1]: There were two inputs, one hidden layer with 4 hidden units, and an output layer with 1 output unit. Thus means W1‘s shape was (4,2), b1 was (4,1), W2 was (1,4) and b2 was (1,1). Now you will generalize this to $L$ layers!- Here is the implementation for $L=1$ (one layer neural network). It should inspire you to implement the general case (L-layer neural network).123if L == 1: parameters["W" + str(L)] = np.random.randn(layer_dims[1], layer_dims[0]) * 0.01 parameters["b" + str(L)] = np.zeros((layer_dims[1], 1))12345678910111213141516171819202122232425262728# GRADED FUNCTION: initialize_parameters_deepdef initialize_parameters_deep(layer_dims): """ Arguments: layer_dims -- python array (list) containing the dimensions of each layer in our network Returns: parameters -- python dictionary containing your parameters "W1", "b1", ..., "WL", "bL": Wl -- weight matrix of shape (layer_dims[l], layer_dims[l-1]) bl -- bias vector of shape (layer_dims[l], 1) """ np.random.seed(3) parameters = &amp;#123;&amp;#125; L = len(layer_dims) # number of layers in the network for l in range(1, L): ### START CODE HERE ### (≈ 2 lines of code) parameters['W' + str(l)] = np.random.randn(layer_dims[l], layer_dims[l-1]) * 0.01 parameters['b' + str(l)] = np.zeros((layer_dims[l], 1)) ### END CODE HERE ### assert(parameters['W' + str(l)].shape == (layer_dims[l], layer_dims[l-1])) assert(parameters['b' + str(l)].shape == (layer_dims[l], 1)) return parameters12345parameters = initialize_parameters_deep([5,4,3])print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) W1 = [[ 0.01788628 0.0043651 0.00096497 -0.01863493 -0.00277388] [-0.00354759 -0.00082741 -0.00627001 -0.00043818 -0.00477218] [-0.01313865 0.00884622 0.00881318 0.01709573 0.00050034] [-0.00404677 -0.0054536 -0.01546477 0.00982367 -0.01101068]] b1 = [[ 0.] [ 0.] [ 0.] [ 0.]] W2 = [[-0.01185047 -0.0020565 0.01486148 0.00236716] [-0.01023785 -0.00712993 0.00625245 -0.00160513] [-0.00768836 -0.00230031 0.00745056 0.01976111]] b2 = [[ 0.] [ 0.] [ 0.]]Expected output: W1 [[ 0.01788628 0.0043651 0.00096497 -0.01863493 -0.00277388] [-0.00354759 -0.00082741 -0.00627001 -0.00043818 -0.00477218] [-0.01313865 0.00884622 0.00881318 0.01709573 0.00050034] [-0.00404677 -0.0054536 -0.01546477 0.00982367 -0.01101068]] b1 [[ 0.] [ 0.] [ 0.] [ 0.]] W2 [[-0.01185047 -0.0020565 0.01486148 0.00236716] [-0.01023785 -0.00712993 0.00625245 -0.00160513] [-0.00768836 -0.00230031 0.00745056 0.01976111]] b2 [[ 0.] [ 0.] [ 0.]] #### 4 - Forward propagation module##### 4.1 - Linear ForwardNow that you have initialized your parameters, you will do the forward propagation module. You will start by implementing some basic functions that you will use later when implementing the model. You will complete three functions in this order:- LINEAR- LINEAR -&gt; ACTIVATION where ACTIVATION will be either ReLU or Sigmoid.- [LINEAR -&gt; RELU] $\times$ (L-1) -&gt; LINEAR -&gt; SIGMOID (whole model)The linear forward module (vectorized over all the examples) computes the following equations:$$Z^&#123;[l]&#125; = W^&#123;[l]&#125;A^&#123;[l-1]&#125; +b^&#123;[l]&#125;\tag&#123;4&#125;$$where $A^&#123;[0]&#125; = X$.Exercise: Build the linear part of forward propagation.Reminder:The mathematical representation of this unit is $Z^&#123;[l]&#125; = W^&#123;[l]&#125;A^&#123;[l-1]&#125; +b^&#123;[l]&#125;$. You may also find np.dot() useful. If your dimensions don’t match, printing W.shape may help.123456789101112131415161718192021222324# GRADED FUNCTION: linear_forwarddef linear_forward(A, W, b): """ Implement the linear part of a layer's forward propagation. Arguments: A -- activations from previous layer (or input data): (size of previous layer, number of examples) W -- weights matrix: numpy array of shape (size of current layer, size of previous layer) b -- bias vector, numpy array of shape (size of the current layer, 1) Returns: Z -- the input of the activation function, also called pre-activation parameter cache -- a python dictionary containing "A", "W" and "b" ; stored for computing the backward pass efficiently """ ### START CODE HERE ### (≈ 1 line of code) Z = np.dot(W, A) + b ### END CODE HERE ### assert(Z.shape == (W.shape[0], A.shape[1])) cache = (A, W, b) return Z, cache1234A, W, b = linear_forward_test_case()Z, linear_cache = linear_forward(A, W, b)print("Z = " + str(Z)) Z = [[ 3.26295337 -1.23429987]]Expected output: Z [[ 3.26295337 -1.23429987]] ##### 4.2 - Linear-Activation ForwardIn this notebook, you will use two activation functions:- Sigmoid: $\sigma(Z) = \sigma(W A + b) = \frac&#123;1&#125;&#123; 1 + e^&#123;-(W A + b)&#125;&#125;$. We have provided you with the sigmoid function. This function returns two items: the activation value “a“ and a “cache“ that contains “Z“ (it’s what we will feed in to the corresponding backward function). To use it you could just call:1A, activation_cache = sigmoid(Z)- ReLU: The mathematical formula for ReLu is $A = RELU(Z) = max(0, Z)$. We have provided you with the relu function. This function returns two items: the activation value “A“ and a “cache“ that contains “Z“ (it’s what we will feed in to the corresponding backward function). To use it you could just call:1A, activation_cache = relu(Z)For more convenience, you are going to group two functions (Linear and Activation) into one function (LINEAR-&gt;ACTIVATION). Hence, you will implement a function that does the LINEAR forward step followed by an ACTIVATION forward step.Exercise: Implement the forward propagation of the LINEAR-&gt;ACTIVATION layer. Mathematical relation is: $A^&#123;[l]&#125; = g(Z^&#123;[l]&#125;) = g(W^&#123;[l]&#125;A^&#123;[l-1]&#125; +b^&#123;[l]&#125;)$ where the activation “g” can be sigmoid() or relu(). Use linear_forward() and the correct activation function.123456789101112131415161718192021222324252627282930313233343536# GRADED FUNCTION: linear_activation_forwarddef linear_activation_forward(A_prev, W, b, activation): """ Implement the forward propagation for the LINEAR-&gt;ACTIVATION layer Arguments: A_prev -- activations from previous layer (or input data): (size of previous layer, number of examples) W -- weights matrix: numpy array of shape (size of current layer, size of previous layer) b -- bias vector, numpy array of shape (size of the current layer, 1) activation -- the activation to be used in this layer, stored as a text string: "sigmoid" or "relu" Returns: A -- the output of the activation function, also called the post-activation value cache -- a python dictionary containing "linear_cache" and "activation_cache"; stored for computing the backward pass efficiently """ if activation == "sigmoid": # Inputs: "A_prev, W, b". Outputs: "A, activation_cache". ### START CODE HERE ### (≈ 2 lines of code) Z, linear_cache = linear_forward(A_prev, W, b) A, activation_cache = sigmoid(Z) ### END CODE HERE ### elif activation == "relu": # Inputs: "A_prev, W, b". Outputs: "A, activation_cache". ### START CODE HERE ### (≈ 2 lines of code) Z, linear_cache = linear_forward(A_prev, W, b) A, activation_cache = relu(Z) ### END CODE HERE ### assert (A.shape == (W.shape[0], A_prev.shape[1])) cache = (linear_cache, activation_cache) return A, cache1234567A_prev, W, b = linear_activation_forward_test_case()A, linear_activation_cache = linear_activation_forward(A_prev, W, b, activation = "sigmoid")print("With sigmoid: A = " + str(A))A, linear_activation_cache = linear_activation_forward(A_prev, W, b, activation = "relu")print("With ReLU: A = " + str(A)) With sigmoid: A = [[ 0.96890023 0.11013289]] With ReLU: A = [[ 3.43896131 0. ]]Expected output: With sigmoid: A [[ 0.96890023 0.11013289]] With ReLU: A [[ 3.43896131 0. ]] Note: In deep learning, the “[LINEAR-&gt;ACTIVATION]” computation is counted as a single layer in the neural network, not two layers.##### d) L-Layer ModelFor even more convenience when implementing the $L$-layer Neural Net, you will need a function that replicates the previous one (linear_activation_forward with RELU) $L-1$ times, then follows that with one linear_activation_forward with SIGMOID. Figure 2 : [LINEAR -&gt; RELU] $\times$ (L-1) -&gt; LINEAR -&gt; SIGMOID modelExercise: Implement the forward propagation of the above model.Instruction: In the code below, the variable AL will denote $A^&#123;[L]&#125; = \sigma(Z^&#123;[L]&#125;) = \sigma(W^&#123;[L]&#125; A^&#123;[L-1]&#125; + b^&#123;[L]&#125;)$. (This is sometimes also called Yhat, i.e., this is $\hat&#123;Y&#125;$.)Tips:- Use the functions you had previously written- Use a for loop to replicate [LINEAR-&gt;RELU] (L-1) times- Don’t forget to keep track of the caches in the “caches” list. To add a new value c to a list, you can use list.append(c).12345678910111213141516171819202122232425262728293031323334353637# GRADED FUNCTION: L_model_forwarddef L_model_forward(X, parameters): """ Implement forward propagation for the [LINEAR-&gt;RELU]*(L-1)-&gt;LINEAR-&gt;SIGMOID computation Arguments: X -- data, numpy array of shape (input size, number of examples) parameters -- output of initialize_parameters_deep() Returns: AL -- last post-activation value caches -- list of caches containing: every cache of linear_activation_forward() (there are L-1 of them, indexed from 0 to L-1) """ caches = [] A = X L = len(parameters) // 2 # number of layers in the neural network # Implement [LINEAR -&gt; RELU]*(L-1). Add "cache" to the "caches" list. for l in range(1, L): A_prev = A ### START CODE HERE ### (≈ 2 lines of code) A, cache = linear_activation_forward(A_prev, parameters["W" + str(l)], parameters["b" + str(l)], "relu") caches.append(cache) ### END CODE HERE ### # Implement LINEAR -&gt; SIGMOID. Add "cache" to the "caches" list. ### START CODE HERE ### (≈ 2 lines of code) AL, cache = linear_activation_forward(A, parameters["W" + str(L)], parameters["b" + str(L)], "sigmoid") caches.append(cache) ### END CODE HERE ### assert(AL.shape == (1,X.shape[1])) return AL, caches1234X, parameters = L_model_forward_test_case_2hidden()AL, caches = L_model_forward(X, parameters)print("AL = " + str(AL))print("Length of caches list = " + str(len(caches))) AL = [[ 0.03921668 0.70498921 0.19734387 0.04728177]] Length of caches list = 3 AL [[ 0.03921668 0.70498921 0.19734387 0.04728177]] Length of caches list 3 Great! Now you have a full forward propagation that takes the input X and outputs a row vector $A^&#123;[L]&#125;$ containing your predictions. It also records all intermediate values in “caches”. Using $A^&#123;[L]&#125;$, you can compute the cost of your predictions.#### 5 - Cost functionNow you will implement forward and backward propagation. You need to compute the cost, because you want to check if your model is actually learning.Exercise: Compute the cross-entropy cost $J$, using the following formula: $$-\frac&#123;1&#125;&#123;m&#125; \sum\limits_&#123;i = 1&#125;^&#123;m&#125; (y^&#123;(i)&#125;\log\left(a^&#123;[L] (i)&#125;\right) + (1-y^&#123;(i)&#125;)\log\left(1- a^&#123;L&#125;\right)) \tag&#123;7&#125;$$12345678910111213141516171819202122232425# GRADED FUNCTION: compute_costdef compute_cost(AL, Y): """ Implement the cost function defined by equation (7). Arguments: AL -- probability vector corresponding to your label predictions, shape (1, number of examples) Y -- true "label" vector (for example: containing 0 if non-cat, 1 if cat), shape (1, number of examples) Returns: cost -- cross-entropy cost """ m = Y.shape[1] # Compute loss from aL and y. ### START CODE HERE ### (≈ 1 lines of code) cost = np.sum(np.multiply(np.log(AL),Y) + np.multiply(np.log(1 - AL), 1 - Y)) / (-m) ### END CODE HERE ### cost = np.squeeze(cost) # To make sure your cost's shape is what we expect (e.g. this turns [[17]] into 17). assert(cost.shape == ()) return cost123Y, AL = compute_cost_test_case()print("cost = " + str(compute_cost(AL, Y))) cost = 0.414931599615Expected Output: cost 0.41493159961539694 #### 6 - Backward propagation moduleJust like with forward propagation, you will implement helper functions for backpropagation. Remember that back propagation is used to calculate the gradient of the loss function with respect to the parameters.Reminder: Figure 3 : Forward and Backward propagation for LINEAR-&gt;RELU-&gt;LINEAR-&gt;SIGMOID The purple blocks represent the forward propagation, and the red blocks represent the backward propagation. Now, similar to forward propagation, you are going to build the backward propagation in three steps: LINEAR backward LINEAR -&gt; ACTIVATION backward where ACTIVATION computes the derivative of either the ReLU or sigmoid activation [LINEAR -&gt; RELU] $\times$ (L-1) -&gt; LINEAR -&gt; SIGMOID backward (whole model) 6.1 - Linear backwardFor layer $l$, the linear part is: $Z^&#123;[l]&#125; = W^&#123;[l]&#125; A^&#123;[l-1]&#125; + b^&#123;[l]&#125;$ (followed by an activation). Suppose you have already calculated the derivative $dZ^&#123;[l]&#125; = \frac&#123;\partial \mathcal&#123;L&#125; &#125;&#123;\partial Z^&#123;[l]&#125;&#125;$. You want to get $(dW^&#123;[l]&#125;, db^&#123;[l]&#125; dA^&#123;[l-1]&#125;)$. Figure 4 The three outputs $(dW^&#123;[l]&#125;, db^&#123;[l]&#125;, dA^&#123;[l]&#125;)$ are computed using the input $dZ^&#123;[l]&#125;$.Here are the formulas you need:$$ dW^&#123;[l]&#125; = \frac&#123;\partial \mathcal&#123;L&#125; &#125;&#123;\partial W^&#123;[l]&#125;&#125; = \frac&#123;1&#125;&#123;m&#125; dZ^&#123;[l]&#125; A^&#123;[l-1] T&#125; \tag&#123;8&#125;$$$$ db^&#123;[l]&#125; = \frac&#123;\partial \mathcal&#123;L&#125; &#125;&#123;\partial b^&#123;[l]&#125;&#125; = \frac&#123;1&#125;&#123;m&#125; \sum_&#123;i = 1&#125;^&#123;m&#125; dZ^&#123;l&#125;\tag&#123;9&#125;$$$$ dA^&#123;[l-1]&#125; = \frac&#123;\partial \mathcal&#123;L&#125; &#125;&#123;\partial A^&#123;[l-1]&#125;&#125; = W^&#123;[l] T&#125; dZ^&#123;[l]&#125; \tag&#123;10&#125;$$ Exercise: Use the 3 formulas above to implement linear_backward(). 1234567891011121314151617181920212223242526272829# GRADED FUNCTION: linear_backwarddef linear_backward(dZ, cache): """ Implement the linear portion of backward propagation for a single layer (layer l) Arguments: dZ -- Gradient of the cost with respect to the linear output (of current layer l) cache -- tuple of values (A_prev, W, b) coming from the forward propagation in the current layer Returns: dA_prev -- Gradient of the cost with respect to the activation (of the previous layer l-1), same shape as A_prev dW -- Gradient of the cost with respect to W (current layer l), same shape as W db -- Gradient of the cost with respect to b (current layer l), same shape as b """ A_prev, W, b = cache m = A_prev.shape[1] ### START CODE HERE ### (≈ 3 lines of code) dW = np.dot(dZ, A_prev.T) / m db = np.sum(dZ, axis=1, keepdims=True) / m dA_prev = np.dot(W.T, dZ) ### END CODE HERE ### assert (dA_prev.shape == A_prev.shape) assert (dW.shape == W.shape) assert (db.shape == b.shape) return dA_prev, dW, db 1234567# Set up some test inputsdZ, linear_cache = linear_backward_test_case()dA_prev, dW, db = linear_backward(dZ, linear_cache)print ("dA_prev = "+ str(dA_prev))print ("dW = " + str(dW))print ("db = " + str(db)) dA_prev = [[ 0.51822968 -0.19517421] [-0.40506361 0.15255393] [ 2.37496825 -0.89445391]] dW = [[-0.10076895 1.40685096 1.64992505]] db = [[ 0.50629448]] Expected Output: dA_prev [[ 0.51822968 -0.19517421] [-0.40506361 0.15255393] [ 2.37496825 -0.89445391]] dW [[-0.10076895 1.40685096 1.64992505]] db [[ 0.50629448]] 6.2 - Linear-Activation backwardNext, you will create a function that merges the two helper functions: linear_backward and the backward step for the activation linear_activation_backward. To help you implement linear_activation_backward, we provided two backward functions: sigmoid_backward: Implements the backward propagation for SIGMOID unit. You can call it as follows: 1dZ = sigmoid_backward(dA, activation_cache) relu_backward: Implements the backward propagation for RELU unit. You can call it as follows: 1dZ = relu_backward(dA, activation_cache) If $g(.)$ is the activation function,sigmoid_backward and relu_backward compute $$dZ^&#123;[l]&#125; = dA^&#123;[l]&#125; * g’(Z^&#123;[l]&#125;) \tag&#123;11&#125;$$. Exercise: Implement the backpropagation for the LINEAR-&gt;ACTIVATION layer. 12345678910111213141516171819202122232425262728293031# GRADED FUNCTION: linear_activation_backwarddef linear_activation_backward(dA, cache, activation): """ Implement the backward propagation for the LINEAR-&gt;ACTIVATION layer. Arguments: dA -- post-activation gradient for current layer l cache -- tuple of values (linear_cache, activation_cache) we store for computing backward propagation efficiently activation -- the activation to be used in this layer, stored as a text string: "sigmoid" or "relu" Returns: dA_prev -- Gradient of the cost with respect to the activation (of the previous layer l-1), same shape as A_prev dW -- Gradient of the cost with respect to W (current layer l), same shape as W db -- Gradient of the cost with respect to b (current layer l), same shape as b """ linear_cache, activation_cache = cache if activation == "relu": ### START CODE HERE ### (≈ 2 lines of code) dZ = relu_backward(dA, activation_cache) dA_prev, dW, db = linear_backward(dZ, linear_cache) ### END CODE HERE ### elif activation == "sigmoid": ### START CODE HERE ### (≈ 2 lines of code) dZ = sigmoid_backward(dA, activation_cache) dA_prev, dW, db = linear_backward(dZ, linear_cache) ### END CODE HERE ### return dA_prev, dW, db 12345678910111213dAL, linear_activation_cache = linear_activation_backward_test_case()dA_prev, dW, db = linear_activation_backward(dAL, linear_activation_cache, activation = "sigmoid")print ("sigmoid:")print ("dA_prev = "+ str(dA_prev))print ("dW = " + str(dW))print ("db = " + str(db) + "\n")dA_prev, dW, db = linear_activation_backward(dAL, linear_activation_cache, activation = "relu")print ("relu:")print ("dA_prev = "+ str(dA_prev))print ("dW = " + str(dW))print ("db = " + str(db)) sigmoid: dA_prev = [[ 0.11017994 0.01105339] [ 0.09466817 0.00949723] [-0.05743092 -0.00576154]] dW = [[ 0.10266786 0.09778551 -0.01968084]] db = [[-0.05729622]] relu: dA_prev = [[ 0.44090989 0. ] [ 0.37883606 0. ] [-0.2298228 0. ]] dW = [[ 0.44513824 0.37371418 -0.10478989]] db = [[-0.20837892]] Expected output with sigmoid: dA_prev [[ 0.11017994 0.01105339] [ 0.09466817 0.00949723] [-0.05743092 -0.00576154]] dW [[ 0.10266786 0.09778551 -0.01968084]] db [[-0.05729622]] Expected output with relu: dA_prev [[ 0.44090989 0. ] [ 0.37883606 0. ] [-0.2298228 0. ]] dW [[ 0.44513824 0.37371418 -0.10478989]] db [[-0.20837892]] 6.3 - L-Model BackwardNow you will implement the backward function for the whole network. Recall that when you implemented the L_model_forward function, at each iteration, you stored a cache which contains (X,W,b, and z). In the back propagation module, you will use those variables to compute the gradients. Therefore, in the L_model_backward function, you will iterate through all the hidden layers backward, starting from layer $L$. On each step, you will use the cached values for layer $l$ to backpropagate through layer $l$. Figure 5 below shows the backward pass. Figure 5 : Backward pass Initializing backpropagation:To backpropagate through this network, we know that the output is,$A^&#123;[L]&#125; = \sigma(Z^&#123;[L]&#125;)$. Your code thus needs to compute dAL $= \frac&#123;\partial \mathcal&#123;L&#125;&#125;&#123;\partial A^&#123;[L]&#125;&#125;$.To do so, use this formula (derived using calculus which you don’t need in-depth knowledge of):1dAL = - (np.divide(Y, AL) - np.divide(1 - Y, 1 - AL)) # derivative of cost with respect to AL You can then use this post-activation gradient dAL to keep going backward. As seen in Figure 5, you can now feed in dAL into the LINEAR-&gt;SIGMOID backward function you implemented (which will use the cached values stored by the L_model_forward function). After that, you will have to use a for loop to iterate through all the other layers using the LINEAR-&gt;RELU backward function. You should store each dA, dW, and db in the grads dictionary. To do so, use this formula : $$grads[“dW” + str(l)] = dW^&#123;[l]&#125;\tag&#123;15&#125; $$ For example, for $l=3$ this would store $dW^&#123;[l]&#125;$ in grads[&quot;dW3&quot;]. Exercise: Implement backpropagation for the [LINEAR-&gt;RELU] $\times$ (L-1) -&gt; LINEAR -&gt; SIGMOID model. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# GRADED FUNCTION: L_model_backwarddef L_model_backward(AL, Y, caches): """ Implement the backward propagation for the [LINEAR-&gt;RELU] * (L-1) -&gt; LINEAR -&gt; SIGMOID group Arguments: AL -- probability vector, output of the forward propagation (L_model_forward()) Y -- true "label" vector (containing 0 if non-cat, 1 if cat) caches -- list of caches containing: every cache of linear_activation_forward() with "relu" (it's caches[l], for l in range(L-1) i.e l = 0...L-2) the cache of linear_activation_forward() with "sigmoid" (it's caches[L-1]) Returns: grads -- A dictionary with the gradients grads["dA" + str(l)] = ... grads["dW" + str(l)] = ... grads["db" + str(l)] = ... """ grads = &amp;#123;&amp;#125; L = len(caches) # the number of layers m = AL.shape[1] Y = Y.reshape(AL.shape) # after this line, Y is the same shape as AL # Initializing the backpropagation ### START CODE HERE ### (1 line of code) dAL = -(np.divide(Y, AL) - np.divide((1-Y), (1-AL))) ### END CODE HERE ### # Lth layer (SIGMOID -&gt; LINEAR) gradients. Inputs: "dAL, current_cache". Outputs: "grads["dAL-1"], grads["dWL"], grads["dbL"] ### START CODE HERE ### (approx. 2 lines) current_cache = caches[L - 1] grads["dA" + str(L-1)], grads["dW" + str(L)], grads["db" + str(L)] = linear_activation_backward(dAL, current_cache, "sigmoid") ### END CODE HERE ### # Loop from l=L-2 to l=0 for l in reversed(range(L-1)): # lth layer: (RELU -&gt; LINEAR) gradients. # Inputs: "grads["dA" + str(l + 1)], current_cache". Outputs: "grads["dA" + str(l)] , grads["dW" + str(l + 1)] , grads["db" + str(l + 1)] ### START CODE HERE ### (approx. 5 lines) current_cache = caches[l] dA_prev_temp, dW_temp, db_temp = linear_activation_backward(grads["dA" + str(l + 1)], current_cache, "relu") grads["dA" + str(l)] = dA_prev_temp grads["dW" + str(l + 1)] = dW_temp grads["db" + str(l + 1)] = db_temp ### END CODE HERE ### return grads 123AL, Y_assess, caches = L_model_backward_test_case()grads = L_model_backward(AL, Y_assess, caches)print_grads(grads) dW1 = [[ 0.41010002 0.07807203 0.13798444 0.10502167] [ 0. 0. 0. 0. ] [ 0.05283652 0.01005865 0.01777766 0.0135308 ]] db1 = [[-0.22007063] [ 0. ] [-0.02835349]] dA1 = [[ 0.12913162 -0.44014127] [-0.14175655 0.48317296] [ 0.01663708 -0.05670698]] Expected Output dW1 [[ 0.41010002 0.07807203 0.13798444 0.10502167] [ 0. 0. 0. 0. ] [ 0.05283652 0.01005865 0.01777766 0.0135308 ]] db1 [[-0.22007063] [ 0. ] [-0.02835349]] dA1 [[ 0.12913162 -0.44014127] [-0.14175655 0.48317296] [ 0.01663708 -0.05670698]] 6.4 - Update ParametersIn this section you will update the parameters of the model, using gradient descent: $$ W^&#123;[l]&#125; = W^&#123;[l]&#125; - \alpha \text&#123; &#125; dW^&#123;[l]&#125; \tag&#123;16&#125;$$$$ b^&#123;[l]&#125; = b^&#123;[l]&#125; - \alpha \text&#123; &#125; db^&#123;[l]&#125; \tag&#123;17&#125;$$ where $\alpha$ is the learning rate. After computing the updated parameters, store them in the parameters dictionary. Exercise: Implement update_parameters() to update your parameters using gradient descent. Instructions:Update parameters using gradient descent on every $W^&#123;[l]&#125;$ and $b^&#123;[l]&#125;$ for $l = 1, 2, …, L$. 12345678910111213141516171819202122232425# GRADED FUNCTION: update_parametersdef update_parameters(parameters, grads, learning_rate): """ Update parameters using gradient descent Arguments: parameters -- python dictionary containing your parameters grads -- python dictionary containing your gradients, output of L_model_backward Returns: parameters -- python dictionary containing your updated parameters parameters["W" + str(l)] = ... parameters["b" + str(l)] = ... """ L = len(parameters) // 2 # number of layers in the neural network # Update rule for each parameter. Use a for loop. ### START CODE HERE ### (≈ 3 lines of code) for l in range(L): parameters["W" + str(l+1)] = parameters['W' + str(l + 1)] - learning_rate * grads["dW" + str(l + 1)] parameters["b" + str(l+1)] = parameters['b' + str(l + 1)] - learning_rate * grads["db" + str(l + 1)] ### END CODE HERE ### return parameters 1234567parameters, grads = update_parameters_test_case()parameters = update_parameters(parameters, grads, 0.1)print ("W1 = "+ str(parameters["W1"]))print ("b1 = "+ str(parameters["b1"]))print ("W2 = "+ str(parameters["W2"]))print ("b2 = "+ str(parameters["b2"])) W1 = [[-0.59562069 -0.09991781 -2.14584584 1.82662008] [-1.76569676 -0.80627147 0.51115557 -1.18258802] [-1.0535704 -0.86128581 0.68284052 2.20374577]] b1 = [[-0.04659241] [-1.28888275] [ 0.53405496]] W2 = [[-0.55569196 0.0354055 1.32964895]] b2 = [[-0.84610769]] Expected Output: W1 [[-0.59562069 -0.09991781 -2.14584584 1.82662008] [-1.76569676 -0.80627147 0.51115557 -1.18258802] [-1.0535704 -0.86128581 0.68284052 2.20374577]] b1 [[-0.04659241] [-1.28888275] [ 0.53405496]] W2 [[-0.55569196 0.0354055 1.32964895]] b2 [[-0.84610769]] 7 - ConclusionCongrats on implementing all the functions required for building a deep neural network! We know it was a long assignment but going forward it will only get better. The next part of the assignment is easier. In the next assignment you will put all these together to build two models: A two-layer neural network An L-layer neural network You will in fact use these models to classify cat vs non-cat images! Deep Neural Network for Image Classification: ApplicationWhen you finish this, you will have finished the last programming assignment of Week 4, and also the last programming assignment of this course! You will use use the functions you’d implemented in the previous assignment to build a deep network, and apply it to cat vs non-cat classification. Hopefully, you will see an improvement in accuracy relative to your previous logistic regression implementation. After this assignment you will be able to: Build and apply a deep neural network to supervised learning. Let’s get started! 1 - PackagesLet’s first import all the packages that you will need during this assignment. numpy is the fundamental package for scientific computing with Python. matplotlib is a library to plot graphs in Python. h5py is a common package to interact with a dataset that is stored on an H5 file. PIL and scipy are used here to test your model with your own picture at the end. dnn_app_utils provides the functions implemented in the “Building your Deep Neural Network: Step by Step” assignment to this notebook. np.random.seed(1) is used to keep all the random function calls consistent. It will help us grade your work. 123456789101112131415161718import timeimport numpy as npimport h5pyimport matplotlib.pyplot as pltimport scipyfrom PIL import Imagefrom scipy import ndimagefrom dnn_app_utils_v3 import *%matplotlib inlineplt.rcParams['figure.figsize'] = (5.0, 4.0) # set default size of plotsplt.rcParams['image.interpolation'] = 'nearest'plt.rcParams['image.cmap'] = 'gray'%load_ext autoreload%autoreload 2np.random.seed(1) /opt/conda/lib/python3.5/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment. warnings.warn(&apos;Matplotlib is building the font cache using fc-list. This may take a moment.&apos;) /opt/conda/lib/python3.5/site-packages/matplotlib/font_manager.py:273: UserWarning: Matplotlib is building the font cache using fc-list. This may take a moment. warnings.warn(&apos;Matplotlib is building the font cache using fc-list. This may take a moment.&apos;) 2 - DatasetYou will use the same “Cat vs non-Cat” dataset as in “Logistic Regression as a Neural Network” (Assignment 2). The model you had built had 70% test accuracy on classifying cats vs non-cats images. Hopefully, your new model will perform a better! Problem Statement: You are given a dataset (“data.h5”) containing: - a training set of m_train images labelled as cat (1) or non-cat (0) - a test set of m_test images labelled as cat and non-cat - each image is of shape (num_px, num_px, 3) where 3 is for the 3 channels (RGB). Let’s get more familiar with the dataset. Load the data by running the cell below. 1train_x_orig, train_y, test_x_orig, test_y, classes = load_data() The following code will show you an image in the dataset. Feel free to change the index and re-run the cell multiple times to see other images. 1234# Example of a pictureindex = 10plt.imshow(train_x_orig[index])print ("y = " + str(train_y[0,index]) + ". It's a " + classes[train_y[0,index]].decode("utf-8") + " picture.") y = 0. It&apos;s a non-cat picture. 123456789101112# Explore your dataset m_train = train_x_orig.shape[0]num_px = train_x_orig.shape[1]m_test = test_x_orig.shape[0]print ("Number of training examples: " + str(m_train))print ("Number of testing examples: " + str(m_test))print ("Each image is of size: (" + str(num_px) + ", " + str(num_px) + ", 3)")print ("train_x_orig shape: " + str(train_x_orig.shape))print ("train_y shape: " + str(train_y.shape))print ("test_x_orig shape: " + str(test_x_orig.shape))print ("test_y shape: " + str(test_y.shape)) Number of training examples: 209 Number of testing examples: 50 Each image is of size: (64, 64, 3) train_x_orig shape: (209, 64, 64, 3) train_y shape: (1, 209) test_x_orig shape: (50, 64, 64, 3) test_y shape: (1, 50) As usual, you reshape and standardize the images before feeding them to the network. The code is given in the cell below. Figure 1: Image to vector conversion. 12345678910# Reshape the training and test examples train_x_flatten = train_x_orig.reshape(train_x_orig.shape[0], -1).T # The "-1" makes reshape flatten the remaining dimensionstest_x_flatten = test_x_orig.reshape(test_x_orig.shape[0], -1).T# Standardize data to have feature values between 0 and 1.train_x = train_x_flatten/255.test_x = test_x_flatten/255.print ("train_x's shape: " + str(train_x.shape))print ("test_x's shape: " + str(test_x.shape)) train_x&apos;s shape: (12288, 209) test_x&apos;s shape: (12288, 50) $12,288$ equals $64 \times 64 \times 3$ which is the size of one reshaped image vector. 3 - Architecture of your modelNow that you are familiar with the dataset, it is time to build a deep neural network to distinguish cat images from non-cat images. You will build two different models: A 2-layer neural network An L-layer deep neural network You will then compare the performance of these models, and also try out different values for $L$. Let’s look at the two architectures. 3.1 - 2-layer neural network Figure 2: 2-layer neural network. The model can be summarized as: INPUT -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID -&gt; OUTPUT. Detailed Architecture of figure 2: The input is a (64,64,3) image which is flattened to a vector of size $(12288,1)$. The corresponding vector: $[x_0,x_1,…,x_&#123;12287&#125;]^T$ is then multiplied by the weight matrix $W^&#123;[1]&#125;$ of size $(n^&#123;[1]&#125;, 12288)$. You then add a bias term and take its relu to get the following vector: $[a_0^&#123;[1]&#125;, a_1^&#123;[1]&#125;,…, a_&#123;n^&#123;[1]&#125;-1&#125;^&#123;[1]&#125;]^T$. You then repeat the same process. You multiply the resulting vector by $W^&#123;[2]&#125;$ and add your intercept (bias). Finally, you take the sigmoid of the result. If it is greater than 0.5, you classify it to be a cat. 3.2 - L-layer deep neural networkIt is hard to represent an L-layer deep neural network with the above representation. However, here is a simplified network representation: Figure 3: L-layer neural network. The model can be summarized as: [LINEAR -&gt; RELU] $\times$ (L-1) -&gt; LINEAR -&gt; SIGMOID Detailed Architecture of figure 3: The input is a (64,64,3) image which is flattened to a vector of size (12288,1). The corresponding vector: $[x_0,x_1,…,x_&#123;12287&#125;]^T$ is then multiplied by the weight matrix $W^&#123;[1]&#125;$ and then you add the intercept $b^&#123;[1]&#125;$. The result is called the linear unit. Next, you take the relu of the linear unit. This process could be repeated several times for each $(W^&#123;[l]&#125;, b^&#123;[l]&#125;)$ depending on the model architecture. Finally, you take the sigmoid of the final linear unit. If it is greater than 0.5, you classify it to be a cat. 3.3 - General methodologyAs usual you will follow the Deep Learning methodology to build the model: 1. Initialize parameters / Define hyperparameters 2. Loop for num_iterations: a. Forward propagation b. Compute cost function c. Backward propagation d. Update parameters (using parameters, and grads from backprop) 4. Use trained parameters to predict labels Let’s now implement those two models! 4 - Two-layer neural networkQuestion: Use the helper functions you have implemented in the previous assignment to build a 2-layer neural network with the following structure: LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID. The functions you may need and their inputs are:123456789101112131415def initialize_parameters(n_x, n_h, n_y): ... return parameters def linear_activation_forward(A_prev, W, b, activation): ... return A, cachedef compute_cost(AL, Y): ... return costdef linear_activation_backward(dA, cache, activation): ... return dA_prev, dW, dbdef update_parameters(parameters, grads, learning_rate): ... return parameters 12345### CONSTANTS DEFINING THE MODEL ####n_x = 12288 # num_px * num_px * 3n_h = 7n_y = 1layers_dims = (n_x, n_h, n_y) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# GRADED FUNCTION: two_layer_modeldef two_layer_model(X, Y, layers_dims, learning_rate = 0.0075, num_iterations = 3000, print_cost=False): """ Implements a two-layer neural network: LINEAR-&gt;RELU-&gt;LINEAR-&gt;SIGMOID. Arguments: X -- input data, of shape (n_x, number of examples) Y -- true "label" vector (containing 0 if cat, 1 if non-cat), of shape (1, number of examples) layers_dims -- dimensions of the layers (n_x, n_h, n_y) num_iterations -- number of iterations of the optimization loop learning_rate -- learning rate of the gradient descent update rule print_cost -- If set to True, this will print the cost every 100 iterations Returns: parameters -- a dictionary containing W1, W2, b1, and b2 """ np.random.seed(1) grads = &amp;#123;&amp;#125; costs = [] # to keep track of the cost m = X.shape[1] # number of examples (n_x, n_h, n_y) = layers_dims # Initialize parameters dictionary, by calling one of the functions you'd previously implemented ### START CODE HERE ### (≈ 1 line of code) parameters = initialize_parameters(n_x, n_h, n_y) ### END CODE HERE ### # Get W1, b1, W2 and b2 from the dictionary parameters. W1 = parameters["W1"] b1 = parameters["b1"] W2 = parameters["W2"] b2 = parameters["b2"] # Loop (gradient descent) for i in range(0, num_iterations): # Forward propagation: LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID. Inputs: "X, W1, b1, W2, b2". Output: "A1, cache1, A2, cache2". ### START CODE HERE ### (≈ 2 lines of code) A1, cache1 = linear_activation_forward(X, W1, b1, "relu") A2, cache2 = linear_activation_forward(A1, W2, b2, "sigmoid") ### END CODE HERE ### # Compute cost ### START CODE HERE ### (≈ 1 line of code) cost = compute_cost(A2, Y) ### END CODE HERE ### # Initializing backward propagation dA2 = - (np.divide(Y, A2) - np.divide(1 - Y, 1 - A2)) # Backward propagation. Inputs: "dA2, cache2, cache1". Outputs: "dA1, dW2, db2; also dA0 (not used), dW1, db1". ### START CODE HERE ### (≈ 2 lines of code) dA1, dW2, db2 = linear_activation_backward(dA2, cache2, "sigmoid") dA0, dW1, db1 = linear_activation_backward(dA1, cache1, "relu") ### END CODE HERE ### # Set grads['dWl'] to dW1, grads['db1'] to db1, grads['dW2'] to dW2, grads['db2'] to db2 grads['dW1'] = dW1 grads['db1'] = db1 grads['dW2'] = dW2 grads['db2'] = db2 # Update parameters. ### START CODE HERE ### (approx. 1 line of code) parameters = update_parameters(parameters, grads, learning_rate) ### END CODE HERE ### # Retrieve W1, b1, W2, b2 from parameters W1 = parameters["W1"] b1 = parameters["b1"] W2 = parameters["W2"] b2 = parameters["b2"] # Print the cost every 100 training example if print_cost and i % 100 == 0: print("Cost after iteration &amp;#123;&amp;#125;: &amp;#123;&amp;#125;".format(i, np.squeeze(cost))) if print_cost and i % 100 == 0: costs.append(cost) # plot the cost plt.plot(np.squeeze(costs)) plt.ylabel('cost') plt.xlabel('iterations (per tens)') plt.title("Learning rate =" + str(learning_rate)) plt.show() return parameters Run the cell below to train your parameters. See if your model runs. The cost should be decreasing. It may take up to 5 minutes to run 2500 iterations. Check if the “Cost after iteration 0” matches the expected output below, if not click on the square (⬛) on the upper bar of the notebook to stop the cell and try to find your error. 1parameters = two_layer_model(train_x, train_y, layers_dims = (n_x, n_h, n_y), num_iterations = 2500, print_cost=True) Cost after iteration 0: 0.693049735659989 Cost after iteration 100: 0.6464320953428849 Cost after iteration 200: 0.6325140647912678 Cost after iteration 300: 0.6015024920354665 Cost after iteration 400: 0.5601966311605748 Cost after iteration 500: 0.515830477276473 Cost after iteration 600: 0.4754901313943325 Cost after iteration 700: 0.43391631512257495 Cost after iteration 800: 0.4007977536203886 Cost after iteration 900: 0.35807050113237987 Cost after iteration 1000: 0.3394281538366413 Cost after iteration 1100: 0.30527536361962654 Cost after iteration 1200: 0.2749137728213015 Cost after iteration 1300: 0.24681768210614827 Cost after iteration 1400: 0.1985073503746611 Cost after iteration 1500: 0.17448318112556593 Cost after iteration 1600: 0.1708076297809661 Cost after iteration 1700: 0.11306524562164737 Cost after iteration 1800: 0.09629426845937163 Cost after iteration 1900: 0.08342617959726878 Cost after iteration 2000: 0.0743907870431909 Cost after iteration 2100: 0.06630748132267938 Cost after iteration 2200: 0.05919329501038176 Cost after iteration 2300: 0.05336140348560564 Cost after iteration 2400: 0.048554785628770226 Expected Output: Cost after iteration 0 0.6930497356599888 Cost after iteration 100 0.6464320953428849 … … Cost after iteration 2400 0.048554785628770206 Good thing you built a vectorized implementation! Otherwise it might have taken 10 times longer to train this. Now, you can use the trained parameters to classify images from the dataset. To see your predictions on the training and test sets, run the cell below. 1predictions_train = predict(train_x, train_y, parameters) Accuracy: 1.0 Expected Output: Accuracy 1.0 1predictions_test = predict(test_x, test_y, parameters) Accuracy: 0.72 Expected Output: Accuracy 0.72 Note: You may notice that running the model on fewer iterations (say 1500) gives better accuracy on the test set. This is called “early stopping” and we will talk about it in the next course. Early stopping is a way to prevent overfitting. Congratulations! It seems that your 2-layer neural network has better performance (72%) than the logistic regression implementation (70%, assignment week 2). Let’s see if you can do even better with an $L$-layer model. 5 - L-layer Neural NetworkQuestion: Use the helper functions you have implemented previously to build an $L$-layer neural network with the following structure: [LINEAR -&gt; RELU]$\times$(L-1) -&gt; LINEAR -&gt; SIGMOID. The functions you may need and their inputs are:123456789101112131415def initialize_parameters_deep(layers_dims): ... return parameters def L_model_forward(X, parameters): ... return AL, cachesdef compute_cost(AL, Y): ... return costdef L_model_backward(AL, Y, caches): ... return gradsdef update_parameters(parameters, grads, learning_rate): ... return parameters 12### CONSTANTS ###layers_dims = [12288, 20, 7, 5, 1] # 4-layer model 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# GRADED FUNCTION: L_layer_modeldef L_layer_model(X, Y, layers_dims, learning_rate = 0.0075, num_iterations = 3000, print_cost=False):#lr was 0.009 """ Implements a L-layer neural network: [LINEAR-&gt;RELU]*(L-1)-&gt;LINEAR-&gt;SIGMOID. Arguments: X -- data, numpy array of shape (number of examples, num_px * num_px * 3) Y -- true "label" vector (containing 0 if cat, 1 if non-cat), of shape (1, number of examples) layers_dims -- list containing the input size and each layer size, of length (number of layers + 1). learning_rate -- learning rate of the gradient descent update rule num_iterations -- number of iterations of the optimization loop print_cost -- if True, it prints the cost every 100 steps Returns: parameters -- parameters learnt by the model. They can then be used to predict. """ np.random.seed(1) costs = [] # keep track of cost # Parameters initialization. (≈ 1 line of code) ### START CODE HERE ### parameters = initialize_parameters_deep(layers_dims) ### END CODE HERE ### # Loop (gradient descent) for i in range(0, num_iterations): # Forward propagation: [LINEAR -&gt; RELU]*(L-1) -&gt; LINEAR -&gt; SIGMOID. ### START CODE HERE ### (≈ 1 line of code) AL, caches = L_model_forward(X, parameters) ### END CODE HERE ### # Compute cost. ### START CODE HERE ### (≈ 1 line of code) cost = compute_cost(AL, Y) ### END CODE HERE ### # Backward propagation. ### START CODE HERE ### (≈ 1 line of code) grads = L_model_backward(AL, Y, caches) ### END CODE HERE ### # Update parameters. ### START CODE HERE ### (≈ 1 line of code) parameters = update_parameters(parameters, grads, learning_rate) ### END CODE HERE ### # Print the cost every 100 training example if print_cost and i % 100 == 0: print ("Cost after iteration %i: %f" %(i, cost)) if print_cost and i % 100 == 0: costs.append(cost) # plot the cost plt.plot(np.squeeze(costs)) plt.ylabel('cost') plt.xlabel('iterations (per tens)') plt.title("Learning rate =" + str(learning_rate)) plt.show() return parameters You will now train the model as a 4-layer neural network. Run the cell below to train your model. The cost should decrease on every iteration. It may take up to 5 minutes to run 2500 iterations. Check if the “Cost after iteration 0” matches the expected output below, if not click on the square (⬛) on the upper bar of the notebook to stop the cell and try to find your error. 1parameters = L_layer_model(train_x, train_y, layers_dims, num_iterations = 2500, print_cost = True) Cost after iteration 0: 0.771749 Cost after iteration 100: 0.672053 Cost after iteration 200: 0.648263 Cost after iteration 300: 0.611507 Cost after iteration 400: 0.567047 Cost after iteration 500: 0.540138 Cost after iteration 600: 0.527930 Cost after iteration 700: 0.465477 Cost after iteration 800: 0.369126 Cost after iteration 900: 0.391747 Cost after iteration 1000: 0.315187 Cost after iteration 1100: 0.272700 Cost after iteration 1200: 0.237419 Cost after iteration 1300: 0.199601 Cost after iteration 1400: 0.189263 Cost after iteration 1500: 0.161189 Cost after iteration 1600: 0.148214 Cost after iteration 1700: 0.137775 Cost after iteration 1800: 0.129740 Cost after iteration 1900: 0.121225 Cost after iteration 2000: 0.113821 Cost after iteration 2100: 0.107839 Cost after iteration 2200: 0.102855 Cost after iteration 2300: 0.100897 Cost after iteration 2400: 0.092878 Expected Output: Cost after iteration 0 0.771749 Cost after iteration 100 0.672053 … … Cost after iteration 2400 0.092878 1pred_train = predict(train_x, train_y, parameters) Accuracy: 0.985645933014 Train Accuracy 0.985645933014 1pred_test = predict(test_x, test_y, parameters) Accuracy: 0.8 Expected Output: Test Accuracy 0.8 Congrats! It seems that your 4-layer neural network has better performance (80%) than your 2-layer neural network (72%) on the same test set. This is good performance for this task. Nice job! Though in the next course on “Improving deep neural networks” you will learn how to obtain even higher accuracy by systematically searching for better hyperparameters (learning_rate, layers_dims, num_iterations, and others you’ll also learn in the next course). 6) Results AnalysisFirst, let’s take a look at some images the L-layer model labeled incorrectly. This will show a few mislabeled images. 1print_mislabeled_images(classes, test_x, test_y, pred_test) A few types of images the model tends to do poorly on include: Cat body in an unusual position Cat appears against a background of a similar color Unusual cat color and species Camera Angle Brightness of the picture Scale variation (cat is very large or small in image) 7) Test with your own image (optional/ungraded exercise)Congratulations on finishing this assignment. You can use your own image and see the output of your model. To do that: 1. Click on &quot;File&quot; in the upper bar of this notebook, then click &quot;Open&quot; to go on your Coursera Hub. 2. Add your image to this Jupyter Notebook&apos;s directory, in the &quot;images&quot; folder 3. Change your image&apos;s name in the following code 4. Run the code and check if the algorithm is right (1 = cat, 0 = non-cat)! 12345678910111213## START CODE HERE ##my_image = "my_image.jpg" # change this to the name of your image file my_label_y = [1] # the true class of your image (1 -&gt; cat, 0 -&gt; non-cat)## END CODE HERE ##fname = "" + my_imageimage = np.array(ndimage.imread(fname, flatten=False))my_image = scipy.misc.imresize(image, size=(num_px,num_px)).reshape((num_px*num_px*3,1))my_image = my_image/255.my_predicted_image = predict(my_image, my_label_y, parameters)plt.imshow(image)print ("y = " + str(np.squeeze(my_predicted_image)) + ", your L-layer model predicts a \"" + classes[int(np.squeeze(my_predicted_image)),].decode("utf-8") + "\" picture.") Accuracy: 1.0 y = 1.0, your L-layer model predicts a &quot;cat&quot; picture. References: for auto-reloading external module: http://stackoverflow.com/questions/1907993/autoreload-of-modules-in-ipython]]></content>
      <tags>
        <tag>Deeplearning.ai</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows局域网与手机共享文件以及iOS文件操作]]></title>
    <url>%2F2018%2F05%2F16%2Fwindows-LAN-share-data-ios-upload-airplay%2F</url>
    <content type="text"><![CDATA[相关背景由于最近拍的照片比较多，有一些需要传到电脑里进行备份。还有，有将电脑里的文件用手机投屏到电视上或投影仪上的需求。因此，有网络硬盘做存储中心，手机做控制中心的需求。 我只是个人进行文件备份，对延迟没有突出需求，所以决定将电脑作为局域网中的NAS。 Windows做文件共享此步骤参考了百度经验 右击桌面网络—-属性—-更改高级共享设置 （注释：查看当前网络 比如：家庭网络、公共网络 等!) “我这里为公共网络” 选择 公共网络—选择以下选项：启动网络发现——启动文件和打印机共享—–启用共享以便可以访问网络的用户可以读取和写入公用文件夹中的文件(可以不选）—-关闭密码保护共享( 注释：其他选项默认即可!) 保存！ 选择需要共享的文件夹 (比如：DY) 右击–属性 共享—- 选择 共享（S）…—弹出对话框—添加“Guest”（注释：选择“Guest”是为了降低权限，以方便于所有用户都能访问！）—共享 选择 高级共享… —-选择 共享此文件 —-确定！ 其他用户，通过开始—运行—\\IP （快捷键 WIN+R）\\IP 访问你共享的文件! 共享成功!ios共享数据下载FileExplorer本教程参考自iOS神器FileExplorer精简使用教程具体操作方法为： 保持 Windows 和 iPad 在同一局域网环境下，如：使用同一个WiFi。 点击右上角“+号”，选择Windows 往下拉，选择网络邻居里的项目（如图即：DESKTOP-71EDJSC），并选择“注册的用户”\ 输入Windows的账户名和密码，然后，尽情浏览你的共享文件吧 win10：遇到权限不足时，点击设置-帐户-你的电子邮件和帐户-改用本地帐户登录，使用此时的帐号密码登录 FileExplorer 即可。 其余操作可以到FE官方文档查看 ios文件上传照片与文件上传具体操作查看FE文件传输 ios11文件格式问题ios11之后，iphone的照片格式变成了.heic，所以windows也无法查看与转换，有两种转换方法： 单独上传可以用ios自带的 文件 进行转换然后将icloud里面的文件复制到windows文件夹中。 批量上传可以使用批量转换工具，我使用的是开源的转换工具HEIF Utility，github地址为HEIF Utility 共享文件投屏具体操作方法查看FE投屏方法。 注意这里需要你的投放设备支持DLNA协议的设备，如果搜不到airplay设备，可以给你的设备下载投屏工具，类似于乐播投屏。 iphone通过airplay音频输出到windows可以使用shairport4w]]></content>
      <tags>
        <tag>运维</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Deeplearning.ai 笔记作业（一）week3]]></title>
    <url>%2F2018%2F05%2F15%2Fdeeplearning-ai-nn-and-dl-week3%2F</url>
    <content type="text"><![CDATA[第一章 神经网络和深度学习 Week3 笔记神经网络概要 主要讲了神经网络要分层，分为输入层，隐藏层，输出层。输入层可以认为是layer0，layer1可以认为是hidden layer，layer2可以认为是output layer。参数 W 和 b 可以用上角标表示，比如第一层W[1]和b[1].同时，用反向传播的方法，求dZ[1]等。 神经网络表示 a[i]表示第i层的激励(activation)，W 和 b 类似 计算神经网络的输出（前向传播） Given Input X: Z[1] = W[1]X + b[1] = W[1]a0 + b[1] a1 = $\sigma$(Z[1]) Z[2] = W[2]X + b[2] = W[2]a0 + b[2] a2 = $\sigma$(Z[2]) X = [X(1), X(2),…,X(m)] Z[1] = [Z[1](1), Z[1](2),…,Z[1](m)] 注意计算的时候一定要注意np.ndarry.shape的匹配。方括号表示层数，圆括号表示样本序号 激活函数 $\sigma(x)$: sigmoid函数 tanh(x) = $\frac{e^Z-e^-Z}{e^Z+e^-Z}$ = 1 - $\sigma(x)$ ReLU: max(0, x) leaky ReLU: max(0.001x, x) tanh常用于做激励函数，因为tanh的mean是0，而sigmoid函数的mean是0.5，因此这样做可以做到规格化的作用，使得结果更接近于0，给模型更多优化。使用sigmoid函数的场景是做二分类的时候进行。tanh函数和sigmoid函数会导致梯度弥散，在数值特别大的时候，会导致梯度会无限趋近于0，使得收敛速度慢，模型效果差。ReLU是NG默认使用的最优激励函数，如果不是二分类问题，这两个函数会使收敛速度变快，效果好。 为什么要使用非线性的激活函数a[2]=W[2](W[1]X+b[1])+b[2]=(W[2]W[1])X+(W[2]b[1]+b[2])=WX+b 我们将激活函数表示为非线性函数 g(x) 如果只是使用线性关系，无论网络有多少层，都只是现行的相加，只是复杂的逻辑回归，没有任何变化。 计算导数和神经网络的梯度下降由于链式法则可以发现，进行反向传播的时候，需要进行计算上一层的激活函数的导数。 梯度下降： Repeat{ output prtedict：y_hat dW[i]=$\frac{dJ}{dW^i}$ Wi=Wi - $\alpha$ dW[i] bi= bi - $\alpha$ db[i]} 反向传播 keepdims是防止产生了shape为(n_h,)这样的数组，而是要产生矩阵。 随机初始化参数如果都是用全0初始化参数，就会由于对称原理得每一层都会得到功能相同的神经元，所以无论训练多久都会一样，所以需要用随机。 W[i] = np.random.randn((2, 2)) * 0.01b[i] = np.zeros((2, 1)) 乘以的0.01是使得W参数变小，因为如果使用sigmoid的时候，会使输入的Z值特别大，使得在sigmoid的梯度特别小，这样会收敛速度会比较慢。 作业课堂小quiz下载或查看 Planar data classification with one hidden layerWelcome to your week 3 programming assignment. It’s time to build your first neural network, which will have a hidden layer. You will see a big difference between this model and the one you implemented using logistic regression. You will learn how to: Implement a 2-class classification neural network with a single hidden layer Use units with a non-linear activation function, such as tanh Compute the cross entropy loss Implement forward and backward propagation 1 - PackagesLet’s first import all the packages that you will need during this assignment. numpy is the fundamental package for scientific computing with Python. sklearn provides simple and efficient tools for data mining and data analysis. matplotlib is a library for plotting graphs in Python. testCases provides some test examples to assess the correctness of your functions planar_utils provide various useful functions used in this assignment 123456789101112# Package importsimport numpy as npimport matplotlib.pyplot as pltfrom testCases_v2 import *import sklearnimport sklearn.datasetsimport sklearn.linear_modelfrom planar_utils import plot_decision_boundary, sigmoid, load_planar_dataset, load_extra_datasets%matplotlib inlinenp.random.seed(1) # set a seed so that the results are consistent 2 - DatasetFirst, let’s get the dataset you will work on. The following code will load a “flower” 2-class dataset into variables X and Y. 1X, Y = load_planar_dataset() Visualize the dataset using matplotlib. The data looks like a “flower” with some red (label y=0) and some blue (y=1) points. Your goal is to build a model to fit this data. 12# Visualize the data:plt.scatter(X[0, :], X[1, :], c=Y, s=40, cmap=plt.cm.Spectral); You have: - a numpy-array (matrix) X that contains your features (x1, x2) - a numpy-array (vector) Y that contains your labels (red:0, blue:1). Lets first get a better sense of what our data is like. Exercise: How many training examples do you have? In addition, what is the shape of the variables X and Y? Hint: How do you get the shape of a numpy array? (help) 123456789### START CODE HERE ### (≈ 3 lines of code)shape_X = X.shapeshape_Y = Y.shapem = X.shape[1] # training set size### END CODE HERE ###print ('The shape of X is: ' + str(shape_X))print ('The shape of Y is: ' + str(shape_Y))print ('I have m = %d training examples!' % (m)) The shape of X is: (2, 400) The shape of Y is: (1, 400) I have m = 400 training examples! Expected Output: shape of X (2, 400) shape of Y (1, 400) m 400 3 - Simple Logistic RegressionBefore building a full neural network, lets first see how logistic regression performs on this problem. You can use sklearn’s built-in functions to do that. Run the code below to train a logistic regression classifier on the dataset. 123# Train the logistic regression classifierclf = sklearn.linear_model.LogisticRegressionCV();clf.fit(X.T, Y.T); /opt/conda/lib/python3.5/site-packages/sklearn/utils/validation.py:515: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel(). y = column_or_1d(y, warn=True) You can now plot the decision boundary of these models. Run the code below. 12345678# Plot the decision boundary for logistic regressionplot_decision_boundary(lambda x: clf.predict(x), X, Y)plt.title("Logistic Regression")# Print accuracyLR_predictions = clf.predict(X.T)print ('Accuracy of logistic regression: %d ' % float((np.dot(Y,LR_predictions) + np.dot(1-Y,1-LR_predictions))/float(Y.size)*100) + '% ' + "(percentage of correctly labelled datapoints)") Accuracy of logistic regression: 47 % (percentage of correctly labelled datapoints) Expected Output: Accuracy 47% Interpretation: The dataset is not linearly separable, so logistic regression doesn’t perform well. Hopefully a neural network will do better. Let’s try this now! 4 - Neural Network modelLogistic regression did not work well on the “flower dataset”. You are going to train a Neural Network with a single hidden layer. Here is our model: Mathematically: For one example $x^{(i)}$:$$z^{[1] (i)} = W^{[1]} x^{(i)} + b^{[1]}\tag{1}$$$$a^{[1] (i)} = \tanh(z^{[1] (i)})\tag{2}$$$$z^{[2] (i)} = W^{[2]} a^{[1] (i)} + b^{[2]}\tag{3}$$$$\hat{y}^{(i)} = a^{[2] (i)} = \sigma(z^{ [2] (i)})\tag{4}$$$$y^{(i)}_{prediction} = \begin{cases} 1 &amp; \mbox{if } a^{2} &gt; 0.5 \ 0 &amp; \mbox{otherwise } \end{cases}\tag{5}$$ Given the predictions on all the examples, you can also compute the cost $J$ as follows:$$J = - \frac{1}{m} \sum\limits_{i = 0}^{m} \large\left(\small y^{(i)}\log\left(a^{[2] (i)}\right) + (1-y^{(i)})\log\left(1- a^{[2] (i)}\right) \large \right) \small \tag{6}$$ Reminder: The general methodology to build a Neural Network is to: 1. Define the neural network structure ( # of input units, # of hidden units, etc). 2. Initialize the model&apos;s parameters 3. Loop: - Implement forward propagation - Compute loss - Implement backward propagation to get the gradients - Update parameters (gradient descent) You often build helper functions to compute steps 1-3 and then merge them into one function we call nn_model(). Once you’ve built nn_model() and learnt the right parameters, you can make predictions on new data. 4.1 - Defining the neural network structureExercise: Define three variables: - n_x: the size of the input layer - n_h: the size of the hidden layer (set this to 4) - n_y: the size of the output layer Hint: Use shapes of X and Y to find n_x and n_y. Also, hard code the hidden layer size to be 4. 12345678910111213141516171819# GRADED FUNCTION: layer_sizesdef layer_sizes(X, Y): """ Arguments: X -- input dataset of shape (input size, number of examples) Y -- labels of shape (output size, number of examples) Returns: n_x -- the size of the input layer n_h -- the size of the hidden layer n_y -- the size of the output layer """ ### START CODE HERE ### (≈ 3 lines of code) n_x = X.shape[0] # size of input layer n_h = 4 n_y = Y.shape[0] # size of output layer ### END CODE HERE ### return (n_x, n_h, n_y) 12345X_assess, Y_assess = layer_sizes_test_case()(n_x, n_h, n_y) = layer_sizes(X_assess, Y_assess)print("The size of the input layer is: n_x = " + str(n_x))print("The size of the hidden layer is: n_h = " + str(n_h))print("The size of the output layer is: n_y = " + str(n_y)) The size of the input layer is: n_x = 5 The size of the hidden layer is: n_h = 4 The size of the output layer is: n_y = 2 Expected Output (these are not the sizes you will use for your network, they are just used to assess the function you’ve just coded). n_x 5 n_h 4 n_y 2 4.2 - Initialize the model’s parametersExercise: Implement the function initialize_parameters(). Instructions: Make sure your parameters’ sizes are right. Refer to the neural network figure above if needed. You will initialize the weights matrices with random values. Use: np.random.randn(a,b) * 0.01 to randomly initialize a matrix of shape (a,b). You will initialize the bias vectors as zeros. Use: np.zeros((a,b)) to initialize a matrix of shape (a,b) with zeros. 123456789101112131415161718192021222324252627282930313233343536# GRADED FUNCTION: initialize_parametersdef initialize_parameters(n_x, n_h, n_y): """ Argument: n_x -- size of the input layer n_h -- size of the hidden layer n_y -- size of the output layer Returns: params -- python dictionary containing your parameters: W1 -- weight matrix of shape (n_h, n_x) b1 -- bias vector of shape (n_h, 1) W2 -- weight matrix of shape (n_y, n_h) b2 -- bias vector of shape (n_y, 1) """ np.random.seed(2) # we set up a seed so that your output matches ours although the initialization is random. ### START CODE HERE ### (≈ 4 lines of code) W1 = np.random.randn(n_h, n_x) * 0.01 b1 = np.zeros((n_h, 1)) W2 = np.random.randn(n_y, n_h) * 0.01 b2 = np.zeros((n_y, 1)) ### END CODE HERE ### assert (W1.shape == (n_h, n_x)) assert (b1.shape == (n_h, 1)) assert (W2.shape == (n_y, n_h)) assert (b2.shape == (n_y, 1)) parameters = &#123;"W1": W1, "b1": b1, "W2": W2, "b2": b2&#125; return parameters 1234567n_x, n_h, n_y = initialize_parameters_test_case()parameters = initialize_parameters(n_x, n_h, n_y)print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) W1 = [[-0.00416758 -0.00056267] [-0.02136196 0.01640271] [-0.01793436 -0.00841747] [ 0.00502881 -0.01245288]] b1 = [[ 0.] [ 0.] [ 0.] [ 0.]] W2 = [[-0.01057952 -0.00909008 0.00551454 0.02292208]] b2 = [[ 0.]] Expected Output: W1 [[-0.00416758 -0.00056267] [-0.02136196 0.01640271] [-0.01793436 -0.00841747] [ 0.00502881 -0.01245288]] b1 [[ 0.] [ 0.] [ 0.] [ 0.]] W2 [[-0.01057952 -0.00909008 0.00551454 0.02292208]] b2** [[ 0.]] 4.3 - The LoopQuestion: Implement forward_propagation(). Instructions: Look above at the mathematical representation of your classifier. You can use the function sigmoid(). It is built-in (imported) in the notebook. You can use the function np.tanh(). It is part of the numpy library. The steps you have to implement are: Retrieve each parameter from the dictionary “parameters” (which is the output of initialize_parameters()) by using parameters[&quot;..&quot;]. Implement Forward Propagation. Compute $Z^{[1]}, A^{[1]}, Z^{[2]}$ and $A^{[2]}$ (the vector of all your predictions on all the examples in the training set). Values needed in the backpropagation are stored in “cache“. The cache will be given as an input to the backpropagation function. 123456789101112131415161718192021222324252627282930313233343536# GRADED FUNCTION: forward_propagationdef forward_propagation(X, parameters): """ Argument: X -- input data of size (n_x, m) parameters -- python dictionary containing your parameters (output of initialization function) Returns: A2 -- The sigmoid output of the second activation cache -- a dictionary containing "Z1", "A1", "Z2" and "A2" """ # Retrieve each parameter from the dictionary "parameters" ### START CODE HERE ### (≈ 4 lines of code) W1 = parameters['W1'] b1 = parameters['b1'] W2 = parameters['W2'] b2 = parameters['b2'] ### END CODE HERE ### # Implement Forward Propagation to calculate A2 (probabilities) ### START CODE HERE ### (≈ 4 lines of code) Z1 = np.dot(W1, X) + b1 A1 = np.tanh(Z1) Z2 = np.dot(W2, A1) + b2 A2 = 1.0 / (1.0 + np.exp(-Z2)) ### END CODE HERE ### assert(A2.shape == (1, X.shape[1])) cache = &#123;"Z1": Z1, "A1": A1, "Z2": Z2, "A2": A2&#125; return A2, cache 12345X_assess, parameters = forward_propagation_test_case()A2, cache = forward_propagation(X_assess, parameters)# Note: we use the mean here just to make sure that your output matches ours. print(np.mean(cache['Z1']) ,np.mean(cache['A1']),np.mean(cache['Z2']),np.mean(cache['A2'])) 0.262818640198 0.091999045227 -1.30766601287 0.212877681719 Expected Output: 0.262818640198 0.091999045227 -1.30766601287 0.212877681719 Now that you have computed $A^{[2]}$ (in the Python variable “A2“), which contains $a^{2}$ for every example, you can compute the cost function as follows: $$J = - \frac{1}{m} \sum\limits_{i = 0}^{m} \large{(} \small y^{(i)}\log\left(a^{[2] (i)}\right) + (1-y^{(i)})\log\left(1- a^{[2] (i)}\right) \large{)} \small\tag{13}$$ Exercise: Implement compute_cost() to compute the value of the cost $J$. Instructions: There are many ways to implement the cross-entropy loss. To help you, we give you how we would have implemented$- \sum\limits_{i=0}^{m} y^{(i)}\log(a^{2})$:12logprobs = np.multiply(np.log(A2),Y)cost = - np.sum(logprobs) # no need to use a for loop! (you can use either np.multiply() and then np.sum() or directly np.dot()). 1234567891011121314151617181920212223242526272829303132# GRADED FUNCTION: compute_costdef compute_cost(A2, Y, parameters): """ Computes the cross-entropy cost given in equation (13) Arguments: A2 -- The sigmoid output of the second activation, of shape (1, number of examples) Y -- "true" labels vector of shape (1, number of examples) parameters -- python dictionary containing your parameters W1, b1, W2 and b2 Returns: cost -- cross-entropy cost given equation (13) """ m = Y.shape[1] # number of example # Compute the cross-entropy cost ### START CODE HERE ### (≈ 2 lines of code) logprobs = np.multiply(np.log(A2), Y) # 此方法不行，因为生成的类型是numpy.ndarray cost = -(float(np.dot(np.log(A2), Y.T)) + np.dot(np.log(1.0 - A2), (1 - Y.T))) / m # 此方法做法是做内积，所以生成的是np.float64 cost = - np.sum(np.multiply(np.log(A2), Y) + np.multiply(np.log(1. - A2), 1. - Y)) / m ### END CODE HERE ### cost = np.squeeze(cost) # makes sure cost is the dimension we expect. # E.g., turns [[17]] into 17 assert(isinstance(cost, float)) return cost 123A2, Y_assess, parameters = compute_cost_test_case()print("cost = " + str(compute_cost(A2, Y_assess, parameters))) cost = 0.693058761039 Expected Output: cost 0.693058761… Using the cache computed during forward propagation, you can now implement backward propagation. Question: Implement the function backward_propagation(). Instructions:Backpropagation is usually the hardest (most mathematical) part in deep learning. To help you, here again is the slide from the lecture on backpropagation. You’ll want to use the six equations on the right of this slide, since you are building a vectorized implementation. Tips: To compute dZ1 you’ll need to compute $g^{[1]’}(Z^{[1]})$. Since $g^{[1]}(.)$ is the tanh activation function, if $a = g^{[1]}(z)$ then $g^{[1]’}(z) = 1-a^2$. So you can compute$g^{[1]’}(Z^{[1]})$ using (1 - np.power(A1, 2)). 123456789101112131415161718192021222324252627282930313233343536373839404142434445# GRADED FUNCTION: backward_propagationdef backward_propagation(parameters, cache, X, Y): """ Implement the backward propagation using the instructions above. Arguments: parameters -- python dictionary containing our parameters cache -- a dictionary containing "Z1", "A1", "Z2" and "A2". X -- input data of shape (2, number of examples) Y -- "true" labels vector of shape (1, number of examples) Returns: grads -- python dictionary containing your gradients with respect to different parameters """ m = X.shape[1] # First, retrieve W1 and W2 from the dictionary "parameters". ### START CODE HERE ### (≈ 2 lines of code) W1 = parameters['W1'] W2 = parameters['W2'] ### END CODE HERE ### # Retrieve also A1 and A2 from dictionary "cache". ### START CODE HERE ### (≈ 2 lines of code) A1 = cache['A1'] A2 = cache['A2'] ### END CODE HERE ### # Backward propagation: calculate dW1, db1, dW2, db2. ### START CODE HERE ### (≈ 6 lines of code, corresponding to 6 equations on slide above) dZ2 = A2 - Y dW2 = np.dot(dZ2, A1.T) / m db2 = np.sum(dZ2, axis = 1, keepdims = True) / m dZ1 = np.dot(W2.T, dZ2) * (1 - np.power(A1, 2)) dW1 = np.dot(dZ1, X.T) / m db1 = np.sum(dZ1, axis = 1, keepdims = True) / m ### END CODE HERE ### grads = &#123;"dW1": dW1, "db1": db1, "dW2": dW2, "db2": db2&#125; return grads 1234567parameters, cache, X_assess, Y_assess = backward_propagation_test_case()grads = backward_propagation(parameters, cache, X_assess, Y_assess)print ("dW1 = "+ str(grads["dW1"]))print ("db1 = "+ str(grads["db1"]))print ("dW2 = "+ str(grads["dW2"]))print ("db2 = "+ str(grads["db2"])) dW1 = [[ 0.00301023 -0.00747267] [ 0.00257968 -0.00641288] [-0.00156892 0.003893 ] [-0.00652037 0.01618243]] db1 = [[ 0.00176201] [ 0.00150995] [-0.00091736] [-0.00381422]] dW2 = [[ 0.00078841 0.01765429 -0.00084166 -0.01022527]] db2 = [[-0.16655712]] Expected output: dW1 [[ 0.00301023 -0.00747267] [ 0.00257968 -0.00641288] [-0.00156892 0.003893 ] [-0.00652037 0.01618243]] db1 [[ 0.00176201] [ 0.00150995] [-0.00091736] [-0.00381422]] dW2 [[ 0.00078841 0.01765429 -0.00084166 -0.01022527]] db2 [[-0.16655712]] Question: Implement the update rule. Use gradient descent. You have to use (dW1, db1, dW2, db2) in order to update (W1, b1, W2, b2). General gradient descent rule: $ \theta = \theta - \alpha \frac{\partial J }{ \partial \theta }$ where $\alpha$ is the learning rate and $\theta$ represents a parameter. Illustration: The gradient descent algorithm with a good learning rate (converging) and a bad learning rate (diverging). Images courtesy of Adam Harley. 12345678910111213141516171819202122232425262728293031323334353637383940414243# GRADED FUNCTION: update_parametersdef update_parameters(parameters, grads, learning_rate = 1.2): """ Updates parameters using the gradient descent update rule given above Arguments: parameters -- python dictionary containing your parameters grads -- python dictionary containing your gradients Returns: parameters -- python dictionary containing your updated parameters """ # Retrieve each parameter from the dictionary "parameters" ### START CODE HERE ### (≈ 4 lines of code) W1 = parameters['W1'] b1 = parameters['b1'] W2 = parameters['W2'] b2 = parameters['b2'] ### END CODE HERE ### # Retrieve each gradient from the dictionary "grads" ### START CODE HERE ### (≈ 4 lines of code) dW1 = grads['dW1'] db1 = grads['db1'] dW2 = grads['dW2'] db2 = grads['db2'] ## END CODE HERE ### # Update rule for each parameter ### START CODE HERE ### (≈ 4 lines of code) W1 = W1 - learning_rate * dW1 b1 = b1 - learning_rate * db1 W2 = W2 - learning_rate * dW2 b2 = b2 - learning_rate * db2 ### END CODE HERE ### parameters = &#123;"W1": W1, "b1": b1, "W2": W2, "b2": b2&#125; return parameters 1234567parameters, grads = update_parameters_test_case()parameters = update_parameters(parameters, grads)print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) W1 = [[-0.00643025 0.01936718] [-0.02410458 0.03978052] [-0.01653973 -0.02096177] [ 0.01046864 -0.05990141]] b1 = [[ -1.02420756e-06] [ 1.27373948e-05] [ 8.32996807e-07] [ -3.20136836e-06]] W2 = [[-0.01041081 -0.04463285 0.01758031 0.04747113]] b2 = [[ 0.00010457]] Expected Output: W1 [[-0.00643025 0.01936718] [-0.02410458 0.03978052] [-0.01653973 -0.02096177] [ 0.01046864 -0.05990141]] b1 [[ -1.02420756e-06] [ 1.27373948e-05] [ 8.32996807e-07] [ -3.20136836e-06]] W2 [[-0.01041081 -0.04463285 0.01758031 0.04747113]] b2 [[ 0.00010457]] 4.4 - Integrate parts 4.1, 4.2 and 4.3 in nn_model()Question: Build your neural network model in nn_model(). Instructions: The neural network model has to use the previous functions in the right order. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# GRADED FUNCTION: nn_modeldef nn_model(X, Y, n_h, num_iterations = 10000, print_cost=False): """ Arguments: X -- dataset of shape (2, number of examples) Y -- labels of shape (1, number of examples) n_h -- size of the hidden layer num_iterations -- Number of iterations in gradient descent loop print_cost -- if True, print the cost every 1000 iterations Returns: parameters -- parameters learnt by the model. They can then be used to predict. """ np.random.seed(3) n_x = layer_sizes(X, Y)[0] n_y = layer_sizes(X, Y)[2] # Initialize parameters, then retrieve W1, b1, W2, b2. Inputs: "n_x, n_h, n_y". Outputs = "W1, b1, W2, b2, parameters". ### START CODE HERE ### (≈ 5 lines of code) parameters = initialize_parameters(n_x, n_h, n_y) W1 = parameters['W1'] b1 = parameters['b1'] W2 = parameters['W2'] b2 = parameters['b2'] ### END CODE HERE ### # Loop (gradient descent) for i in range(0, num_iterations): ### START CODE HERE ### (≈ 4 lines of code) # Forward propagation. Inputs: "X, parameters". Outputs: "A2, cache". A2, cache = forward_propagation(X, parameters) # Cost function. Inputs: "A2, Y, parameters". Outputs: "cost". cost = compute_cost(A2, Y, parameters) # Backpropagation. Inputs: "parameters, cache, X, Y". Outputs: "grads". grads = backward_propagation(parameters, cache, X, Y) # Gradient descent parameter update. Inputs: "parameters, grads". Outputs: "parameters". parameters = update_parameters(parameters, grads) ### END CODE HERE ### # Print the cost every 1000 iterations if print_cost and i % 1000 == 0: print ("Cost after iteration %i: %f" %(i, cost)) return parameters 123456X_assess, Y_assess = nn_model_test_case()parameters = nn_model(X_assess, Y_assess, 4, num_iterations=10000, print_cost=True)print("W1 = " + str(parameters["W1"]))print("b1 = " + str(parameters["b1"]))print("W2 = " + str(parameters["W2"]))print("b2 = " + str(parameters["b2"])) Cost after iteration 0: 0.692739 Cost after iteration 1000: 0.000218 Cost after iteration 2000: 0.000107 Cost after iteration 3000: 0.000071 Cost after iteration 4000: 0.000053 Cost after iteration 5000: 0.000042 Cost after iteration 6000: 0.000035 Cost after iteration 7000: 0.000030 Cost after iteration 8000: 0.000026 Cost after iteration 9000: 0.000023 W1 = [[-0.65848169 1.21866811] [-0.76204273 1.39377573] [ 0.5792005 -1.10397703] [ 0.76773391 -1.41477129]] b1 = [[ 0.287592 ] [ 0.3511264 ] [-0.2431246 ] [-0.35772805]] W2 = [[-2.45566237 -3.27042274 2.00784958 3.36773273]] b2 = [[ 0.20459656]] Expected Output: cost after iteration 0 0.692739 $\vdots$ $\vdots$ W1 [[-0.65848169 1.21866811] [-0.76204273 1.39377573] [ 0.5792005 -1.10397703] [ 0.76773391 -1.41477129]] b1 [[ 0.287592 ] [ 0.3511264 ] [-0.2431246 ] [-0.35772805]] W2 [[-2.45566237 -3.27042274 2.00784958 3.36773273]] b2 [[ 0.20459656]] 4.5 PredictionsQuestion: Use your model to predict by building predict().Use forward propagation to predict results. Reminder: predictions = $y_{prediction} = \mathbb 1 \textfalse = \begin{cases} 1 &amp; \text{if} activation &gt; 0.5 \\ 0 &amp; \text{otherwise} \end{cases}$ As an example, if you would like to set the entries of a matrix X to 0 and 1 based on a threshold you would do: 12345678910111213141516171819202122232425```python# GRADED FUNCTION: predictdef predict(parameters, X): &quot;&quot;&quot; Using the learned parameters, predicts a class for each example in X Arguments: parameters -- python dictionary containing your parameters X -- input data of size (n_x, m) Returns predictions -- vector of predictions of our model (red: 0 / blue: 1) &quot;&quot;&quot; # Computes probabilities using forward propagation, and classifies to 0/1 using 0.5 as the threshold. ### START CODE HERE ### (≈ 2 lines of code) A2, cache = forward_propagation(X, parameters) predictions = list(map(lambda x : 0 if x &lt; 0.5 else 1, A2[0])) predictions = np.array([predictions]) ### END CODE HERE ### return predictions 1234parameters, X_assess = predict_test_case()predictions = predict(parameters, X_assess)print("predictions mean = " + str(np.mean(predictions))) predictions mean = 0.666666666667 Expected Output: predictions mean 0.666666666667 It is time to run the model and see how it performs on a planar dataset. Run the following code to test your model with a single hidden layer of $n_h$ hidden units. 123456# Build a model with a n_h-dimensional hidden layerparameters = nn_model(X, Y, n_h = 4, num_iterations = 10000, print_cost=True)# Plot the decision boundaryplot_decision_boundary(lambda x: predict(parameters, x.T), X, Y)plt.title("Decision Boundary for hidden layer size " + str(4)) Cost after iteration 0: 0.693048 Cost after iteration 1000: 0.288083 Cost after iteration 2000: 0.254385 Cost after iteration 3000: 0.233864 Cost after iteration 4000: 0.226792 Cost after iteration 5000: 0.222644 Cost after iteration 6000: 0.219731 Cost after iteration 7000: 0.217504 Cost after iteration 8000: 0.219471 Cost after iteration 9000: 0.218612 &lt;matplotlib.text.Text at 0x7f0bbeb25898&gt; Expected Output: Cost after iteration 9000 0.218607 123# Print accuracypredictions = predict(parameters, X)print ('Accuracy: %d' % float((np.dot(Y,predictions.T) + np.dot(1-Y,1-predictions.T))/float(Y.size)*100) + '%') Accuracy: 90% Expected Output: Accuracy 90% Accuracy is really high compared to Logistic Regression. The model has learnt the leaf patterns of the flower! Neural networks are able to learn even highly non-linear decision boundaries, unlike logistic regression. Now, let’s try out several hidden layer sizes. 4.6 - Tuning hidden layer size (optional/ungraded exercise)Run the following code. It may take 1-2 minutes. You will observe different behaviors of the model for various hidden layer sizes. 123456789101112# This may take about 2 minutes to runplt.figure(figsize=(16, 32))hidden_layer_sizes = [1, 2, 3, 4, 5, 20, 50]for i, n_h in enumerate(hidden_layer_sizes): plt.subplot(5, 2, i+1) plt.title('Hidden Layer of size %d' % n_h) parameters = nn_model(X, Y, n_h, num_iterations = 5000) plot_decision_boundary(lambda x: predict(parameters, x.T), X, Y) predictions = predict(parameters, X) accuracy = float((np.dot(Y,predictions.T) + np.dot(1-Y,1-predictions.T))/float(Y.size)*100) print ("Accuracy for &#123;&#125; hidden units: &#123;&#125; %".format(n_h, accuracy)) Accuracy for 1 hidden units: 67.5 % Accuracy for 2 hidden units: 67.25 % Accuracy for 3 hidden units: 90.75 % Accuracy for 4 hidden units: 90.5 % Accuracy for 5 hidden units: 91.25 % Accuracy for 20 hidden units: 90.0 % Accuracy for 50 hidden units: 90.25 % Interpretation: The larger models (with more hidden units) are able to fit the training set better, until eventually the largest models overfit the data. The best hidden layer size seems to be around n_h = 5. Indeed, a value around here seems to fits the data well without also incurring noticable overfitting. You will also learn later about regularization, which lets you use very large models (such as n_h = 50) without much overfitting. Optional questions: Note: Remember to submit the assignment but clicking the blue “Submit Assignment” button at the upper-right. Some optional/ungraded questions that you can explore if you wish: What happens when you change the tanh activation for a sigmoid activation or a ReLU activation? Play with the learning_rate. What happens? What if we change the dataset? (See part 5 below!) You’ve learnt to: Build a complete neural network with a hidden layer Make a good use of a non-linear unit Implemented forward propagation and backpropagation, and trained a neural network See the impact of varying the hidden layer size, including overfitting. Nice work! 5) Performance on other datasetsIf you want, you can rerun the whole notebook (minus the dataset part) for each of the following datasets. 123456789101112131415161718192021# Datasetsnoisy_circles, noisy_moons, blobs, gaussian_quantiles, no_structure = load_extra_datasets()datasets = &#123;"noisy_circles": noisy_circles, "noisy_moons": noisy_moons, "blobs": blobs, "gaussian_quantiles": gaussian_quantiles&#125;### START CODE HERE ### (choose your dataset)dataset = "noisy_moons"### END CODE HERE ###X, Y = datasets[dataset]X, Y = X.T, Y.reshape(1, Y.shape[0])# make blobs binaryif dataset == "blobs": Y = Y%2# Visualize the dataplt.scatter(X[0, :], X[1, :], c=Y, s=40, cmap=plt.cm.Spectral); Congrats on finishing this Programming Assignment! Reference: http://scs.ryerson.ca/~aharley/neural-networks/ http://cs231n.github.io/neural-networks-case-study/]]></content>
      <tags>
        <tag>Deeplearning.ai</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人博客（hexo next）日志及校外ipv6 bt访问工具]]></title>
    <url>%2F2018%2F04%2F27%2Fblog-build-and-ipv6-tools%2F</url>
    <content type="text"><![CDATA[博客就是记录最近的工作，所以就把这个博客的搭建过程以及校外访问bt小工具的日志作为个人博客的第一篇。 博客搭建过程调研直接看步骤 我在知乎上翻阅了大部分关于博客工具的回答，基本了解个人博客一般采用脚本语言搭建Web（比如Django等）和静态网页工具两种。由于不想增加额外的运维成本，基本定位到静态网页工具上。由于不想在前端模板方面投入太多精力，所以基本去找有比较稳定的主题的工具。参考准备自己建一个个人博客，有什么好的框架推荐？ - 知乎和一些其他的文章，基本把调研内容锁定在jekyll和hexo两种工具上。 Jekyll是基于Ruby脚本实现的博客生成工具，是经常与Github Pages配合使用的工具。目前比较常用的主题是huxpro，我之前的同事王喆的博客也是基于这个主题构建的。但是，经过试验发现，主题代码已经更新较多，相关文档却没有对应更新，一些设置找不到对应文档只能去查看源码，所以测试了Hexo之后选取了Hexo。但是，毕竟Jekyll是Github配套工具，相关的主题也比较完整，所以想要自己折腾的可以多尝试尝试。 Hexo是基于Node.js脚本实现的博客生成类工具，如果你之前做过有关node的工作，相对接触Hexo也比较简单。Hexo比较流行的主题是Next，功能没有那么丰富，所以配置相对简单而且全面，文档十分详细，运维成本低。而且Hexo的官网还有对应的youtube视频可以看，懒得看的可以对着视频做也不会出错。 详细教程可以在Hexo官网查看，以下给出简单步骤。 步骤安装Node.js，windows的可以下载，其余同学可以用Node Version Manager安装1234# 安装nvm$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh | bash# 安装Node.js$ nvm install stable 安装git可以参考 git 准备工作如果想要查看详细的说明可以查看 next 安装Hexo1$ npm install -g hexo-cli 博客初始化123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 下载主题12$ cd &lt;folder&gt;$ git clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题，编辑_config.yml，找到theme字段，改为next 1theme: next 验证主题 hexo s –debug，显示以下内容，访问http://localhost:4000如果发现未生效，清除Hexo静态文件hexo clean再执行，以后的步骤任意改动类似。 1INFO Hexo is running at http://0.0.0.0:4000/. Press Ctrl+C to stop. 配置选择设计效果Scheme，修改themes\next_config.yml，我采用的主题版本实现了四种效果，选取了Gemini。12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini 设置中文_config.yml 1language: zh-Hans 设置菜单themes\next_config.yml，Next使用的是Font Awesome，如果你想要的菜单图标没有显示，可以在网站上寻找理想的图标并在 ||后修改。如果想要icon生效，可以将menu_icons的enable设置为true 123456789menu: home: / || home about: /About/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 设置头像themes\next_config.yml，可以选取互联网地址或者本地地址1avatar: http://www.wuzequn.com/images/touxiang.png 设置代码高亮themes\next_config.yml，next使用的是Tomorrow Theme，可以在链接中查看高亮效果。12345# Code Highlight theme# Available value:# normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night 设置侧边栏社交链接themes\next_config.yml，图标的设置和菜单类似。1234567891011# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: #GitHub: https://github.com/yourname || github 邮件: mailto:wuzqbupt@gmail.com || envelope 知乎: https://www.zhihu.com/people/wu-ze-qun || globe 微博: https://weibo.com/u/1922768971 || weibo 领英: https://www.linkedin.com/in/zequn-wu-038a5b133/ || linkedin 网页访问量统计themes\next_config.yml，代码是基于不蒜子统计实现的。1234567891011121314151617# Show PV/UV of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; site_uv_footer: # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; site_pv_footer: # custom pv span for one page only page_pv: true page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; page_pv_footer: 本地搜索 安装hexo-generator-searchdb，在站点的根目录下执行以下命令： 1$ npm install hexo-generator-searchdb --save 配置_config.yml，增加以下内容： 12345search: path: search.xml field: post format: html limit: 10000 配置themes\next_config.yml，启用本地搜索功能 12345search: path: search.xml field: post format: html limit: 10000 其他类似于昵称和站点描述等信息可以在_config.yml里修改。 内容编辑Hexo的内容都可以用Markdown，具体的格式可以参考教程 about页面首先生成about页面，首先在站点的根目录下执行以下命令：1$ hexo new page About 然后会在source目录下生成一个About文件夹，然后编辑source/About/index.md介绍你自己。 tags页面首先生成about页面，首先在站点的根目录下执行以下命令：1$ hexo new page tags 然后会在source目录下生成一个tags文件夹，然后编辑source/tags/index.md，修改为:123456---title: tagsdate: 20xx-xx-xx xx:xx:xxtype: &quot;tags&quot;comments: false--- categories页面首先生成categories页面，首先在站点的根目录下执行以下命令：1$ hexo new page categories 然后会在source目录下生成一个categories文件夹，然后编辑source/categories/index.md，修改为:123456---title: categoriesdate: 20xx-xx-xx xx:xx:xxtype: &quot;categories&quot;comments: false--- 内容操作hexo有三种内容类型，分别文page，post，draft。可以用以下内容新建：1$ hexo new [page|post|code] &lt;file-name&gt; page就是基础页面，你可以在http;//127.0.0.1/后添加页面名称访问到对应文件夹下内容。 post新建到source目录下，名称就是文件名称。 如果不想发布未编辑完成的草稿，可以新建draft，待编辑完成，发布草稿。1$ hexo publish &lt;draft-name&gt; 发布网站Hexo是用脚本将Markdown文件生成静态html页面的工具，用一下命令生成一个public静态文件夹。1$ hexo generate 同时，Hexo也提供了一个服务器用于显示内容。ye也可以加-p选项配置http端口，默认为40001$ hexo server 如果发现你的修改没有生效，可以执行以下命令清楚数据文件和public文件夹，之后再重新生成。1$ hexo clean 另外，hexo也提供了将静态文件夹部署的功能，我使用了码市作为git仓库网站，具体配置git方法可以参考，本地需要配置_config.yml并安装hexo-deployer-git，更多部署方式可以参考123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://&lt;git-address&gt; branch: &lt;branch-name&gt; 执行以下命令，就可以将public中的静态文件上传到git仓库。1$ hexo deploy 如果你采用Github.io作为展示方案，参考教程，执行完部署步骤，就可以将静态文件部署到Github.io上。 其他修改操作 hexo插入本地图片资源 插入公式：在博客的添加mathjax: true 常用的Markdown数学公式 Markdown插入Jupyter Notebook vpsvps购买由于之后还需要搭建科学上网小工具和ipv6工具，所以在选取vps运营商的时候看重有ipv6出口，所以根据同学建议选择了搬瓦工OpenVZ的云主机。 之后又调研了vps运营商，发现还有AplhaRacks的7美元方案，对于不注重运行速度的童鞋可以采用这个方案。 同时推荐直呼过瘾，查询性价比比较高的方案，但是要注意如果要搭建ipv6小工具，需要注意vps中有ipv6通道。 博客配置环境：CentOS 7 64 bit 博客采用的是Nginx作为Web服务器，安装Nginx：12$ sudo yum install epel-release$ sudo yum install nginx 从git拉取代码并授权123$ git clone https://&lt;your-repo-address&gt;$ cd &lt;git-dir&gt;$ sudo chmod -R 777 . 配置Nginx，将Nginx访问的根目录配置为本地仓库的根目录。修改/etc/nginx/nginx.conf中的内容。12345678910111213141516171819202122server &#123; listen 80 default_server; listen [::]:80 default_server; server_name _; # root /usr/share/nginx/html; root &lt;your-repo-local-path&gt;; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; index index.html; autoindex on; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125;&#125; https配置CentOS可以参考DigitalOcean的解决方案。 但是，配置了HTTPS之后，如果不购买CA证书，Chrome就会在网站显示Not Secure。如果觉得不需要购买，可以取消HTTPS。 12345678# 失效SSL$ mv /etc/nginx/conf.d/ssl.conf /etc/nginx/conf.d/ssl.conf.bak # 失效redirect$ mv /etc/nginx/default.d/ssl-redirect.conf /etc/nginx/default.d/ssl-redirect.conf.bak# 检测配置文件格式$ nginx -t# 是配置生效$ nginx -s reload 此时，访问就会恢复HTTP。如果发现未生效，清除Chrome缓存数据。 2018-09-24 更新可以使用免费CA证书，我使用的是Let’s Encrypt，步骤如下: 123456789101112131415161718192021222324252627282930# 准备工作 python环境# 检查系统是否安装git,如果已经自带有git会出现git版本号，没有则需要我们自己安装git --version # git 安装yum install git# 检查Python的版本是否在2.7以上python -v //2.6版本# 安装python所需的包yum install zlib-develyum install bzip2-develyum install openssl-develyum install ncurses-develyum install sqlite-devel# 获取letsencryptgit clone https://github.com/letsencrypt/letsencrypt# 进入letsencrypt目录cd letsencrypt# 生成证书 -nginx为例./certbot --nginx certonly# 然后输入你的邮箱和所要添加https的域名# 生成秘钥完毕 上文DigitalOcean的解决方案中提到的nginx配置文件的秘钥路径：123#打开linux配置文件，找到HTTPS 443端口配置的server ssl_certificate /etc/letsencrypt/live/域名/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/域名/privkey.pem; 修改http配置，将http转成https服务：12345server &#123; listen 80; server_name 域名; return 301 https://域名$request_uri; &#125; 此时，CA证书90天会过期，过期所以需要续签：1./letsencrypt-auto renew --force-renewal 最后你可以通过以下网址检测https服务1https://www.ssllabs.com/ssltest/analyze.html?d=域名 域名注册域名注册商很多，国内需要实名注册，要求的内容较多且周期比较长。国外的注册商通常自己提供DNS服务器，对速度有一定的影响。 如果不是米商，个人博客通常还是选取性价比高的注册商。域名的购买需要注意两个要点： 注册价格，可以使用比价网站。 注意续租价格，一般.com的网站每年价格相同。 注册成功后将云主机ip绑定，绑定DNS可以参考百度经验。 校外访问bt ipv6小工具服务器端上网工具其实就是将本地无法访问的请求发送给可以访问的服务器，服务器取回数据后再转发给客户端。如上文，服务器采用的是搬瓦工的VPS，所以首先要在控制面板上开启ipv6地址。以root安装ss服务。123wget --no-check-certificate -O shadowsocks-go.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks-go.shchmod +x shadowsocks-go.sh./shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log 安装中会选择转发的端口和密码。安装完成后，会提示：12345678Congratulations, Shadowsocks-go server install completed!Your Server IP :your_server_ipYour Server Port :your_server_portYour Password :your_passwordYour Encryption Method:your_encryption_methodWelcome to visit:https://teddysun.com/392.htmlEnjoy it! 如果安装成功，ss服务会开机自动启动。 如果想卸载，可以执行：1./shadowsocks-go.sh uninstall 如果想要为多用户并行服务，可配置多转发端口，编辑/etc/shadowsocks/config.json:123456789101112&#123; &quot;server&quot;:&quot;0.0.0.0&quot;, &quot;port_password&quot;:&#123; &quot;8989&quot;:&quot;password0&quot;, &quot;9001&quot;:&quot;password1&quot;, &quot;9002&quot;:&quot;password2&quot;, &quot;9003&quot;:&quot;password3&quot;, &quot;9004&quot;:&quot;password4&quot; &#125;, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;timeout&quot;:600&#125; 配置成功之后重启服务1234/etc/init.d/shadowsocks start/etc/init.d/shadowsocks stop/etc/init.d/shadowsocks restart/etc/init.d/shadowsocks status 2019-04-28更新另外，因为OVZ更新了，所以如果你使用的是KVM架构，也可以参考搬瓦工这篇文章用渠道技术搞定IPV6 客户端下载客户端，然后根据服务器的配置，编辑端口和密码。同时，shadowsocks客户端可以设置PAC规则，节省转发流量，也可以在PAC文件中增加转发网址。设置好后可以访问ipv6和科学上网，可以北邮人bt测试。 设置utorrent 打开设置 -&gt; 连接 代理服务选择socks5，代理127.0.0.1，端口1080，勾选通过代理服务器解析主机名和 对于点对点连接使用代理服务器 如果设置的系统代理方式为PAC代理，需要在PAC文件中加入.byr,cn。 其余工具安装 因为关于环境的安装都属于服务器运维相关的工作，所以将链接放到下面，以备以后使用 docker-ce因为使用的是搬瓦工，如果直接使用yum的docker版本会出现engine安装问题，所以使用搬瓦工官方的处理方法 ngrok内网穿透工具当服务处于内网过程中，客户端无法直接访问接口，这时候需要使用NAT转换代理，除了使用Nginx做代理，还可以使用Ngrok]]></content>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
</search>
